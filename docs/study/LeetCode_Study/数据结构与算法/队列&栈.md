# 队列&栈

> [探索--队列 & 栈](https://leetcode-cn.com/explore/learn/card/queue-stack/)

## 队列：先入先出的数据结构

1. 设计循环队列

    + 语言：java

    + 思路：用count记录数量，和capacity对比来看是否空或者满载了。head头指针、tail尾指针。

    + 代码（7ms，58.52%）：

      ```java
      class MyCircularQueue {

          int head,tail;
          int count;
          int capacity;
          int[] queue;

          /** Initialize your data structure here. Set the size of the queue to be k. */
          public MyCircularQueue(int k) {
              head = 0;
              tail = -1;
              count = 0;
              capacity = k;
              queue = new int[k];
          }

          /** Insert an element into the circular queue. Return true if the operation is successful. */
          public boolean enQueue(int value) {
              if(isFull())return false;
              ++count;
              tail = (tail+1)%capacity;
              queue[tail] = value;
              return true;
          }

          /** Delete an element from the circular queue. Return true if the operation is successful. */
          public boolean deQueue() {
              if(isEmpty())return false;
              --count;
              head = (head+1)%capacity;
              return true;
          }

          /** Get the front item from the queue. */
          public int Front() {
              return isEmpty()?-1:queue[head];
          }

          /** Get the last item from the queue. */
          public int Rear() {
              return isEmpty()?-1:queue[tail];
          }

          /** Checks whether the circular queue is empty or not. */
          public boolean isEmpty() {
              return count==0;
          }

          /** Checks whether the circular queue is full or not. */
          public boolean isFull() {
              return count==capacity;
          }
      }
      ```

    + 参考代码1（3ms）：删除count和capacity，直接通过head头指针和tail尾指针判断空和满的情况。

      多申请了一个空间，方便判断空和满的情况。

      这里tail指向下一个要插入元素的位置，而不是现存的最后一个元素。

      ```java
      class MyCircularQueue {

          int[] data;
          int s, e;

          public  MyCircularQueue(int k) {
              data = new int[k + 1];
          }

          /**
           * Insert an element into the circular queue. Return true if the operation is successful.
           */
          public boolean enQueue(int value) {
              if (isFull()) {
                  return false;
              }
              data[s] = value;
              s = (s + 1) % data.length;
              return true;
          }

          /**
           * Delete an element from the circular queue. Return true if the operation is successful.
           */
          public boolean deQueue() {
              if (isEmpty()) {
                  return false;
              }
              e = (e + 1) % data.length;
              return true;
          }

          public int Front() {

              if (isEmpty()) {
                  return -1;
              }
              return data[e];
          }

          /**
           * Get the last item from the queue.
           */
          public int Rear() {
              if (isEmpty()) {
                  return -1;
              }
              return data[(s - 1 + data.length) % data.length];
          }

          /**
           * Checks whether the circular queue is empty or not.
           */
          public boolean isEmpty() {
              return s == e;
          }

          /**
           * Checks whether the circular queue is full or not.
           */
          public boolean isFull() {
              return e == (s + 1) % data.length;
          }

      }
      ```

## 队列和广度优先搜索

1. 岛屿数量

    + 语言：java

    + 思路：每次遇到岛屿，借助DFS扩展、标记。然后岛屿数量计数+1，寻找下一个岛屿位置（前面借助DFS已经把本次遇到的岛屿都标记了，不会再遇到了）。

    + 代码（2ms，97.40%）：

      ```java
      class Solution {
          public int numIslands(char[][] grid) {
              int res = 0;
              for(int i = 0,lenX = grid.length;i<lenX;++i){
                  for(int j = 0,lenY = grid[0].length;j<lenY;++j){
                      if(grid[i][j]=='1'){
                          dfs(grid,i,j);
                          ++res;
                      }
                  }
              }
              return res;
          }

          public void dfs(char[][] grid,int x,int y){
              if(x<0||x>=grid.length||y<0||y>=grid[0].length) // 边界外
                  return;
              if(grid[x][y]=='0') // 已经走过了
                  return;
              grid[x][y] = '0';
              dfs(grid,x-1,y); // 上
              dfs(grid,x,y+1); // 右
              dfs(grid,x+1,y); // 下
              dfs(grid,x,y-1); // 左
          }
      }
      ```

    + 参考代码1（1ms）：本质思路没区别，就写法稍微有一点点点不一样。

      ```java
      class Solution {
          public int numIslands(char[][] grid) {
              if (grid == null || grid.length == 0) {
                  return 0;
              }
              int count = 0;
              int rowMax = grid.length;
              int columnMax = grid[0].length;
              for (int row = 0; row < rowMax; row++) {
                  for (int column = 0; column < columnMax; column++) {
                      if  (grid[row][column] == '1') {
                          count++;
                          helper(grid, row, column);
                      }
                  }
              }
              return count;
          }
          public void helper(char[][] grid, int row, int column) {
              if (row < 0 || row >= grid.length || column < 0 || column >= grid[0].length || grid[row][column] != '1') {
                  return;
              }
              grid[row][column] = '0';
              helper(grid, row - 1, column);
              helper(grid, row + 1, column);
              helper(grid, row, column - 1);
              helper(grid, row, column + 1);
          }

      }
      ```

2. 打开转盘锁

    + 语言：java

    + 思路：BFS，从0000到结果，或者结果到0000的情况很好想到，就每轮BFS尝试4个位置的向上、向下转动共8种情况（1轮）。直到遇到终点或者遇到死路。

      > [我写了一套 BFS 算法框架，见到 BFS 直接套](https://leetcode-cn.com/problems/open-the-lock/solution/wo-xie-liao-yi-tao-bfs-suan-fa-kuang-jia-jian-dao-/)

    + 代码1（97ms，64.05%）：单向BFS。

      ```java
      class Solution {
          public int openLock(String[] deadends, String target) {
              // (1) deadends存到HashSet以便下面判断，之后visited也存这里
              HashSet<String> visited = new HashSet<>();
              for(String deadend:deadends){
                  visited.add(deadend);
              }

              // (2) 初始化BFS要用到的队列queue
              Queue<String> queue = new LinkedList<>();
              queue.add("0000");

              int res = -1;
              String cur;
              while(!queue.isEmpty()){
                  // 每轮BFS遍历当前所有子节点可能情况
                  int size = queue.size();
                  while (size>0){
                      cur = queue.poll();
                      --size;
                      // <1> 浏览过相同的了，或者这个是思路deadends，就继续取queue的下一个元素
                      if(visited.contains(cur))
                          continue;
                      // <2> 遇到结果了直接返回答案。
                      if(cur.equals(target))
                          return res+1;
                      // <3> 获取所有可能的走法，共4位，每一位都可能往上拨动or往下拨动，共8种可能
                      for(int i = 0;i<4;++i){
                          queue.add(upLock(cur,i));
                          queue.add(downLock(cur,i));
                      }
                      // <4> 标记当前弹出的String串已经访问过
                      visited.add(cur);
                  }
                  // 该轮没找到答案，继续下一轮
                  ++res;
              }
              return -1;// 没找到才可能走到这里，没找到返回-1
          }

          // 往上拨动锁
          public String upLock(String str,int index){
              char[] chars = str.toCharArray();
              if(chars[index]=='9')
                  chars[index] = '0';
              else
                  chars[index]+=1;
              return new String(chars);
          }

          // 往下拨动锁
          public String downLock(String str,int index){
              char[] chars = str.toCharArray();
              if(chars[index]=='0')
                  chars[index] = '9';
              else
                  chars[index]-=1;
              return new String(chars);
          }
      }
      ```

    + 代码2（25ms，94.94%）：双向DFS。用HashSet代替queue，使用两个HashSet，BFS原本一般是从head->tail判断是否含有目标target，这里分别从head->tail和从tail->head，那么只要两个碰头了，说明"0000"可以到target，且target可以到"0000"。

      中间需要注意的就是，每轮固定遍历queue1，但是实际每轮过后queue1和queue2会有一个对调操作，也就是一轮head->tail进行BFS，一轮tail->head进行BFS。

      双向BFS好处就是可以减少存储中间节点，因为单项BFS，如果是树的话，越下面加入queue的节点越多；如果头->尾和尾->头的BFS同时进行，既可以避免round回合数越多，queue暂存的节点过多的问题。

      ```java
      class Solution {
          public int openLock(String[] deadends, String target) {
              // (1) deadends存到HashSet以便下面判断，之后visited也存这里
              HashSet<String> visited = new HashSet<>();
              for(String deadend:deadends){
                  visited.add(deadend);
              }

              // (2) 初始化"双向BFS"要用到的2个HashSet(因为只要碰头就表示找到了，所以用HashSet方便判断交集)
              HashSet<String> queue1 = new HashSet<>();
              HashSet<String> queue2 = new HashSet<>();
              queue1.add("0000");
              queue2.add(target);

              int res = -1;
              String cur;
              while(!queue1.isEmpty()&&!queue2.isEmpty()){
                  //用于存储queue1下一轮要遍历的节点。
                  HashSet<String> temp = new HashSet<>();
                  for(String str:queue1){
                      // <1> 浏览过相同的了，或者这个是思路deadends，就继续取queue的下一个元素
                      if(visited.contains(str))
                          continue;
                      // <2> 如果另一个queue2含有当前queue1的元素，说明碰头了head-> str <- tail
                      if(queue2.contains(str))
                          return res+1;
                      // <3> 获取所有可能的走法，共4位，每一位都可能往上拨动or往下拨动，共8种可能
                      for(int i = 0;i<4;++i){
                          temp.add(upLock(str,i));
                          temp.add(downLock(str,i));
                      }
                      // <4> 标记当前弹出的String串已经访问过
                      visited.add(str);
                  }
                  // 该轮没找到答案，继续下一轮
                  ++res;
                  // queue1永远是下一轮要遍历的节点组
                  // queue2则是下下轮的
                  // 双向BFS，假如分别从头到尾和从尾到头；那么 head->tail ; tail->head ; head->tail ....
                  queue1 = queue2;
                  queue2 = temp;
              }
              return -1;// 没找到才可能走到这里，没找到返回-1
          }

          // 往上拨动锁
          public String upLock(String str,int index){
              char[] chars = str.toCharArray();
              if(chars[index]=='9')
                  chars[index] = '0';
              else
                  chars[index]+=1;
              return new String(chars);
          }

          // 往下拨动锁
          public String downLock(String str,int index){
              char[] chars = str.toCharArray();
              if(chars[index]=='0')
                  chars[index] = '9';
              else
                  chars[index]-=1;
              return new String(chars);
          }
      }
      ```

    + 参考代码1（1ms）：直接先判断是否可能到达targrt（把target的8种拨动情况全考虑一遍），然后就直接数字计算需要走的步数。

      ```java
      class Solution {
          public int openLock(String[] deadends, String target) {
              List<String> deals = Arrays.asList(deadends);
              if (deals.contains("0000")) return -1;
              final List<String> options = new ArrayList<>();
              char[] cs;
              char c;
              int zero = '0';
              for (int i = 0; i < 4; i++ ){
                  cs = target.toCharArray();
                  c = cs[i];
                  cs[i] = (char) ((c - zero + 1) % 10 + zero);
                  options.add(new String(cs));
                  cs[i] = (char) ((c - zero + 9) % 10 + zero);
                  options.add(new String(cs));
              }
              options.removeAll(deals);
              if (options.isEmpty()) return -1;
              int step = Integer.MAX_VALUE;
              for ( String option : options ){
                  int curStep = 1;
                  cs = option.toCharArray();
                  for ( int i = 0; i < 4; i++ ){
                      int num = cs[i] - zero;
                      if (num > 5) curStep += 10 - num;
                      else curStep += num;
                  }
                  step = Math.min(curStep, step);
              }
              return step;
          }
      }
      ```

3. 完全平方数

    + 语言：java

    + 思路：整体上是BFS，需要让"组成和的完全平方数的个数"最少，可以理解为，以n作为根节点，然后每一层子树都是减去某一个完全平方数后的值，这样来计算最小深度。树的最小深度就可以用BFS写了。

      1. 先计算出所有可能出现的完全平方数，可以用for循环i\*i<=n实现，方便遍历。（计算每层子树的值，root-X = 当前层某子树值）
      2. BFS（~~使用queue~~）使用HashSet（因为会有重复计算，草稿纸上画画树就知道了），(~~每轮根据当前queue大小（某一层拥有的节点总数）作为一层for循环~~)**HashSet不方便直接边添加边遍历**，所以这里用一个临时HashSet存储下一层，接着每轮替换一下HashSet引用，指向刚才临时创建的下一层就好了。
      3. 每一层计算下一层，每个子树都需要遍历完全平方数，又是一个for循环。

    + 代码（45ms，49.29%）：

      ```java
      class Solution {
          public int numSquares(int n) {
              // (1) 计算并存储所有可能用到的完全平方数
              ArrayList<Integer> squares = new ArrayList<>();
              for(int i = 1;i*i<=n;++i){
                  squares.add(i*i);
              }

              // (2) 初始化BFS要用到的HashSet(因为会有重复计算)，加入根节点n
              HashSet<Integer> curFloor = new HashSet<>();
              curFloor.add(n);

              int res = 0;
              // (3) BFS常见套路之 最外层while判断HashSet非空
              while(!curFloor.isEmpty()){
                  ++res; // 层数+1(结果值+1)
                  HashSet<Integer> nextFloor = new HashSet<>(); // 存储下一层节点
                  // (4) 遍历每一层树节点BFS每一轮就是一层
                  for(int curNode:curFloor){
                      // (5) 每一层所有的树节点，每一个都需要和之前存的"完全平方数"计算差值，作为自己下面一层的子节点加入queue
                      for(int num:squares){
                          if(curNode==num) // 如果当前节点的值已经就是某个"完全平方数"了，那么直接返回层数res
                              return res;
                          else if(curNode<num) // 如果不够减了，就没必要继续遍历"完全平方数"了。进入外层循环，计算同层别的节点的子树
                              break;
                          else
                              nextFloor.add(curNode-num); // 下一层子树，比如完全平方数有1 2 4 ...，当前curNode 5，那么其子树就是 4、3 和 1
                      }
                  }
                  // (6) 调换引用，curFloor引用指向下一层
                  curFloor = nextFloor;
              }
              return res;
          }
      }
      ```

    + 参考代码1（41ms）：DP动态规划，从1计算到n，利用dp\[0]是0，最外层for遍历从1~n，每次初始化dp\[i]=i，也就是假设最坏情况，数字i由i个1组成，然后再计算`dp[i] = min(dp[i],dp[i-j*j]+1)`，这里`dp[i-j*j]+1`可能是`dp[0]+1`也就是`0+1=1`。

      ```java
      class Solution {
          public int numSquares(int n) {
              int[] dp = new int[n + 1];
              for(int i = 1; i <= n; i ++){
                  dp[i] = i;
                  for(int j = 1; i - j * j >= 0; j ++){
                      dp[i] = Math.min(dp[i], dp[i - j * j] + 1);
                  }
              }

              return dp[n];
          }
      }
      ```

    + 参考代码2（1ms）：数学方法，没啥好值得学习的。

      ```java
      import java.util.*;
      class Solution {
          public int numSquares(int n) {
              int num = n;
              //判断4个的情况
              while (num % 4 == 0) {
                  num /= 4;
              }
              if (num % 8 == 7) {
                  return 4;
              }
              num = n;
              if (isSqure(num)) {
                  return 1;
              }
              for (int i = 1; i < Math.sqrt(n) + 1; i++) {
                  if (isSqure(n - i * i)) {
                      return 2;
                  }
              }
              return 3;
          }

          boolean isSqure(int num) {
              int sqrt = (int) Math.sqrt(num);
              if (sqrt * sqrt == num) {
                  return true;
              }
              return false;
          }
      }
      ```

## 栈：后进先出的数据结构

1. 最小栈

    + 语言：java

    + 思路：维护两个栈，一个是题目要求的存储所有数据的栈，另一个是单调递减的单调栈（方便获取最小值）。

    + 代码（6ms，97.08%）：

      ```java
      class MinStack {

          LinkedList<Integer> stack; // 存放所有值的栈
          LinkedList<Integer> minStack; // 维持一个递减的最小单调栈

          /** initialize your data structure here. */
          public MinStack() {
              stack = new LinkedList<>();
              minStack = new LinkedList<>();
          }

          public void push(int x) {
              stack.addFirst(x);
              if(minStack.isEmpty()||minStack.peekFirst()>=x)
                  minStack.addFirst(x);
          }

          public void pop() {
              if(stack.pollFirst().equals(minStack.peekFirst()))
                  minStack.pollFirst();
          }

          public int top() {
              return stack.peekFirst();
          }

          public int getMin() {
              return minStack.peekFirst();
          }
      }
      ```

    + 参考代码1（3ms）：利用自定义链表维护min最小值，主要没有实际的`pop`操作，只是移动链表指针，所以更轻量级，更快。

      ```java
      class MinStack {
          private Node head;
          /** initialize your data structure here. */
          public MinStack() {

          }

          public void push(int x) {
              if (head == null) {
                  head = new Node(x, x);
              } else {
                  head = new Node(x, Math.min(x, head.min), head);
              }

          }

          public void pop() {
              head = head.next;
          }

          public int top() {
              return head.val;
          }

          public int getMin() {
              return head.min;
          }

          private class Node {
              int val;
              int min;
              Node next;

              private Node(int val, int min) {
                  this(val, min, null);
              }

              private Node(int val, int min, Node next) {
                  this.val = val;
                  this.min = min;
                  this.next = next;
              }
          }
      }
      ```

2. 有效的括号

    + 语言：java

    + 思路：就直接判断是否是某种左括号，是的话就入栈，否则就是遇到了某种右括号，试图和栈中元素匹配并出栈。不过这里已经明确了所有元素，可以考虑直接用一个数组和指针配合模拟栈。

      这里直接把原字符串转换的字符数组当作栈使用。

    + 代码（0ms，100%）：

      ```java
      class Solution {
          public boolean isValid(String s) {
              char[] stack = s.toCharArray();
              int top = 0, index = 0;//top表示栈顶指针，index则是遍历元素的指针
              int len = s.length();
              while(index<len){
                  switch (stack[index]){
                      case '(':
                      case '[':
                      case '{':
                          stack[top++] = stack[index]; // 直接把原字符串转换的字符数组当栈用
                          break;
                      case ')':
                          if(top<1||stack[top-1]!='(')
                              return false;
                          --top;
                          break;
                      case ']':
                          if(top<1||stack[top-1]!='[')
                              return false;
                          --top;
                          break;
                      case '}':
                          if(top<1||stack[top-1]!='{')
                              return false;
                          --top;
                          break;
                  }
                  ++index;
              }
              return top==0;
          }
      }
      ```

    + 参考代码1（0ms）：思路一样，就是写法略有不同。

      ```java
      class Solution {
          public boolean isValid(String s) {
              char[] charArray = new char[s.length() + 1];

              int p = 1;

              for (char c : s.toCharArray()) {
                  if (c == '(' || c == '{' || c == '[') {
                      charArray[p++] = c;
                  } else {
                      p--;
                      if (c == ')' && charArray[p] != '(') {
                          return false;
                      }
                      if (c == '}' && charArray[p] != '{') {
                          return false;
                      }
                      if (c == ']' && charArray[p] != '[') {
                          return false;
                      }
                  }
              }
              return p == 1; // 如果左括号还有剩余 括号没有一一对应，属于无效情况
          }
      }
      ```

3. 每日温度

    + 语言：java

    + 思路：

      1. 需要暂存的是小于或等于当前遍历到的数字，就想到队列或者栈，这里判断我们只需要存大数，小的中间需要去掉，那么就是栈了。
      2. 再加上"如果气温在这之后都不会升高"这句提示性的话，并且每次存的都是小于等于自己的数字，所以我们维护的应该是一个单调递减栈。

      3. 由于我们需要在出栈的时候，根据下标的差值判断是某一位置后第几天遇到高温，那么栈中需要存的就是下标值而不是具体的数值。

    + 代码（16ms，80.66%）：

      ```java
      class Solution {
          public int[] dailyTemperatures(int[] T) {
              int len = T.length;
              int[] res = new int[len];
              LinkedList<Integer> stack = new LinkedList<>();//单调递减栈(因为要是大于栈顶，就直接得出某一位置的结果了)
              for(int i = 0,topIndex;i<len;++i){
                  while(!stack.isEmpty()&&T[stack.peekFirst()]<T[i]){
                      topIndex = stack.pollFirst();
                      res[topIndex] = i-topIndex;
                  }
                  stack.addFirst(i);// 把当前元素加入栈顶
              }
              return res;
          }
      }
      ```

    + 参考代码1（3ms）：从后往前，外层for循环表示给每个res\[i]计算结果值，内层for循环表示寻找比res[i]大的值，运用了类似KMP算法的技巧，快速跳过绝对不可能出现匹配的位置。

      ```java
      class Solution {
          public int[] dailyTemperatures(int[] T) {
              //特殊值处理
              if(T == null)
                  return null;
              int[] result = new int[T.length];
              for(int i = T.length - 2; i >=0; i--) {
                  int j = i + 1;
                  while(true){
                      if(T[j] > T[i]) {
                          result[i] = j - i;
                          break;
                      } else if (result[j] == 0) {
                          result[i] = 0;
                          break;
                      }
                      j += result[j];
                  }
              }
              return result;
          }
      }
      ```

4. 逆波兰表达式求值

    + 语言：java

    + 思路：题目明确提示，逆波兰表达式如果遇到符号就计算，遇到数字则入栈。

      我们分析下，正确的逆波兰表达式，每次都是取两个数字，然后紧接着一个符号，就直接计算了。居然我们知道明确规律就一定是两数字然后一符号，那么我们连new一个栈都省了，直接通过DFS，在过程中获取两个需要被计算的数字即可。

    + 代码（1ms，100%）：

      ```java
      class Solution {
          String[] tokens; // 方便快速访问tokens
          int topIndex; //模拟栈顶指针

          public int evalRPN(String[] tokens) {
              this.tokens = tokens;
              topIndex = tokens.length - 1; // 从后往前，必定1符号2数字的规律
              return dfs();
          }

          public int dfs() {
              String tmp = tokens[topIndex--];
              int a,b;
              switch (tmp) {
                  case "+":
                      a = dfs();
                      b = dfs();
                      return a + b;
                  case "-":
                      a = dfs();
                      b = dfs();
                      return a - b;
                  case "*":
                      a = dfs();
                      b = dfs();
                      return a * b;
                  case "/":
                      a = dfs();
                      b = dfs();
                      return a / b;
                  default:
                      return Integer.parseInt(tmp);
              }
          }
      }
      ```

## 栈和深度优先搜索

1. 岛屿数量

    + 语言：java

    + 思路：遇到岛屿的土地`1`，就计数器+1，然后DFS把整个岛屿都遍历标记成`非1`的任意元素，这里标记走过的土地为`0`

    + 代码（2ms，97.46%）：

      ```java
      class Solution {
          public int numIslands(char[][] grid) {
              int res = 0;
              for(int i =0;i<grid.length;++i){
                  for(int j =0;j<grid[0].length;++j){
                      if(grid[i][j]=='1'){
                          ++res;
                          dfs(grid,i,j);
                      }
                  }
              }
              return res;
          }

          public void dfs(char[][] grid,int x,int y){
              if(x<0||x>=grid.length||y<0||y>=grid[0].length||grid[x][y]!='1')
                  return;
              grid[x][y]='0';
              dfs(grid,x-1,y); // 上
              dfs(grid,x,y+1); // 右
              dfs(grid,x+1,y); // 下
              dfs(grid,x,y-1); // 左
          }
      }
      ```

    + 参考代码1（1ms）：很可惜看了下没什么太大区别。

      ```java
      class Solution {

          public int numIslands(char[][] grid) {
              if (grid == null || grid.length == 0) {
                  return 0;
              }
              int num = 0;
              int k = grid.length;
              int h = grid[0].length;
              for (int i = 0; i < k; i++) {
                  for (int j = 0; j < h; j++) {
                      if (grid[i][j] == '1') {
                          num++;
                          dfs(grid, i, j, k, h);
                      }
                  }
              }
              return num;
          }

          private void dfs(char[][] grid, int i, int j, int k, int h) {
              if (i < 0 || j < 0 || i >= k || j >= h || grid[i][j] == '0' ) {
                  return ;
              }
              grid[i][j] = '0';
              dfs(grid, i-1, j, k, h);
              dfs(grid, i+1, j, k, h);
              dfs(grid, i, j-1, k, h);
              dfs(grid, i, j+1, k, h);
          }

      }
      ```

2. 克隆图

    + 语言：java

    + 思路：DFS，先是很好想到的部分，遍历原node的neighbors，然后添加到新结点的neighbors。再来，考虑什么时候创建新结点。如果当前node存在（不为null）并且没出现过（出现过直接返回之前新建过的），那么新建一个新节点。

      1. 是否需要新建结点。
      2. 遍历结点，把邻居结点都添加到这个新建的结点上。（DFS调用）
      3. 返回新建的结点

      > [DFS 和 BFS](https://leetcode-cn.com/problems/clone-graph/solution/dfs-he-bfs-by-powcai/)

    + 代码1（40ms，22.23%）：DFS

      ```java
      /*
      class Node {
          public int val;
          public List<Node> neighbors;

          public Node() {
              val = 0;
              neighbors = new ArrayList<Node>();
          }

          public Node(int _val) {
              val = _val;
              neighbors = new ArrayList<Node>();
          }

          public Node(int _val, ArrayList<Node> _neighbors) {
              val = _val;
              neighbors = _neighbors;
          }
      }
      */

      class Solution {
          public Node cloneGraph(Node node) {
              return dfs(node, new HashMap<>());
          }

          public Node dfs(Node node, HashMap<Node,Node> map) {
              if(node==null) return null;
              if(map.containsKey(node))return map.get(node);
              Node cur = new Node(node.val,new ArrayList<>());
              map.put(node,cur);
              for(Node mem:node.neighbors){
                  cur.neighbors.add(dfs(mem,map));
              }
              return cur;
          }
      }
      ```

    + 代码2（37ms，52.77%）：BFS。把图当作类似树的结构来写，一次遍历一层。如果遇到未拷贝的结点，就拷贝一个。把子节点添加到父节点的邻居列表中。

      ```java
      class Solution {
          public Node cloneGraph(Node node) {
              if(node==null)
                  return null;
              Node res = new Node(node.val,new ArrayList<>());
              HashMap<Node,Node> map = new HashMap<>();
              map.put(node,res);
              Queue<Node> queue = new LinkedList<>();
              queue.add(node);
              while(!queue.isEmpty()){
                  Node cur = queue.poll();
                  for(Node mem: cur.neighbors){
                      if(!map.containsKey(mem)){
                          map.put(mem,new Node(mem.val,new ArrayList<>()));
                          queue.add(mem);
                      }
                      map.get(cur).neighbors.add(map.get(mem));
                  }
              }
              return res;
          }
      }
      ```

    + 参考代码1（26ms）：其实和上面DFS代码差不多，就是减少了一点调用栈。

      ```java
      class Solution {

          Map<Node, Node> copies;

          public Node cloneGraph(Node node) {
              if (node == null) {
                  return node;
              }
              copies = new HashMap<>();

              return dfs(node);
          }

          private Node dfs(Node node) {
              if (node == null) {
                  return node;
              }
              if (copies.containsKey(node)) {
                  return copies.get(node);
              }
              Node copy = new Node(node.val);
              // 一定要在递归之前就把copy放进Map不然就会扑街
              copies.put(node, copy);
              List<Node> newNb = new ArrayList<>();
              for (Node neighbor : node.neighbors) {
                  if (copies.containsKey(neighbor)) {
                      newNb.add(copies.get(neighbor));
                  } else {
                      newNb.add(dfs(neighbor));
                  }
              }

              copy.neighbors = newNb;

              return copy;
          }
      }
      ```

3. 目标和

    + 语言：java

    + 思路：看着就是直接DFS，然后记录出现结果的次数。

      + 终止条件：下标达到`nums.length`。
      + 递归：加上当前遍历数字or减去当前遍历数字。

    + 代码（611ms，33.28%）：史诗级慢

      ```java
      class Solution {
          int res = 0;

          public int findTargetSumWays(int[] nums, int S) {
              dfs(nums,S,0,0);
              return res;
          }

          public void dfs(int[] nums,int S,int index,int sum){
              if(index==nums.length){
                  if(sum==S)
                      ++res;
              }else{
                  dfs(nums,S,index+1, sum+nums[index]);
                  dfs(nums,S,index+1, sum-nums[index]);
              }
          }
      }
      ```

    + 参考代码1（1ms）：动态规划+01背包问题

      原问题等同于： 找到nums一个正子集和一个负子集，使得总和等于target

      我们假设P是正子集，N是负子集 例如： 假设nums = [1, 2, 3, 4, 5]，target = 3，一个可能的解决方案是+1-2+3-4+5 = 3 这里正子集P = [1, 3, 5]和负子集N = [2, 4]

      那么让我们看看如何将其转换为子集求和问题：

      ```none
                        sum(P) - sum(N) = target
      sum(P) + sum(N) + sum(P) - sum(N) = target + sum(P) + sum(N)
                             2 * sum(P) = target + sum(nums)
      ```

      因此，原来的问题已转化为一个求子集的和问题： 找到nums的一个子集 P，使得sum(P) = (target + sum(nums)) / 2

      请注意，上面的公式已经证明target + sum(nums)必须是偶数，否则输出为0 

      java代码示例：

      ```java
      class Solution {
          public int findTargetSumWays(int[] nums, int S) {
              int sum = 0;
              for (int n : nums) sum += n;

              int res = sum < S || (sum + S) % 2 > 0 ? 0 : subsetSum(nums, (sum + S) >> 1);

              return res;

          }
          public int subsetSum(int[] nums, int target) {
              int[] dp = new int[target + 1];
              dp[0] = 1;

              for (int n : nums) {
                  for (int i = target; i >= n; i--) {
                      dp[i] += dp[i - n];
                  }
              }

              return dp[target];
          }
      }
      ```

    + 参考代码2（11ms，70.05%）：这里先计算sum，主要是方便DP动态规划时减少负数下标的出现。

      > [动态规划思考全过程](https://leetcode-cn.com/problems/target-sum/solution/dong-tai-gui-hua-si-kao-quan-guo-cheng-by-keepal/)

      ```java
      class Solution {
          public static int findTargetSumWays(int[] nums, int s) {
              int sum = 0;
              for (int i = 0; i < nums.length; i++) {
                  sum += nums[i];
              }
              // 绝对值范围超过了sum的绝对值范围则无法得到
              if (Math.abs(s) > Math.abs(sum)) return 0;

              int len = nums.length;
              // - 0 +
              int t = sum * 2 + 1;
              int[][] dp = new int[len][t];
              // 初始化
              if (nums[0] == 0) {
                  dp[0][sum] = 2;
              } else {
                  dp[0][sum + nums[0]] = 1;
                  dp[0][sum - nums[0]] = 1;
              }

              for (int i = 1; i < len; i++) {
                  for (int j = 0; j < t; j++) {
                      // 边界
                      int l = (j - nums[i]) >= 0 ? j - nums[i] : 0;
                      int r = (j + nums[i]) < t ? j + nums[i] : 0;
                      dp[i][j] = dp[i - 1][l] + dp[i - 1][r];
                  }
              }
              return dp[len - 1][sum + s];
          }
      }
      ```

    + 参考代码3（2ms）：

      ```java
      class Solution {
          public int findTargetSumWays(int[] nums, int S) {
              int sum = 0;
              //计算数组和
              for(int num:nums){
                  sum+=num;
              }
              //如果数组和小于S且sum(P)是奇数，则没有合适的
              if(sum<S||(sum+S)%2==1){
                  return 0;
              }
              int w = (sum+S)/2;
              int[] dp = new int[w+1];
              dp[0]=1;
              for(int num:nums){
                  for(int j=w;j>=num;j--){
                      dp[j]+=dp[j-num];
                  }
              }
              return dp[w];
          }
      }
      ```

    + 参考后重写1（11ms，70.05%）：DP动态规划

      ```java
      class Solution {
          public int findTargetSumWays(int[] nums, int S) {
              int sum = 0;
              for(int num:nums)
                  sum+=num;
              if(sum<S) // 因为nums所有数字非负数，如果总和小于S，那么S就肯定不可能算出来
                  return 0;
              int len = nums.length;
              int ylen = sum*2+1;// 最多可能就是sum+nums遍历总和，下标从sum开始算，这样可以+也可以-。而sum>=S
              // 下标0 ~ x 计算出 y 的 可能性个数
              int[][] dp = new int[len][ylen];

              // 初始化dp的起始值 下标0位置 计算出 y的可能性 +=1
              dp[0][sum+nums[0]] += 1;
              dp[0][sum-nums[0]] += 1;

              // 外层for循环，遍历 下标1~len-1；0位置前面初始化dp就讨论过了
              // dp[i][j] = dp[i-1][j+nums[i]] + dp[i-1][j-nums[i]]
              for(int i = 1;i<len;++i){
                  // 内层for循环,dp计算出来的 结果值，可能是0到sum*2的任何一种情况
                  for(int j =0;j<ylen;++j){
                      dp[i][j] =
                          dp[i-1][j+nums[i]>=ylen?0:j+nums[i]]
                          +
                          dp[i-1][Math.max(j - nums[i], 0)];
                  }
              }

              return dp[len-1][sum+S];// 初始值是sum而不是0（0的话要讨论下标负数的情况更繁琐）
          }
      }
      ```

4. 二叉树的中序遍历

    + 语言：java

    + 思路：利用`while`和显式栈模拟递归的`系统调用栈`。中序遍历，左中右。先一直往左下走，到尽头回溯，然后尝试往右走。

    + 代码（0ms）：

      ```java
      /**
       * Definition for a binary tree node.
       * public class TreeNode {
       *     int val;
       *     TreeNode left;
       *     TreeNode right;
       *     TreeNode(int x) { val = x; }
       * }
       */
      class Solution {
          public List<Integer> inorderTraversal(TreeNode root) {
              List<Integer> res = new LinkedList<>();
              LinkedList<TreeNode> stack = new LinkedList<>();
              while (root!=null||!stack.isEmpty()) {
                  while(root!=null){
                      stack.addFirst(root);
                      root = root.left;
                  }
                  root = stack.pollFirst();
                  res.add(root.val);
                  root = root.right;
              }
              return res;
          }
      }
      ```

## 小结

1. 用栈实现队列

   + 语言：java

   + 思路：无需解释

   + 代码：

     ```java
     class MyQueue {
     
       private Deque<Integer> deque = new LinkedList<>();
     
       /** Initialize your data structure here. */
       public MyQueue() {
         deque = new LinkedList<>();
       }
     
       /** Push element x to the back of queue. */
       public void push(int x) {
         deque.offer(x);
       }
     
       /** Removes the element from in front of queue and returns that element. */
       public int pop() {
         return deque.pollFirst();
       }
     
       /** Get the front element. */
       public int peek() {
         return deque.peekFirst();
       }
     
       /** Returns whether the queue is empty. */
       public boolean empty() {
         return deque.isEmpty();
       }
     }
     
     /**
      * Your MyQueue object will be instantiated and called as such:
      * MyQueue obj = new MyQueue();
      * obj.push(x);
      * int param_2 = obj.pop();
      * int param_3 = obj.peek();
      * boolean param_4 = obj.empty();
      */
     ```
     

2. 用队列实现栈

   + 语言：java

   + 思路：没啥好说的

   + 代码：

     ```java
     class MyStack {
     
       private Deque<Integer> deque;
     
       /**
          * Initialize your data structure here.
          */
       public MyStack() {
         deque = new LinkedList<>();
       }
     
       /**
          * Push element x onto stack.
          */
       public void push(int x) {
         deque.push(x);
       }
     
       /**
          * Removes the element on top of the stack and returns that element.
          */
       public int pop() {
         return deque.poll();
       }
     
       /**
          * Get the top element.
          */
       public int top() {
         return deque.peek();
       }
     
       /**
          * Returns whether the stack is empty.
          */
       public boolean empty() {
         return deque.isEmpty();
       }
     }
     
     /**
      * Your MyStack object will be instantiated and called as such:
      * MyStack obj = new MyStack();
      * obj.push(x);
      * int param_2 = obj.pop();
      * int param_3 = obj.top();
      * boolean param_4 = obj.empty();
      */
     ```

3. 字符串解码

   + 语言：java

   + 思路：

     + 如果遇到数字，入数字栈；
     + 遇到字母，识别字符串并入栈
     + 遇到"["，入栈
     + 遇到"]"，把之前入栈的数字出栈一个，字符串栈出栈直到遇到"["，每次字符串添加到当前暂存字符串的最前方。然后根据数字次数重复拼接，最后入栈（字符串栈）
     + 最后遍历完后，字符串栈出栈直到为空，每次把弹出的字符串添加到首部，作为结果返回。

   + 代码（1ms，89.51%）：

     ```java
     class Solution {
       public String decodeString(String s) {
         LinkedList<Integer> nums = new LinkedList<>();
         LinkedList<String> strs = new LinkedList<>();
         char[] arrs = s.toCharArray();
         int number = 0;
     
         for (int i = 0; i < arrs.length; ++i) {
           if (arrs[i] >= '0' && arrs[i] <= '9') {
             int tmp = arrs[i] - '0';
             number *= 10;
             number += tmp;
           } else {
             if (number > 0) {
               nums.addFirst(number); // 入栈
               number = 0; // 清零
             }
             if (Character.isLetter(arrs[i])) {
               StringBuilder sb = new StringBuilder();
               while (i < arrs.length && Character.isLetter(arrs[i])) {
                 sb.append(arrs[i++]);
               }
               strs.addFirst(sb.toString());
               --i;
             } else if (arrs[i] == '[') {
               strs.addFirst("[");
             } else if (arrs[i] == ']') {
               int num = nums.pollFirst();
               StringBuilder sb = new StringBuilder();
               String str = strs.pollFirst();
               while (!strs.isEmpty() && !str.equals("[")) {
                 sb.insert(0, str);
                 str = strs.pollFirst();
               }
               str = sb.toString();
               while (--num > 0) {
                 sb.append(str);
               }
               strs.addFirst(sb.toString());
             }
           }
         }
         StringBuilder res = new StringBuilder();
         while (!strs.isEmpty()) {
           res.insert(0, strs.pollFirst());
         }
         return res.toString();
       }
     }
     ```

   + 参考代码1（2ms，52.19%）：使用辅助栈。

     > [字符串解码（辅助栈法 / 递归法，清晰图解）](https://leetcode-cn.com/problems/decode-string/solution/decode-string-fu-zhu-zhan-fa-di-gui-fa-by-jyd/)

     ```java
     class Solution {
       public String decodeString(String s) {
         StringBuilder res = new StringBuilder();
         int multi = 0;
         LinkedList<Integer> stack_multi = new LinkedList<>();
         LinkedList<String> stack_res = new LinkedList<>();
         for(Character c : s.toCharArray()) {
           if(c == '[') {
             stack_multi.addLast(multi);
             stack_res.addLast(res.toString());
             multi = 0;
             res = new StringBuilder();
           }
           else if(c == ']') {
             StringBuilder tmp = new StringBuilder();
             int cur_multi = stack_multi.removeLast();
             for(int i = 0; i < cur_multi; i++) tmp.append(res);
             res = new StringBuilder(stack_res.removeLast() + tmp);
           }
           else if(c >= '0' && c <= '9') multi = multi * 10 + Integer.parseInt(c + "");
           else res.append(c);
         }
         return res.toString();
       }
     }
     ```

   + 参考代码2（0ms，递归法）：和辅助栈总体思路相近。这里比较巧妙的是对左右括号的递归回溯处理。

     比较巧妙的就是指针i的变化。

     ```java
     class Solution {
       public String decodeString(String s) {
         return helper(s, 0)[0];
       }
     
       private String[] helper(String s, int i) {
         StringBuilder res = new StringBuilder();
         int multi = 0;
         while (i < s.length()) {
           if (s.charAt(i) >= '0' && s.charAt(i) <= '9')
             multi = multi * 10 + s.charAt(i) - '0';
           else if (s.charAt(i) == '[') {
             String[] temp = helper(s, i + 1);
             for (int j = 0; j < multi; j++)
               res.append(temp[0]);
             i = Integer.parseInt(temp[1]);
             multi = 0;
           } else if (s.charAt(i) == ']') {
             return new String[]{res.toString(), String.valueOf(i)};
           }
           else
             res.append(s.charAt(i));
           i++;
         }
         return new String[]{res.toString(), String.valueOf(i)};
       }
     }
     ```

4. 图像渲染

   + 语言：java

   + 思路：岛屿问题。注意点就是，涂色可能涂成原本相同的颜色，所以需要判断是否走过。

   + 代码（1ms，98.46%）：

     ```java
     class Solution {
       // 一看就是岛屿问题了
       public int[][] floodFill(int[][] image, int sr, int sc, int newColor) {
         dfs(image,sr,sc,image[sr][sc],newColor,new boolean[image.length][image[0].length]);
         return image;
       }
     
       public void dfs(int[][]image,int x,int y,int oldColor,int newColor,boolean[][] visited){
         if(x<0||x>=image.length||y<0||y>=image[0].length||visited[x][y]||image[x][y]!=oldColor){
           return;
         }
         image[x][y] = newColor;
         visited[x][y] = true;
         dfs(image,x-1,y,oldColor,newColor,visited); //上
         dfs(image,x,y+1,oldColor,newColor,visited); //右
         dfs(image,x+1,y,oldColor,newColor,visited); //下
         dfs(image,x,y-1,oldColor,newColor,visited); //左
       }
     }
     ```

   + 参考代码1（0ms）：一样的，不过少去了走回头路的判断（我那个顺时针可能死循环）

     ```java
     class Solution {
         public int[][] floodFill(int[][] image, int sr, int sc, int newColor) {
             int color = image[sr][sc];
             if(color!=newColor){
                 dfs(image,sr,sc,newColor,color);
             }
             return image;
             
         }
         public void dfs(int[][]image,int sr,int sc ,int  newColor,int color){
             int row = image.length;
             int column = image[0].length;
             if(sr<0||sr>=row||sc<0||sc>=column||image[sr][sc]!=color){
                 return;
             }
             image[sr][sc] = newColor;
             dfs(image,sr-1,sc,newColor,color);
             dfs(image,sr+1,sc,newColor,color);
             dfs(image,sr,sc-1,newColor,color);
             dfs(image,sr,sc+1,newColor,color);
         }
     }
     ```

5. 01矩阵

   + 语言：java

   + 思路：这个和传统的岛屿问题不大一样。传统岛屿问题从某一端向外扩散，直到遇到边界（或边界条件）的DFS；而这个是先找到所有边界，再从外向里扩散的BFS。

     我这里先把所有原本1的设置为最大值，之后BFS时，如果队列中元素的上下左右值较大，则将其（也就是左邻右舍）替换成当前值+1。

   + 代码（16ms，63.86%）：

     ```java
     class Solution {
       public int[][] updateMatrix(int[][] matrix) {
         int x_len = matrix.length, y_len = matrix[0].length;
         Queue<int[]> queue = new LinkedList<>();
         for (int i = 0; i < x_len; ++i) {
           for (int j = 0; j < y_len; ++j) {
             if (matrix[i][j] == 0) {
               if (i > 0 && matrix[i - 1][j] != 0 || j > 0 && matrix[i][j - 1] != 0 || i < x_len - 1 && matrix[i + 1][j] != 0 || j < y_len - 1 && matrix[i][j + 1] != 0) {
                 queue.add(new int[]{i, j});
               }
             } else {
               matrix[i][j] = Integer.MAX_VALUE;
             }
           }
         }
         while (!queue.isEmpty()) {
           int[] pair = queue.poll();
           int i = pair[0], j = pair[1], core = matrix[i][j] + 1;
           if (i > 0 && matrix[i - 1][j] > core) {
             matrix[i - 1][j] = core;
             queue.add(new int[]{i - 1, j});
           } // 上
           if (i < x_len - 1 && matrix[i + 1][j] > core) {
             matrix[i + 1][j] = core;
             queue.add(new int[]{i + 1, j});
           } // 下
           if (j > 0 && matrix[i][j - 1] > core) {
             matrix[i][j - 1] = core;
             queue.add(new int[]{i, j - 1});
           } // 左
           if (j < y_len - 1 && matrix[i][j + 1] > core) {
             matrix[i][j + 1] = core;
             queue.add(new int[]{i, j + 1});
           } // 右
         }
         return matrix;
       }
     }
     ```

   + 参考代码1（18ms，43.08%）：广度优先搜索，BFS。

     > [01矩阵--官方题解](https://leetcode-cn.com/problems/01-matrix/solution/01ju-zhen-by-leetcode-solution/)

     这个是直接把所有0加入（多余判断），并把数字0的位置都标记已走过。

     之后再BFS的时候，根据原本在Queue的数据位置，让其上下左右未走过的值变成自身值+1。

     ```java
     class Solution {
       static int[][] dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
     
       public int[][] updateMatrix(int[][] matrix) {
         int m = matrix.length, n = matrix[0].length;
         int[][] dist = new int[m][n];
         boolean[][] seen = new boolean[m][n];
         Queue<int[]> queue = new LinkedList<int[]>();
         // 将所有的 0 添加进初始队列中
         for (int i = 0; i < m; ++i) {
           for (int j = 0; j < n; ++j) {
             if (matrix[i][j] == 0) {
               queue.offer(new int[]{i, j});
               seen[i][j] = true;
             }
           }
         }
     
         // 广度优先搜索
         while (!queue.isEmpty()) {
           int[] cell = queue.poll();
           int i = cell[0], j = cell[1];
           for (int d = 0; d < 4; ++d) {
             int ni = i + dirs[d][0];
             int nj = j + dirs[d][1];
             if (ni >= 0 && ni < m && nj >= 0 && nj < n && !seen[ni][nj]) {
               dist[ni][nj] = dist[i][j] + 1;
               queue.offer(new int[]{ni, nj});
               seen[ni][nj] = true;
             }
           }
         }
     
         return dist;
       }
     }
     ```

   + 参考代码2（11 ms，82.07%）：动态规划

     > [01矩阵--官方题解](https://leetcode-cn.com/problems/01-matrix/solution/01ju-zhen-by-leetcode-solution/)

     空间换时间。先把所有1的位置在DP数组中替换成巨大值，然后左上到右下、右下到左上，两轮把遍历到的位置替换成（邻居+1）或者（自身），哪个值小取哪个。
     
     之所以两轮是因为，单独左上到右下的时候，有些值可能被多算了（比如某一个格子到左上的有0位置要5格，但是其实他右下角那一个格子就是0，也就是实际值应该是2）
     
     ```java
     class Solution {
       static int[][] dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
     
       public int[][] updateMatrix(int[][] matrix) {
         int m = matrix.length, n = matrix[0].length;
         // 初始化动态规划的数组，所有的距离值都设置为一个很大的数
         int[][] dist = new int[m][n];
         for (int i = 0; i < m; ++i) {
           Arrays.fill(dist[i], Integer.MAX_VALUE / 2);
         }
         // 如果 (i, j) 的元素为 0，那么距离为 0
         for (int i = 0; i < m; ++i) {
           for (int j = 0; j < n; ++j) {
             if (matrix[i][j] == 0) {
               dist[i][j] = 0;
             }
           }
         }
         // 只有 水平向左移动 和 竖直向上移动，注意动态规划的计算顺序
         for (int i = 0; i < m; ++i) {
           for (int j = 0; j < n; ++j) {
             if (i - 1 >= 0) {
               dist[i][j] = Math.min(dist[i][j], dist[i - 1][j] + 1);
             }
             if (j - 1 >= 0) {
               dist[i][j] = Math.min(dist[i][j], dist[i][j - 1] + 1);
             }
           }
         }
         // 只有 水平向右移动 和 竖直向下移动，注意动态规划的计算顺序
         for (int i = m - 1; i >= 0; --i) {
           for (int j = n - 1; j >= 0; --j) {
             if (i + 1 < m) {
               dist[i][j] = Math.min(dist[i][j], dist[i + 1][j] + 1);
             }
             if (j + 1 < n) {
               dist[i][j] = Math.min(dist[i][j], dist[i][j + 1] + 1);
             }
           }
         }
         return dist;
       }
     }
     ```

6. 钥匙和房间

   + 语言：java

   + 思路：BFS，每轮记录下次能够走的房间，然后标记当然房间走过。最后再判断是否存在房间没走过。

   + 代码（3ms，27.21%）：

     ```java
     class Solution {
       // BFS
       public boolean canVisitAllRooms(List<List<Integer>> rooms) {
         boolean[] visited = new boolean[rooms.size()];
         Queue<Integer> queue = new LinkedList<>();
         visited[0] = true;
         queue.addAll(rooms.get(0));
     
         while (!queue.isEmpty()) {
           int curRoom = queue.poll();
           if (!visited[curRoom]) {
             for (int num : rooms.get(curRoom)) {
               if (!visited[num]) {
                 queue.add(num);
               }
             }
             visited[curRoom] = true;
           }
         }
         for (boolean bool : visited) {
           if (!bool) {
             return false;
           }
         }
         return true;
       }
     }
     ```

   + 参考代码1（0ms）：DFS，每次先走到底，同样记录过程中走过的房间。

     ```java
     class Solution {
       private boolean[] visited;
       private int num = 0;
       public boolean canVisitAllRooms(List<List<Integer>> rooms) {
         visited = new boolean[rooms.size()];
         dfs(rooms,0);
         return num == rooms.size();
       }
       private void dfs(List<List<Integer>> rooms, int index) {
         visited[index] = true;
         num++;
         List<Integer> keys = rooms.get(index);
         for(int i = 0; i < keys.size(); i++) {
           //for (int i : rooms.get(index)) {
           if(!visited[keys.get(i)]) {
     
             dfs(rooms,keys.get(i));
           }
         }
       }
     }
     ```

   + 参考后重写（1ms，94.44%）：

     ```java
     class Solution {
       int count = 0;
       // DFS
       public boolean canVisitAllRooms(List<List<Integer>> rooms) {
         boolean[] visited = new boolean[rooms.size()];
         dfs(visited,rooms,0);
         return count == rooms.size();
       }
     
       public void dfs(boolean[] visited,List<List<Integer>> rooms,Integer num){
         visited[num] = true;
         ++count;
         List<Integer> keys = rooms.get(num);
         for(int key:keys){
           if(!visited[key]){
             dfs(visited,rooms,key);
           }
         }
       }
     }
     ```

     

   

   

