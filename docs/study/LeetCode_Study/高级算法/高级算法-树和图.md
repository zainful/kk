# 高级算法

> 题库链接：https://leetcode-cn.com/explore/interview/card/top-interview-questions-hard/

* 树和图

  1. 单词接龙

   + 语言：java

   + 思路：本来用的DFS，然后错了。因为路径可能有多条，必须找出最短的一条，如果是普通的DFS那么找到一条就返回了。后面就改用BFS了，尽量遍历所有情况。

   + 代码（1485ms，12.68%）：巨慢无比。

     ```java
     class Solution {
         public int ladderLength(String beginWord, String endWord, List<String> wordList) {
             if (!wordList.contains(endWord))
                 return 0;
             Queue<String> probablyRoad = new LinkedList<>();
             HashMap<String,Integer> roads = new HashMap<>();
     
             probablyRoad.add(beginWord);
             roads.put(beginWord, 1);
             String cur,next;
             int size = wordList.size(),curLayer,nextLayer;
             while(!probablyRoad.isEmpty()){
                 cur = probablyRoad.poll();
                 curLayer = roads.get(cur);
                 for(int i = 0;i<size;++i){
                     next = wordList.get(i);
                     if(diffOne(cur,next)){
                         if(!roads.containsKey(next)){
                             nextLayer = roads.getOrDefault(next, Integer.MAX_VALUE);
                             if(curLayer+1<nextLayer){
                                 probablyRoad.add(next);
                                 roads.put(next,curLayer+1);
                             }
                         }
                     }
                 }
             }
             return roads.getOrDefault(endWord, 0);
         }
     
         public boolean diffOne(String a, String b) {
             char[] aArr = a.toCharArray();
             char[] bArr = b.toCharArray();
             int i = 0, j = aArr.length - 1;
             while (i < j&&aArr[i] == bArr[i]) ++i;
             while (i <= j&&aArr[j] == bArr[j]) --j;
             return i == j;
         }
     }
     ```

  + 参考代码1（61ms，72.30%）：广度优先搜索

    > [单词接龙--官方讲解](https://leetcode-cn.com/problems/word-ladder/solution/dan-ci-jie-long-by-leetcode/)

    ```java
    class Solution {
        public int ladderLength(String beginWord, String endWord, List<String> wordList) {
    
            // Since all words are of same length.
            int L = beginWord.length();
    
            // Dictionary to hold combination of words that can be formed,
            // from any given word. By changing one letter at a time.
            Map<String, List<String>> allComboDict = new HashMap<>();
    
            wordList.forEach(
                word -> {
                    for (int i = 0; i < L; i++) {
                        // Key is the generic word
                        // Value is a list of words which have the same intermediate generic word.
                        String newWord = word.substring(0, i) + '*' + word.substring(i + 1, L);
                        List<String> transformations = allComboDict.getOrDefault(newWord, new ArrayList<>());
                        transformations.add(word);
                        allComboDict.put(newWord, transformations);
                    }
                });
    
            // Queue for BFS
            Queue<Pair<String, Integer>> Q = new LinkedList<>();
            Q.add(new Pair(beginWord, 1));
    
            // Visited to make sure we don't repeat processing same word.
            Map<String, Boolean> visited = new HashMap<>();
            visited.put(beginWord, true);
    
            while (!Q.isEmpty()) {
                Pair<String, Integer> node = Q.remove();
                String word = node.getKey();
                int level = node.getValue();
                for (int i = 0; i < L; i++) {
    
                    // Intermediate words for current word
                    String newWord = word.substring(0, i) + '*' + word.substring(i + 1, L);
    
                    // Next states are all the words which share the same intermediate state.
                    for (String adjacentWord : allComboDict.getOrDefault(newWord, new ArrayList<>())) {
                        // If at any point if we find what we are looking for
                        // i.e. the end word - we can return with the answer.
                        if (adjacentWord.equals(endWord)) {
                            return level + 1;
                        }
                        // Otherwise, add it to the BFS Queue. Also mark it visited
                        if (!visited.containsKey(adjacentWord)) {
                            visited.put(adjacentWord, true);
                            Q.add(new Pair(adjacentWord, level + 1));
                        }
                    }
                }
            }
    
            return 0;
        }
    }
    ```

  + 参考代码2（30ms，87.74%）：双向广度优先搜索

    > [单词接龙--官方讲解](https://leetcode-cn.com/problems/word-ladder/solution/dan-ci-jie-long-by-leetcode/)

    ```java
    class Solution {
    
        private int L;
        private Map<String, List<String>> allComboDict;
    
        Solution() {
            this.L = 0;
    
            // Dictionary to hold combination of words that can be formed,
            // from any given word. By changing one letter at a time.
            this.allComboDict = new HashMap<>();
        }
    
        private int visitWordNode(
            Queue<Pair<String, Integer>> Q,
            Map<String, Integer> visited,
            Map<String, Integer> othersVisited) {
    
            Pair<String, Integer> node = Q.remove();
            String word = node.getKey();
            int level = node.getValue();
    
            for (int i = 0; i < this.L; i++) {
    
                // Intermediate words for current word
                String newWord = word.substring(0, i) + '*' + word.substring(i + 1, L);
    
                // Next states are all the words which share the same intermediate state.
                for (String adjacentWord : this.allComboDict.getOrDefault(newWord, new ArrayList<>())) {
                    // If at any point if we find what we are looking for
                    // i.e. the end word - we can return with the answer.
                    if (othersVisited.containsKey(adjacentWord)) {
                        return level + othersVisited.get(adjacentWord);
                    }
    
                    if (!visited.containsKey(adjacentWord)) {
    
                        // Save the level as the value of the dictionary, to save number of hops.
                        visited.put(adjacentWord, level + 1);
                        Q.add(new Pair(adjacentWord, level + 1));
                    }
                }
            }
            return -1;
        }
    
        public int ladderLength(String beginWord, String endWord, List<String> wordList) {
    
            if (!wordList.contains(endWord)) {
                return 0;
            }
    
            // Since all words are of same length.
            this.L = beginWord.length();
    
            wordList.forEach(
                word -> {
                    for (int i = 0; i < L; i++) {
                        // Key is the generic word
                        // Value is a list of words which have the same intermediate generic word.
                        String newWord = word.substring(0, i) + '*' + word.substring(i + 1, L);
                        List<String> transformations =
                            this.allComboDict.getOrDefault(newWord, new ArrayList<>());
                        transformations.add(word);
                        this.allComboDict.put(newWord, transformations);
                    }
                });
    
            // Queues for birdirectional BFS
            // BFS starting from beginWord
            Queue<Pair<String, Integer>> Q_begin = new LinkedList<>();
            // BFS starting from endWord
            Queue<Pair<String, Integer>> Q_end = new LinkedList<>();
            Q_begin.add(new Pair(beginWord, 1));
            Q_end.add(new Pair(endWord, 1));
    
            // Visited to make sure we don't repeat processing same word.
            Map<String, Integer> visitedBegin = new HashMap<>();
            Map<String, Integer> visitedEnd = new HashMap<>();
            visitedBegin.put(beginWord, 1);
            visitedEnd.put(endWord, 1);
    
            while (!Q_begin.isEmpty() && !Q_end.isEmpty()) {
    
                // One hop from begin word
                int ans = visitWordNode(Q_begin, visitedBegin, visitedEnd);
                if (ans > -1) {
                    return ans;
                }
    
                // One hop from end word
                ans = visitWordNode(Q_end, visitedEnd, visitedBegin);
                if (ans > -1) {
                    return ans;
                }
            }
    
            return 0;
        }
    }
    ```

  + 参考代码3（11ms）：双向广度优先搜索，通过切换调用BFS，做到每次进行begin端的BFS或者end端的BFS。

    写起来比官方优雅，而且比较清晰，额。

    ```java
    class Solution {
        public int ladderLength(String beginWord, String endWord, List<String> wordList) {
            if(wordList==null||wordList.size()==0)  return 0;
    
            HashSet<String> start = new HashSet();
            HashSet<String> end = new HashSet();
    
            HashSet<String> dic  = new HashSet(wordList);
    
            start.add(beginWord);
            end.add(endWord);
    
            if(!dic.contains(endWord))  return 0;
    
            return bfs(start,end,dic,2);
    
        }
    
        public int bfs(HashSet<String> st,HashSet<String> ed,HashSet<String> dic,int l){
            if(st.size()==0)    return 0;
            if(st.size()>ed.size()){
                return bfs(ed,st,dic,l);
            }
    
            dic.removeAll(st);
            HashSet<String> next = new HashSet();
    
            for(String s:st){
                char arr[] = s.toCharArray();
                for(int i=0;i<arr.length;i++){
                    char temp = arr[i];
                    for(char x='a';x<='z';x++){
                        if(x==temp) continue;
                        arr[i]=x;
                        String nes = String.valueOf(arr);
                        if(dic.contains(nes)){
                            if(ed.contains(nes)){
                                return l;
                            } else{
                                next.add(nes);
                            }
                        }
                    }
                    arr[i] = temp;
                }
            }
            return bfs(next,ed,dic,l+1);
        }
    }
    ```

  + 参考代码4（59ms，74.31%）：感觉重点就是如何优化字符串匹配的时间。

    ```java
    
    public class Solution {
        /**
         * 链接：https://leetcode-cn.com/problems/word-ladder/solution/dan-ci-jie-long-by-leetcode/
         *
         * 最重要的步骤是找出只差一个字母的多个单词，即从当前单词一步能得到哪些单词。
         * 为了快速的找到这些相邻节点，我们对给定的 wordList 做一个预处理，将单词中的某个字母用 * 代替
         * 这个预处理帮我们构造了一个单词变换的通用状态。
         *
         * 我们使用一个Map来存储，键：通用状态；值：能得到这个通用状态的所有单词
         * 例如：Dog ----> D*g <---- Dig，Dog 和 Dig 都指向了一个通用状态 D*g。即键D*g对应的值为[Dog,Dig]
         *
         * 这步预处理找出了单词表中所有单词改变某个字母后的通用状态，并帮助我们更方便也更快的找到相邻节点。
         * 否则，对于每个单词我们需要遍历整个字母表查看是否存在一个单词与它相差一个字母，这将花费很多时间。
         * 预处理操作在广度优先搜索之前高效的建立了邻接表。
         *
         * 例如，在广搜时我们需要访问 Dug 的所有邻接点，也就是想知道由Dug能变换到字典中哪些单词
         * 我们可以先生成 Dug 的所有通用状态：以通用状态为键去获取值就可得到结果
         * Dug => *ug
         * Dug => D*g
         * Dug => Du*
         * 第二个变换 D*g 可以同时映射到 Dog 或者 Dig，因为他们都有相同的通用状态。拥有相同的通用状态意味着两个单词只相差一个字母，他们的节点是相连的。
         *
         */
    
        /**
         * 广度优先遍历(可认为是寻找全局最优解)
         * 1. 对给定的 wordList 做预处理，找出所有的通用状态。将通用状态记录在字典中，键是通用状态，值是所有具有通用状态的单词。
         * 2. 将键值对 <beginWord，1> 放入队列中，1 代表节点的层次。我们需要返回 endWord 的层次也就是从 beginWord 出发的最短距离。
         * 3. 为了防止出现环，使用访问数组记录当前单词已访问过。
         * 4. 当队列中有元素的时候，取出第一个元素，记为 current_word。
         * 5. 找到 current_word 的所有通用状态，并根据这些通用状态得到其对应的单词列表w1，w2，即从currWord能达到给定字典中的list中的w1和w2
         * 6. w1和w2都和 current_word 相连，因此将他们加入到队列中。
         * 7. 对于新获得的所有单词，向队列中加入元素 (word, level + 1) 其中 level 是 current_word 的层次。
         * 8. 最终当你到达期望的单词，对应的层次就是最短变换序列的长度
         * 相当于要从1得到9，发现1直接到达2和3，再操作2得到4和5，再操作3得到6和7，再操作4得到8和9，达到目标
         * 也就是一个广度优先遍历，因此需要借助 [队列] ，且要避免重复遍历
         */
        public static int ladderLength(String beginWord, String endWord, List<String> wordList) {
            // 给定单词列表中不包括endword，直接返回
            if (!wordList.contains(endWord)) return 0;
            // 题目说明，每个单词长度相同
            int len = beginWord.length();
            // 处理给出的单词字典，转换为全部的通用状态及每个通配词映射的单词集合
            HashMap<String, ArrayList<String>> allComboDict = new HashMap<>();
            // lambda表达式遍历，currWord是当前正在遍历的单词
            wordList.forEach(curWord -> {
                // 每个单词能得到len种通配词(每个位置字符都可变为*)
                for (int i = 0; i < len; i++) {
                    // 得到通配词
                    String comboWord = curWord.substring(0, i) + "*" + curWord.substring(i + 1, len);
                    // 从通配字典全集中拿到这个通配词对应的单词集合，如果是空(第一次得到通配词时)就创建一个新的
                    ArrayList<String> comboWordList = allComboDict.getOrDefault(comboWord, new ArrayList<>());
                    // 把当前这个单词加进去，因此从这个单词得到了这个通配词
                    comboWordList.add(curWord);
                    // 更新一个通配字典全集中这个通配词对应的单词集合
                    allComboDict.put(comboWord, comboWordList);
                }
            });
            // 广度优先遍历队列
            // LinkedList implements Deque extends Queue
            Queue<Pair<String, Integer>> queue = new LinkedList<>();
            // 记录已遍历过的单词,为什么不用List，因为之后判断节点是否已遍历过时，ArrayList的contains方法太低效了，它的底层是数组，或者直接用TreeSet也可以
            // ArrayList<String> hasVistedList = new ArrayList<>();
            HashMap<String, Boolean> hasVistedList = new HashMap<>();
            // 开始词作为第一个节点加入队列,深度level是1，标记其已访问
            queue.add(new Pair<>(beginWord, 1));
            // hasVistedList.add(beginWord);
            hasVistedList.put(beginWord, true);
            // 广度优先遍历，逐个取出队列中元素进行操作
            while (!queue.isEmpty()) {
                // 队列第一个节点
                Pair<String, Integer> node = queue.remove();
                // 当前节点对应的<单词，层级>
                String currWord = node.getKey();
                int level = node.getValue();
                for (int i = 0; i < len; i++) {
                    // 从当前单词，得到len个通配词
                    String currComboWord = currWord.substring(0, i) + "*" + currWord.substring(i + 1, len);
                    // 拿到这个通配词映射的单词集合(也就是从当前单词一次转换能得到哪些单词)
                    ArrayList<String> currComboWordList = allComboDict.getOrDefault(currComboWord, new ArrayList<>());
                    // 遍历其中是否包含目标单词
                    for (String word : currComboWordList) {
                        // 包含目标单词，说明当前单词能一次转换到目标单词，经历的步骤数是当前单词的层级 + 1
                        if (word.equals(endWord))
                            return level + 1;
                        // 否则，当前单词能得到这个单词，如果它还没被访问过
                        // if (!hasVistedList.contains(word)){
                        // HashMap.containsKey方法效率远高于ArrayList.contains
                        if (!hasVistedList.containsKey(word)){
                            // 把这个单词加入到队列中
                            queue.add(new Pair<>(word, level + 1));
                            // 标记它为已访问
                            // hasVistedList.add(word);
                            hasVistedList.put(word, true);
                        }
                    }
                }
            }
            return 0;
        }
    }
    ```

  + 效仿参考代码3使用HashSet的BFS写写看（17ms，95.20%）：

    ```java
    class Solution {
    
        public int ladderLength(String beginWord, String endWord, List<String> wordList) {
    
            // 反正不能重复走，那么就用HashSet代替HashMap<String,Boolean>,每次走过就直接remove就好了
            HashSet<String> wordSet = new HashSet<>(wordList);
            if (!wordSet.contains(endWord))
                return 0;
    
            HashSet<String> beginSet = new HashSet<>();
            HashSet<String> endSet = new HashSet<>();
    
            beginSet.add(beginWord);
            endSet.add(endWord);
    
            return bfs(beginSet, endSet, wordSet, 2);
        }
    
        public int bfs(HashSet<String> beginSet, HashSet<String> endSet, HashSet<String> wordSet, int level) {
            if (beginSet.isEmpty()) // 当前没法走了,可能走到死路了
                return 0;
            if (beginSet.size() > endSet.size()) { // 双向走，如果begin可选路径太多了，我们改从另一边走(可以减小走到无用死胡同的概率)
                return bfs(endSet, beginSet, wordSet, level);
            }
            wordSet.removeAll(beginSet);// 移除所有当前包含的路径，因为下面要判断当前所有路径的下一步走什么位置，不需要再考虑现在和过去的路了。
            HashSet<String> nextSet = new HashSet<>();
            for (String beginStr : beginSet) { // 为所有当前路径(同level，深度)查找下一步
                char[] beginArr = beginStr.toCharArray();
                for (int i = 0, len = beginArr.length; i < len; ++i) { // 遍历 路径的每一个字母，查找是否有符合相差一个字母的路径
                    char curCh = beginArr[i];
                    for (char ch = 'a'; ch <= 'z'; ++ch) { // 开始试探是否包含下一步路径
                        if (curCh != ch) { //相差一个字母
                            beginArr[i] = ch;
                            String next = String.valueOf(beginArr); 
                            if (wordSet.contains(next)) { // 如果存在正好改动一个字母的路径
                                if (endSet.contains(next)) // 正好和end走过来碰头，那么就是走通了。
                                    return level;
                                else
                                    nextSet.add(next); // 没走通，但是记录为下一步可走的路
                            }
                        }
                    }
                    beginArr[i] = curCh;// 还原当前字母
                }
            }
            return bfs(nextSet, endSet, wordSet, level + 1);
        }
    }
    ```

  2. 被围绕的区域

  + 语言：java

  + 思路：先从4个边缘开始DFS。等于把连接边缘的岛屿都标记成字符M，然后第二次把所有非M的位置都变成X。

    对岛屿类题目不熟的可以看看下面这个总结文章

    > [岛屿类问题的通用解法、DFS 遍历框架](https://leetcode-cn.com/problems/number-of-islands/solution/dao-yu-lei-wen-ti-de-tong-yong-jie-fa-dfs-bian-li-/)

  + 代码（2ms，98.44%）：

    ```java
    class Solution {
        public void solve(char[][] board) {
            if(board==null||board.length==0||board[0].length==0)
                return ;
            int xLen = board.length;
            int yLen = board[0].length;
            // (1) 四个边缘开始DFS，标记边缘的岛屿为 'M'
    
            // 左边
            for(int i = 0;i<xLen;++i){
                if(board[i][0]=='O')
                    dfs(board,i,0);
            }
            // 上边
            for(int i = 0;i<yLen;++i){
                if(board[0][i]=='O')
                    dfs(board,0,i);
            }
            // 右边
            for(int i = 0;i<xLen;++i){
                if(board[i][yLen-1]=='O')
                    dfs(board,i,yLen-1);
            }
            // 下边
            for(int i = 0;i<yLen;++i) {
                if (board[xLen - 1][i] == 'O')
                    dfs(board, xLen-1, i);
            }
    
            // (2) 把所有M变成O,其余非X位置变成X
            for(int i = 0;i<xLen;++i){
                for(int j = 0;j<yLen;++j){
                    if(board[i][j]=='X') {
                        continue;
                    }
                    else if(board[i][j]=='O') // 不是和边缘连接的岛屿
                        board[i][j]='X';
                    else // 和边缘相连接的岛屿，标志成O
                        board[i][j]='O';
                }
            }
        }
    
        public void dfs(char[][] board,int x,int y){
            if(!isArea(board,x,y))
                return;
            board[x][y]='M';
            dfs(board, x-1, y); // 上
            dfs(board, x, y+1); // 右
            dfs(board, x+1, y); // 下
            dfs(board, x, y-1); // 左
        }
    
        public boolean isArea(char[][] board,int x,int y){
            return x>=0&&x<board.length&&y>=0&&y<board[0].length&&board[x][y]=='O';
        }
    }
    ```

  + 参考代码1：本质上没有区别

    ```java
    class Solution {
        public void solve(char[][] board) {
            if(board == null || board.length < 1 || board[0].length < 1){
                return;
            }
            int rows = board.length;
            int cols = board[0].length;
            for(int i = 0;i < rows;i++){
                if(board[i][0] == 'O'){
                    change(board,i,0);
                }
                if(board[i][cols-1] == 'O'){
                    change(board,i,cols-1);
                }
            }
            for(int i = 0;i < cols;i++){
                if(board[0][i] == 'O'){
                    change(board,0,i);
                }
                if(board[rows-1][i] == 'O'){
                    change(board,rows-1,i);
                }
            }
            for(int i = 0;i < rows;i++){
                for(int j = 0;j < cols;j++){
                    if(board[i][j] == 'A'){
                        board[i][j] = 'O';
                    }else{
                        board[i][j] = 'X';
                    }
                }
            }
        }
    
    
        public void change(char[][] board,int i,int j){
            if(i < 0 || i>=board.length || j < 0 || j >= board[0].length){
                return;
            }
            if(board[i][j] != 'O'){
                return;
            }
            board[i][j] = 'A';
            change(board,i-1,j);
            change(board,i+1,j);
            change(board,i,j+1);
            change(board,i,j-1);
        }
    }
    ```

  3. 二叉树的最近公共祖先

  + 语言：java

  + 思路："最近"，所以肯定是一找到符合的位置直接返回，不需要再筛选什么最大值、最小值之类的，那么直接DFS就好了。

    + root==null，直接返回null。很好理解，到底了，没法继续了。
    + root == p||root == q，因为"最近"，那么一旦找到相等的元素，就没必要再往下了。（题目说p和q肯定存在）不再往下了，那么q可能是p的子树，也可能p是q的子树，或者两者分别在某树分叉后的左右子树里。
    + 如果某树左右子树都不为空，说明左右子树都存在p或者q，那么它正好是最近公共祖先，直接返回。
    + 如果不是上述情况，那么只需返回不为null的子树节点。（该子树至少包含p或者q，甚至两者都有）

  + 代码（7ms，99.93%）：

    ```java
    class Solution {
        public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
            return dfs(root,p,q);
        }
    
        public TreeNode dfs(TreeNode root, TreeNode p, TreeNode q) {
            if(root==null)
                return null;
            if(root==p||root==q)
                return root;
            TreeNode left = dfs(root.left,p,q);
            TreeNode right = dfs(root.right, p, q);
            if (left!=null&&right!=null)
                return root;
            return left==null?right:left;
        }
    }
    ```
    
  + 参考代码1（4ms）：其实是一样的思路

    ```java
    class Solution {
        public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
            if (root == null || root == p || root == q) {
                return root;
            }
          TreeNode left = lowestCommonAncestor(root.left, p, q);
            TreeNode right = lowestCommonAncestor(root.right, p, q);
          if (left != null && right != null) {
                return root;
            }
            return left != null ? left : right;
        }
    }
    ```

  4. 二叉树中的最大路径和

  + 语言：java

  + 思路（1ms，99.55%）：首先，不走完整个图，基本没法确定哪个是最大路径和。那么就需要BFS或者配合全局变量的DFS。这里想一想感觉DFS比较可能。那么确定递归结束条件。

    + 节点==null，返回0。到底部了，没啥好说的

    + 随便取一个节点，什么时候可能取最大路径和？

      1. 单纯包含当前节点
      2. 包含当前节点和左子树（左子树已经计算好某条最大路径）
      3. 包含当前节点和右子树（右子树已经计算好某条最大路径）
      4. 包含当前节点和左子树、右子树

      为满足上述要求，DFS递归获取left和right左右子树最长路径时，考虑是否需要包含左右子树，可以在最外围嵌套一层Math.max(XXX，0)。这样如果某一子树路径最大和是负数就可以直接舍弃了。

    + 每次都更新可能的最大值。那就是maxRes，或者上述4种情况。
    + 当前节点返回时，只能至多包含一条子路径，也就是上述的1-3情况，去除第4种。

  + 代码（1ms，99.55%）：

    ```java
    class Solution {
        int maxRes = Integer.MIN_VALUE;

        public int maxPathSum(TreeNode root) {
            dfs(root);
            return maxRes;
        }
    
        public int dfs(TreeNode root){
            if(root==null)
                return 0;
    
            int left = Math.max(dfs(root.left),0);
            int right = Math.max(dfs(root.right),0);
    
            maxRes = Math.max(maxRes, root.val+left+right);
    
            return root.val+Math.max(left,right);
        }
    }
    ```

  + 参考代码1（1ms，99.55%）：思路没什么区别

    ```java
    class Solution {
      int max_sum = Integer.MIN_VALUE;
    
      public int max_gain(TreeNode node) {
        if (node == null) return 0;
    
        // max sum on the left and right sub-trees of node
        int left_gain = Math.max(max_gain(node.left), 0);
        int right_gain = Math.max(max_gain(node.right), 0);
    
        // the price to start a new path where `node` is a highest node
        int price_newpath = node.val + left_gain + right_gain;
    
        // update max_sum if it's better to start a new path
        max_sum = Math.max(max_sum, price_newpath);
    
        // for recursion :
        // return the max gain if continue the same path
        return node.val + Math.max(left_gain, right_gain);
      }
    
      public int maxPathSum(TreeNode root) {
        max_gain(root);
        return max_sum;
      }
    }
    ```

  5. Friend Circles

  + 语言：java

  + 思路：一看就是并查集。

  + 代码（10ms，13.20%）：巨慢无比。

    ```java
    class Solution {
    
    // 并查集的父集
        int[] parent;
    
        public int findCircleNum(int[][] M) {
            if (M == null)
                return 0;
            int Mlen = M.length;
            parent = new int[Mlen];
            Arrays.fill(parent, -1);
            for (int i = 0; i < Mlen; ++i) {
                for (int j = 0; j < Mlen; ++j) {
                    if(M[i][j]==1)
                        union(i, j);
                }
            }
            int res = 0;
            for (int i = 0; i < Mlen; ++i) {
                if (parent[i] == -1)
                    res++;
            }
            return res;
        }
    
        public int findParent(int i) {
            if(parent[i]==-1)
                return i;
            return findParent(parent[i]);
        }
    
        public void union(int i, int j) {
            int iParent= findParent(i);
            int jParent = findParent(j);
            if (iParent!= jParent)
                parent[iParent] = jParent;
        }
    }
    ```

  + 参考代码1（2ms，54.84%）：同样使用并查集的思想，不过在查找父集的时候顺便修改父级，优化合并时查找父级的操作。同时缩小了内层for循环的范围。

    > [粗俗易懂：这篇题解让你学会并查集,执行用时 : 2 ms , 在所有 Java 提交中击败了 63.97% 的用户 内](https://leetcode-cn.com/problems/friend-circles/solution/cu-su-yi-dong-zhe-pian-ti-jie-rang-ni-xue-hui-bing/)

    ```java
    class Solution {
    
        class unionFind{
            private int[] parent;
            private int[] rank;
    
            public unionFind(int size){
                this.parent = new int[size];
                this.rank = new int[size];
                for (int i = 0; i < size; i++){
                    parent[i] = -1; // 初始用-1来表示，这样在最后所有元素合并完之后，还为-1的就是一个集合的根节点
                    rank[i] = 1;
                }
            }
    
            // 更新到每个节点都指向根节点
            public int find(int p){
                if (parent[p] == -1) return p; // 如果p的父节点是-1表示当前p就是根节点
    
                int curP = p;
                while (parent[p] != -1){ // 循环找到根节点
                    p = parent[p];
                }
    
                parent[curP] = p; // 将查找的节点指向根节点，以减低树的高度，起到后续查询时优化的作用
                return p;
            }
    
            public boolean isConnected(int p, int q){
                return find(p) == find(q);
            }
    
            public void union(int p, int q){
                int pRoot = find(p);
                int qRoot = find(q);
                if (pRoot == qRoot) return;
    
                if (rank[pRoot] > rank[qRoot]){
                    parent[qRoot] = pRoot;
                }else if (rank[pRoot] < rank[qRoot]){
                    parent[pRoot] = qRoot;
                }else{
                    parent[qRoot] = pRoot;
                    rank[pRoot] += 1;
                }
            }
        }
        // 方式三：并查集
        public int findCircleNum(int[][] M) {
            int peopleCount = M.length;
    
            unionFind unionFind = new unionFind(peopleCount);
            for (int i = 0; i < peopleCount; i++){
                for (int j = 0; j <= i; j++){
                    if (i == j) continue;
                    if (M[i][j] == 1) unionFind.union(i, j);
                }
            }
    
            int[] arr = unionFind.parent;
            int count = 0;
            for (int i = 0; i < peopleCount; i++){
                if (arr[i] == -1){
                    count++;
                }
            }
    
            return count;
        }
    
    }
    ```

  + 参考代码2（2ms，54.84%）：DFS。换思维考虑，如果数字没有遇到过，就是新朋友团队，count++。每次通过dfs的for循环查找是否有和其相连的无向图节点，有的话标记遍历过，继续下向下遍历。

    总之就是转换成有向图问题。这里关键dfs里面的for循环一定要j<M.length,而不能j<=i，会遗漏节点。

    ```java
    
    public class Solution {
        public void dfs(int[][] M, int[] visited, int i) {
            for (int j = 0; j < M.length; j++) {
                if (M[i][j] == 1 && visited[j] == 0) {
                    visited[j] = 1;
                    dfs(M, visited, j);
                }
            }
        }
        public int findCircleNum(int[][] M) {
            int[] visited = new int[M.length];
            int count = 0;
            for (int i = 0; i < M.length; i++) {
                if (visited[i] == 0) {
                    dfs(M, visited, i);
                    count++;
                }
            }
            return count;
        }
    }
    ```

  + 参考代码3（0ms）：BFS。其实和DFS也都是要遍历整个数组。不过相对DFS重复递归优化不少了。

    ```java
    public class Solution {
        public int findCircleNum(int[][] M) {
            int[] visited = new int[M.length];
            int count = 0;
            Queue < Integer > queue = new LinkedList < > ();
            for (int i = 0; i < M.length; i++) {
                if (visited[i] == 0) {
                    queue.add(i);
                    while (!queue.isEmpty()) {
                        int s = queue.remove();
                        visited[s] = 1;
                        for (int j = 0; j < M.length; j++) {
                            if (M[s][j] == 1 && visited[j] == 0)
                                queue.add(j);
                        }
                    }
                    count++;
                }
            }
            return count;
        }
    }
    ```

  + 重写并查集的代码（2ms，54.84%）：关键是find（）函数不要写错。

    ```java
    class Solution {
    
        int[] parent;
        int[] weight;
    
        public int findCircleNum(int[][] M) {
            if(M==null)
                return 0;
            int mLen = M.length;
            parent=new int[mLen];
            weight=new int[mLen];
            for(int i =0;i<mLen;++i){
                parent[i] = -1;
                weight[i] = 1;
            }
            for(int i = 0;i<mLen;++i){
                for(int j = 0;j<=i;++j){
                    if(M[i][j]==1&&i!=j){
                        union(i,j);
                    }
                }
            }
            int res = 0;
            for(int num:parent){
                if(num==-1)
                    res+=1;
            }
            return res;
        }
    
        public int find(int i){
            if(parent[i]==-1)
                return i;
            int cur = i;
            while(parent[i]!=-1){
                i = parent[i];
            }
            parent[cur] = i;
            return i;
        }
    
        public void union(int i,int j){
            int iP = find(i);
            int jP = find(j);
            if(iP!=jP){
                if(weight[i]>=weight[j]){
                    parent[jP] = iP;
                    weight[i] +=weight[j];
                }else{
                    parent[iP] = jP;
                    weight[j] +=weight[i];
                }
            }
        }
    
    }
    ```

  + DFS参考后重写（2ms）：

    ```java
    class Solution {
    
        boolean[] visited;
        int mLen;
        int[][] mArr;
    
        public int findCircleNum(int[][] M) {
            if(M==null)
                return 0;
            int res = 0;
            mArr = M;
            mLen = M.length;
            visited = new boolean[mLen];
            for(int i = 0;i<mLen;++i){
                if(!visited[i]){
                    dfs(i);
                    ++res;
                }
            }
            return res;
        }
    
        public void dfs(int num){
            for(int i = 0;i<mLen;++i){
                if(mArr[num][i]==1&&!visited[i]){
                    visited[i]=true;
                    dfs(i);
                }
            }
        }
    }
    ```

  + BFS参考后重写（8ms，17.25%）：时间莫名长。其实和DFS也差不多，都是用到visited数组来标记是否已经遍历过。

    ```java
    class Solution {
    
        public int findCircleNum(int[][] M) {
            if(M==null)
                return 0;
            int len = M.length;
            boolean[] visited = new boolean[len];
            Queue<Integer> numQueue = new LinkedList<>();
            int res = 0;
            for(int i =0,tmp;i<len;++i){
                if(!visited[i]){
                    numQueue.add(i);
                    ++res;
                    while(!numQueue.isEmpty()){
                        tmp = numQueue.poll();
                        visited[tmp]=true;
                        for(int j =0;j<len;++j){
                            if(M[tmp][j]==1&&!visited[j]){
                                numQueue.add(j);
                            }
                        }
                    }
                }
            }
            return res;
        }
    }
    ```

  6. 课程表

  + 语言：java

  + 思路：有向图判断环。

  + 代码（29ms，17.35%）：

    ```java
    class Solution {
      public boolean canFinish(int numCourses, int[][] prerequisites) {
        HashMap<Integer,HashSet<Integer>> map = new HashMap<>();
        Queue<Integer> queue = new LinkedList<>();
        for(int i = 0,len = prerequisites.length,cur,need;i<len;++i){
          cur = prerequisites[i][0];
          need = prerequisites[i][1];
          HashSet<Integer> needSet = map.getOrDefault(cur, new HashSet<>());
          needSet.add(need);
          map.put(cur,needSet);
          queue.add(cur);
          while(!queue.isEmpty()){
            Integer curNum = queue.poll();
            HashSet<Integer> tmpSet = map.getOrDefault(curNum, new HashSet<>());
            if(tmpSet.contains(cur))
              return false;
            queue.addAll(tmpSet);
          }
        }
        return true;
      }
    }
    ```

  + 参考代码1（6ms，78.86%）：拓扑排序。

    > [拓扑排序、深度优先遍历](https://leetcode-cn.com/problems/course-schedule/solution/tuo-bu-pai-xu-by-liweiwei1419/)

    ```java
    import java.util.HashSet;
    import java.util.LinkedList;
    import java.util.Queue;
    
    public class Solution {
    
        public boolean canFinish(int numCourses, int[][] prerequisites) {
            if (numCourses <= 0) {
                return false;
            }
    
            // 特判
            int pLen = prerequisites.length;
            if (pLen == 0) {
                return true;
            }
    
            int[] inDegree = new int[numCourses];
            HashSet<Integer>[] adj = new HashSet[numCourses];
            for (int i = 0; i < numCourses; i++) {
                adj[i] = new HashSet<>();
            }
    
            for (int[] p : prerequisites) {
                inDegree[p[0]]++;
                adj[p[1]].add(p[0]);
            }
    
            Queue<Integer> queue = new LinkedList<>();
    
            // 首先加入入度为 0 的结点
            for (int i = 0; i < numCourses; i++) {
                if (inDegree[i] == 0) {
                    queue.add(i);
                }
            }
    
            // 记录已经出队的课程数量
            int cnt = 0;
            while (!queue.isEmpty()) {
                Integer top = queue.poll();
                cnt += 1;
                // 遍历当前出队结点的所有后继结点
                for (int successor : adj[top]) {
                    inDegree[successor]--;
                    if (inDegree[successor] == 0) {
                        queue.add(successor);
                    }
                }
            }
            return cnt == numCourses;
        }
    }
    ```

  + 参考代码2（4ms，94.38%）：深度优先遍历

    > [拓扑排序、深度优先遍历](https://leetcode-cn.com/problems/course-schedule/solution/tuo-bu-pai-xu-by-liweiwei1419/)

    ```java
    import java.util.HashSet;
    
    public class Solution {
    
        public boolean canFinish(int numCourses, int[][] prerequisites) {
            if (numCourses <= 0) {
                return false;
            }
            int plen = prerequisites.length;
            if (plen == 0) {
                return true;
            }
            int[] marked = new int[numCourses];
    
            // 初始化有向图 begin
            HashSet<Integer>[] graph = new HashSet[numCourses];
            for (int i = 0; i < numCourses; i++) {
                graph[i] = new HashSet<>();
            }
            // 初始化有向图 end
            // 有向图的 key 是前驱结点，value 是后继结点的集合
            for (int[] p : prerequisites) {
                graph[p[1]].add(p[0]);
            }
    
            for (int i = 0; i < numCourses; i++) {
                if (dfs(i, graph, marked)) {
                    // 注意方法的语义，如果图中存在环，表示课程任务不能完成，应该返回 false
                    return false;
                }
            }
            // 在遍历的过程中，一直 dfs 都没有遇到已经重复访问的结点，就表示有向图中没有环
            // 所有课程任务可以完成，应该返回 true
            return true;
        }
    
        /**
         * 注意这个 dfs 方法的语义
         * @param i      当前访问的课程结点
         * @param graph
         * @param marked 如果 == 1 表示正在访问中，如果 == 2 表示已经访问完了
         * @return true 表示图中存在环，false 表示访问过了，不用再访问了
         */
        private boolean dfs(int i,
                            HashSet<Integer>[] graph,
                            int[] marked) {
            // 如果访问过了，就不用再访问了
            if (marked[i] == 1) {
                // 从正在访问中，到正在访问中，表示遇到了环
                return true;
            }
    
            if (marked[i] == 2) {
                // 表示在访问的过程中没有遇到环，这个节点访问过了
                return false;
            }
            // 走到这里，是因为初始化呢，此时 marked[i] == 0
            // 表示正在访问中
            marked[i] = 1;
            // 后继结点的集合
            HashSet<Integer> successorNodes = graph[i];
    
            for (Integer successor : successorNodes) {
                if (dfs(successor, graph, marked)) {
                    // 层层递归返回 true ，表示图中存在环
                    return true;
                }
            }
            // i 的所有后继结点都访问完了，都没有存在环，则这个结点就可以被标记为已经访问结束
            // 状态设置为 2
            marked[i] = 2;
            // false 表示图中不存在环
            return false;
        }
    }
    ```

  + 参考代码3（6ms，78.86%）：BFS。

    > [课程表（拓扑排序：入度表BFS法 / DFS法，清晰图解）](https://leetcode-cn.com/problems/course-schedule/solution/course-schedule-tuo-bu-pai-xu-bfsdfsliang-chong-fa/)

    ```java
    class Solution {
        public boolean canFinish(int numCourses, int[][] prerequisites) {
            int[] indegrees = new int[numCourses];
            List<List<Integer>> adjacency = new ArrayList<>();
            Queue<Integer> queue = new LinkedList<>();
            for(int i = 0; i < numCourses; i++)
                adjacency.add(new ArrayList<>());
            // Get the indegree and adjacency of every course.
            for(int[] cp : prerequisites) {
                indegrees[cp[0]]++;
                adjacency.get(cp[1]).add(cp[0]);
            }
            // Get all the courses with the indegree of 0.
            for(int i = 0; i < numCourses; i++)
                if(indegrees[i] == 0) queue.add(i);
            // BFS TopSort.
            while(!queue.isEmpty()) {
                int pre = queue.poll();
                numCourses--;
                for(int cur : adjacency.get(pre))
                    if(--indegrees[cur] == 0) queue.add(cur);
            }
            return numCourses == 0;
        }
    }
    ```

  + 参考代码4（3ms，99.25%）：DFS。

    > [课程表（拓扑排序：入度表BFS法 / DFS法，清晰图解）](https://leetcode-cn.com/problems/course-schedule/solution/course-schedule-tuo-bu-pai-xu-bfsdfsliang-chong-fa/)

    ```java
    class Solution {
        public boolean canFinish(int numCourses, int[][] prerequisites) {
            List<List<Integer>> adjacency = new ArrayList<>();
            for(int i = 0; i < numCourses; i++)
                adjacency.add(new ArrayList<>());
            int[] flags = new int[numCourses];
            for(int[] cp : prerequisites)
                adjacency.get(cp[1]).add(cp[0]);
            for(int i = 0; i < numCourses; i++)
                if(!dfs(adjacency, flags, i)) return false;
            return true;
        }
        private boolean dfs(List<List<Integer>> adjacency, int[] flags, int i) {
            if(flags[i] == 1) return false;
            if(flags[i] == -1) return true;
            flags[i] = 1;
            for(Integer j : adjacency.get(i))
                if(!dfs(adjacency, flags, j)) return false;
            flags[i] = -1;
            return true;
        }
    }
    ```

  + 参考代码5（1ms）：也是DFS思想

    ```java
    class Solution {
        public boolean canFinish(int numCourses, int[][] prerequisites) {
            if(prerequisites==null || prerequisites.length==0) return true;
    
            //构建图
            Node[] graph=new Node[numCourses];
            for(int[] plan:prerequisites){
                //头插法
                graph[plan[0]]=new Node(plan[1],graph[plan[0]]);
            }
            //判断是否存在环
            int[] visited=new int[numCourses];
            for(int i=0;i<numCourses;i++){
                //未遍历则遍历，如果存在环，则不符合要求
                if(visited[i]!=-1 && !isDAG(i,graph,visited)) return false;
                //遍历完成，以i出发不存在环路，置为访问且无环
                visited[i]=-1;
            }
            return true;
        }
    
        private boolean isDAG(int start,Node[] graph,int[] visited){
            //置为正在遍历
            visited[start]=1;
            Node temp=graph[start];
            while(temp!=null){
                //之前已经遍历过，无环
                if(visited[temp.val]==-1){
                    temp=temp.next;
                    continue;
                }
                //存在回路
                if(visited[temp.val]==1 || !isDAG(temp.val,graph,visited)) return false;
                //遍历结束，置为已访问且无环
                visited[temp.val]=-1;
                temp=temp.next;
            }
            return true;
        }
    
    
        // 图  邻接表
        class Node{
            int val;
            Node next;
    
            Node(int val){
                this.val=val;
            }
    
            Node(int val,Node next){
                this.val=val;
                this.next=next;
            }
        }
    }
    ```

  + 使用BFS的邻接矩阵重写（6ms，78.86%）：

    ```java
    class Solution {
        public boolean canFinish(int numCourses, int[][] prerequisites) {
            List<List<Integer>> graph = new ArrayList<>();
            int[] inDegree = new int[numCourses];
            Queue<Integer> queue = new LinkedList<>();
    
            for(int i = 0;i<numCourses;++i){
                graph.add(new ArrayList<>()); // 构建邻接矩阵
            }
    
            for(int[] side:prerequisites){
                graph.get(side[1]).add(side[0]); // 添加 A->B ,这里对应就是 int[i][1] -> int[i][0]
                ++inDegree[side[0]]; // B的入度增加，即int[i][0]的入度增大
            }
    
            for(int i = 0;i<numCourses;++i){
                if(inDegree[i]==0)
                    queue.add(i); // 拓扑排序，需要先把入度0的所有节点标记出
            }
    
            while(!queue.isEmpty()){ // 存的都是某时刻入度0的拓扑排序过程节点
                int curNode = queue.poll();
                --numCourses; // 消费掉一个 0 入度的节点
                List<Integer> toNodes = graph.get(curNode); // 查找入度0的节点的指向的其他节点
                for(int node: toNodes){
                    --inDegree[node];
                    if(inDegree[node]==0){
                        queue.add(node);
                    }
                }
            }
    
            return numCourses==0; // 看看是否所有节点都有机会变成0入度(拓扑排序)
        }
    }
    ```

  + 使用DFS的邻接矩阵重写（5ms，85.47%）：蜜汁才快1ms，参考的版本整体差不多居然只要3ms

    ```java
    class Solution {
        public boolean canFinish(int numCourses, int[][] prerequisites) {
            List<List<Integer>> graph = new ArrayList<>();
            int[] nodesVisiedState = new int[numCourses]; // 0 未访问,访问到 1, 回溯 标记 -1
    
            for(int i = 0;i<numCourses;++i){
                graph.add(new ArrayList<>()); // 构建邻接矩阵
            }
    
            for(int[] side:prerequisites){
                graph.get(side[1]).add(side[0]); // 添加 A->B ,这里对应就是 int[i][1] -> int[i][0]
            }
    
            for(int i = 0;i<numCourses;++i){
                if(!dfs(graph,nodesVisiedState,i))
                    return false;
            }
    
            return true;
        }
    
        public boolean dfs(List<List<Integer>> graph,int[] nodesVisiedState,int node){
            if(nodesVisiedState[node]==1) // 向箭头方向遍历过程中，标记1。如果中途又遇到同一个节点，说明成环了。
                return false;
            if(nodesVisiedState[node]==-1) // 该路径已经走过且回溯过了，也就是节点其实算被舍弃了,标记-1
                return true;
            nodesVisiedState[node] = 1; // 向箭头方向遍历的路上，先标记1.
            List<Integer> toNodes = graph.get(node);
            for(int toNode : toNodes){
                if(!dfs(graph,nodesVisiedState,toNode))
                    return false; // 继续向下遍历
            }
            nodesVisiedState[node] = -1;// 回溯了，这条路径的节点都遍历过了
            return true;
        }
    }
    ```

  7. 课程表 II

  + 语言：java

  + 思路：一看就是构建边缘列表，然后用BFS找0入度的节点了。和6.课程表不同的是，这里的prerequisites为空时，需要直接返回整个课程列表。

  + 代码（20ms，38.07%）：莫名还挺慢的。

    ```java
    class Solution {
        public int[] findOrder(int numCourses, int[][] prerequisites) {
    
            // 前提数组为空的特殊情况处理
            if(prerequisites==null||prerequisites.length==0){
                if(numCourses<=0)
                    return new int[]{};
                else{
                    int[] res = new int[numCourses];
                    for(int i = 0;i<numCourses;++i)
                        res[i] = i;
                    return res;
                }
            }
    
            int[] inDegrees = new int[numCourses];
            List<List<Integer>> graph = new LinkedList<>();
            Queue<Integer> queue = new LinkedList<>();
            int[] res = new int[numCourses];
            int index = 0;
    
            // 初始化有向图列表。
            for(int i  = 0;i<numCourses;++i){
                graph.add(new LinkedList<>());
            }
    
            // 构建 边缘列表，表示有向图。添加 有向图的边，比如 A->B。
            // 按照题目要求，这里side[1]是A，side[2]是B
            for(int[] side: prerequisites){
                graph.get(side[1]).add(side[0]);
                ++inDegrees[side[0]];
            }
    
            // 拓扑排序，先把所有入度为0的节点找出
            for(int i = 0;i<numCourses;++i){
                if(inDegrees[i]==0)
                    queue.add(i);
            }
    
            // 开始拓扑排序，每次取出入度为0的节点。
            while(!queue.isEmpty()){
                Integer curNode = queue.poll();
                res[index++] = curNode;// 记录遍历的0入度节点
                List<Integer> toNodes = graph.get(curNode);
                for(Integer toNode: toNodes){
                    if(--inDegrees[toNode]==0){
                        queue.add(toNode);
                    }
                }
            }
    
            // 如果没有遇到闭环，就返回res，否则返回空数组
            return numCourses==index?res:new int[]{};
        }
    }
    ```

  + 参考代码1（11ms，48.35%）：DFS。这里map其实对于A->B存储的方式是 B：A，而不是A：B。也就是下面口口声声说的出节点，应该是入节点才是。

    ```java
    class Solution {
        public int[] findOrder(int numCourses, int[][] prerequisites) {
            Map<Integer, List<Integer>> map = new HashMap<>();
            for(int[] course: prerequisites) {
                int dest = course[1];
                int src = course[0];
                List<Integer> lst = map.getOrDefault(src, new ArrayList<>());
                lst.add(dest);
                map.put(src, lst);
            }
    
            int[] visited = new int[numCourses];
            List<Integer> ans = new ArrayList<>();
            for(int i = 0; i < numCourses; i++) {
                if(!dfs(i, map, visited, ans)) {
                    return new int[0];
                }
            }
            return ans.stream().mapToInt(Integer::intValue).toArray();
        }
    
        /**
        *  node: 当前节点
        *  map: 图
        *  visited: 0表示未访问, 1表示访问中, 2表示访问完成
        *  ans: 储存拓扑排序结果
        * return: 是否无环
        */
        private boolean dfs(int node, Map<Integer, List<Integer>> map, int[] visited, List<Integer> ans) {
            // 已访问
            if(visited[node] == 2) {
                return true;
            }
            // 发现环
            if(visited[node] == 1) {
                return false;
            }
            // 标记访问
            visited[node] = 1;
            // 无出节点, 加入答案，并标记访问完成
            if(!map.containsKey(node)) {
                ans.add(node);
                visited[node] = 2;
                return true;
            }
            // 遍历出节点
            List<Integer> neighbour = map.get(node);
            for(int nei: neighbour) {
                if(!dfs(nei, map, visited, ans)) {
                    return false;
                }
            }
            // 当前节点访问完成
            visited[node] = 2;
            ans.add(node);
            return true;
        }
    }
    ```

  + 参考代码2（23ms）：BFS。整体差不多，不过这里没有特地用二维空间存储边，而是每次都for循环临时找A->B的B节点。

    ```java
    class Solution{    
        // 方法 1 最简单的 BFS
        public int[] findOrder(int numCourses, int[][] prerequisites) {
            if (numCourses == 0) return new int[0];
            int[] inDegrees = new int[numCourses];
            // 建立入度表
            for (int[] p : prerequisites) { // 对于有先修课的课程，计算有几门先修课
                inDegrees[p[0]]++;
            }
            // 入度为0的节点队列
            Queue<Integer> queue = new LinkedList<>();
            for (int i = 0; i < inDegrees.length; i++) {
                if (inDegrees[i] == 0) queue.offer(i);
            }
            int count = 0;  // 记录可以学完的课程数量
            int[] res = new int[numCourses];  // 可以学完的课程
            // 根据提供的先修课列表，删除入度为 0 的节点
            while (!queue.isEmpty()){
                int curr = queue.poll();
                res[count++] = curr;   // 将可以学完的课程加入结果当中
                for (int[] p : prerequisites) {
                    if (p[1] == curr){
                        inDegrees[p[0]]--;
                        if (inDegrees[p[0]] == 0) queue.offer(p[0]);
                    }
                }
            }
            if (count == numCourses) return res;
            return new int[0];
        }
    }
    ```

  + 参考代码3（5ms，91.27%）：HashSet+DFS。这里HashSet存储的方式是 A->B即A：B，但是由于DFS类似栈，所以如果要保证最后数组存储的顺序是拓扑排序，需要用Stack暂存过程数据。这样到时候就是正向的了。

    ```java
    class Solution {
            // 方法 2 升级版：用 HashSet 作为邻接矩阵，加速查找速度
        public int[] findOrder(int numCourses, int[][] prerequisites) {
            if (numCourses == 0) return new int[0];
            // HashSet 作为邻接矩阵
            HashSet<Integer>[] graph = new HashSet[numCourses];
            for (int i = 0; i < numCourses; i++) {
                graph[i] = new HashSet<>();
            }
            for (int[] p : prerequisites) {
                graph[p[1]].add(p[0]);
            }
            int[] mark = new int[numCourses]; // 标记数组
            Stack<Integer> stack = new Stack<>(); // 结果栈
            for (int i = 0; i < numCourses; i++) {
                if(!isCycle(graph, mark, i, stack)) return new int[0];
            }
            int[] res = new int[numCourses];
            for (int i = 0; i < numCourses; i++) {
                res[i] = stack.pop();
            }
            return res;
        }
    
        private boolean isCycle(HashSet<Integer>[] graph, int[] mark, int i, Stack<Integer> stack) {
            if (mark[i] == -1) return true;
            if (mark[i] == 1) return false;
    
            mark[i] = 1;
            for (int neighbor : graph[i]) {
                if (!isCycle(graph, mark, neighbor, stack)) return false;
            }
            mark[i] = -1;
            stack.push(i);
            return true;
        }
    }
    ```

  + 参考代码4（2ms）：这个同样是反向存A->B，变成B：A了，为的是配合DFS。因为DFS向下递归，回溯时添加节点是最后的先添加，前面的再添加。

    当然这里其实也可以变成先添加节点，再往下判断。但是如果这样子，在出现环的情况下，也事先执行了多余的添加操作，效率较低。理论上出现环的时候最好不要有任何操作，直接返回是最好的。

    ```java
    class Solution {
        int[] flag;
        int index = 0;
    
        public int[] findOrder(int numCourses, int[][] prerequisites) {
    
            if (numCourses == 0) {
                return new int[]{};
            }
    
            flag = new int[numCourses];
    
            ArrayList<Integer>[] courses = new ArrayList[numCourses];
            for (int i = 0; i < numCourses; i++) {
                courses[i] = new ArrayList();
            }
            for (int[] pre : prerequisites) {
                courses[pre[0]].add(pre[1]);
            }
    
            int[] orders = new int[numCourses];
            for (int i = 0; i < numCourses; i++) {
                if (!addCourse(orders, courses, i)){
                    return new int[]{};
                }
            }
    
            return orders;
        }
    
        public boolean addCourse(int[] orders, ArrayList<Integer>[] courses, int i) {
            if (flag[i] == 2) {
                return true;
            }
            flag[i] = 1;
            int n = courses[i].size();
            for (int j = 0; j < n; j++) {
                int preNo = courses[i].get(j);
                if (flag[preNo] == 1){
                    return false;
                }
                if (!addCourse(orders, courses, preNo)){
                    return false;
                }
            }
            orders[index++] = i;
            flag[i] = 2;
            return true;
        }
    }
    ```

  + 参考了DFS的写法后，重写（5ms，91.27%）：还可以的时间

    ```java
    class Solution {
        // 结果数组
        int[] res;
        int index;
    
        public int[] findOrder(int numCourses, int[][] prerequisites) {
    
            if(numCourses==0)
                return new int[]{};
    
            // 结果数组
            res = new int[numCourses];
            index = 0;
    
            // 有向图，反向存储。A->B,这里存储 B:A,其实就是存成 B<-A
            HashMap<Integer,ArrayList<Integer>> graph = new HashMap<>();
    
            // 记录DFS的遍历状态，第一次遇到变成1，回溯变成-1.
            // 所以过程中遇到1就说明出现环了->false,遇到-1说明判断过了，不需要再向下，直接true
            int[] visitedState = new int[numCourses];
    
            // 初始化 图
            for(int i = 0;i<numCourses;++i){
                graph.put(i,new ArrayList<>());
            }
    
            // 记录 B <- A
            for(int[] side:prerequisites){
                graph.get(side[0]).add(side[1]);
            }
    
            for(int i = 0;i<numCourses;++i){
                if(!dfs(graph,visitedState,i))
                    return new int[]{};
            }
    
            return res;
        }
    
        public boolean dfs(HashMap<Integer,ArrayList<Integer>> graph,int[] visitedState,int node){
            if(visitedState[node]==1) // 遇到环
                return false;
            if(visitedState[node]==-1) // 已经遍历过了
                return true;
    
            visitedState[node] = 1;
            ArrayList<Integer> inNodes = graph.get(node);// 获取所有node的前驱节点, B<-A ,B <- C,就得到 [A,C]
            for(Integer inNode : inNodes){
                if(!dfs(graph,visitedState,inNode))
                    return false;
            }
    
            visitedState[node] = -1; // 回溯
            res[index++] = node; // 因为其实是反向遍历的，比如A->B->C.这里由于Map存的是 B<-A，所以实际DFS是 C<-B<-A。所以存的时候，是从A开始存的
            return true;
        }
    }
    ```

  8. 矩阵中的最长递增路径

  + 语言：java

  + 思路：第一想法，就是DFS加标记路径。这样肯定短的路径就没必要当作起点了。然后超时了。看了下官方的DFS解答，说起来你可能不信，我想过缓存路径值，但是我没想到怎么正确缓存。原来只要路径值在回溯时返回获取到的最大值就好了。

  + 代码（7ms，100%）：

    ```java
    public class Solution {
        int xLen;
        int yLen;
    
        public int longestIncreasingPath(int[][] matrix) {
            xLen = matrix.length;
            if (xLen == 0) return 0;
            yLen = matrix[0].length;
            if (yLen == 0) return 0;
            int[][] cache = new int[xLen][yLen];
            int res = 0;
            for(int i = 0;i<xLen;++i){
                for(int j =0;j<yLen;++j){
                    if(cache[i][j]==0){
                        res = Math.max(res,dfs(matrix,cache,i,j));
                    }
                }
            }
            return res;
        }
    
        public int dfs(int[][] matrix,int[][] cache,int x,int y){
            if(cache[x][y]!=0) return cache[x][y];
            int curVal = matrix[x][y]; // 当前值
            int roadVal = 0;
            if(x>0&&matrix[x-1][y]>curVal) // 上
                roadVal = Math.max(roadVal,dfs(matrix,cache,x-1,y));
            if(y+1<yLen&&matrix[x][y+1]>curVal) // 右
                roadVal = Math.max(roadVal,dfs(matrix,cache,x,y+1));
            if(x+1<xLen&&matrix[x+1][y]>curVal) // 下
                roadVal = Math.max(roadVal,dfs(matrix,cache,x+1,y));
            if(y>0&&matrix[x][y-1]>curVal) // 左
                roadVal = Math.max(roadVal,dfs(matrix,cache,x,y-1));
            ++roadVal;
            cache[x][y]=roadVal;
            return roadVal;
        }
    }
    ```

  + 参考代码1（11ms，75.14%）：记忆化深度优先搜索

    > [矩阵中的最长递增路径--官方解答](https://leetcode-cn.com/problems/longest-increasing-path-in-a-matrix/solution/ju-zhen-zhong-de-zui-chang-di-zeng-lu-jing-by-leet/)

    ```java
    // DFS + Memoization Solution
    // Accepted and Recommended
    public class Solution {
        private static final int[][] dirs = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
        private int m, n;
    
        public int longestIncreasingPath(int[][] matrix) {
            if (matrix.length == 0) return 0;
            m = matrix.length; n = matrix[0].length;
            int[][] cache = new int[m][n];
            int ans = 0;
            for (int i = 0; i < m; ++i)
                for (int j = 0; j < n; ++j)
                    ans = Math.max(ans, dfs(matrix, i, j, cache));
            return ans;
        }
    
        private int dfs(int[][] matrix, int i, int j, int[][] cache) {
            if (cache[i][j] != 0) return cache[i][j];
            for (int[] d : dirs) {
                int x = i + d[0], y = j + d[1];
                if (0 <= x && x < m && 0 <= y && y < n && matrix[x][y] > matrix[i][j])
                    cache[i][j] = Math.max(cache[i][j], dfs(matrix, x, y, cache));
            }
            return ++cache[i][j];
        }
    }
    ```

  + 参考代码2（22ms，17.43%）：“剥洋葱”（动态规划） 。其实就是拓扑排序，把原本二维数组用来构建有向图，计算每个点的出度。每进行一轮逆向拓扑排序，就res++；因为肯定无环，所以最后一个节点弹出queue时，获取到最大的res。

    这个写法，个人刚觉不是很好。因为题目明明没说每个节点不能是负数，下面这个在数组里面全是负数的情况就歇菜了。

    > [矩阵中的最长递增路径--官方解答](https://leetcode-cn.com/problems/longest-increasing-path-in-a-matrix/solution/ju-zhen-zhong-de-zui-chang-di-zeng-lu-jing-by-leet/)

    ```java
    // Topological Sort Based Solution
    // An Alternative Solution
    public class Solution {
        private static final int[][] dir = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
        private int m, n;
        public int longestIncreasingPath(int[][] grid) {
            int m = grid.length;
            if (m == 0) return 0;
            int n = grid[0].length;
            // padding the matrix with zero as boundaries
            // assuming all positive integer, otherwise use INT_MIN as boundaries
            int[][] matrix = new int[m + 2][n + 2];
            for (int i = 0; i < m; ++i)
                System.arraycopy(grid[i], 0, matrix[i + 1], 1, n);
    
            // calculate outdegrees
            int[][] outdegree = new int[m + 2][n + 2];
            for (int i = 1; i <= m; ++i)
                for (int j = 1; j <= n; ++j)
                    for (int[] d: dir)
                        if (matrix[i][j] < matrix[i + d[0]][j + d[1]])
                            outdegree[i][j]++;
    
            // find leaves who have zero out degree as the initial level
            List<int[]> leaves = new ArrayList<>();
            for (int i = 1; i <= m; ++i)
                for (int j = 1; j <= n; ++j)
                    if (outdegree[i][j] == 0) leaves.add(new int[]{i, j});
    
            // remove leaves level by level in topological order
            int height = 0;
            while (!leaves.isEmpty()) {
                height++;
                List<int[]> newLeaves = new ArrayList<>();
                for (int[] node : leaves) {
                    for (int[] d:dir) {
                        int x = node[0] + d[0], y = node[1] + d[1];
                        if (matrix[node[0]][node[1]] > matrix[x][y])
                            if (--outdegree[x][y] == 0)
                                newLeaves.add(new int[]{x, y});
                    }
                }
                leaves = newLeaves;
            }
            return height;
        }
    }
    ```

  + 参考代码3（7ms）：

    ```java
    class Solution {
        int[][] cache;
        int x;
        int y;
        int max = 0;
        int[][] matrix;
    
        public int longestIncreasingPath(int[][] matrix) {
            this.matrix = matrix;
            x = matrix.length;
            if (x == 0) return 0;
            y = matrix[0].length;
            if (y == 0) return 0;
            cache = new int[matrix.length][matrix[0].length];
            for (int i = 0; i < x; i++) {
                for (int j = 0; j < y; j++) {
                    search(i, j);
    
                }
            }
            return max;
        }
    
        public int search(int nowX, int nowY) {
            if (cache[nowX][nowY] > 0) return cache[nowX][nowY];
            int val = matrix[nowX][nowY];
            int thisMax = 1;
            if (nowX + 1 < x && val < matrix[nowX + 1][nowY]) {
                thisMax = Math.max(thisMax, search(nowX + 1, nowY) + 1);
            }
            if (nowX - 1 >= 0 && val < matrix[nowX - 1][nowY]) {
                thisMax = Math.max(thisMax, search(nowX - 1, nowY) + 1);
            }
            if (nowY + 1 < y && val < matrix[nowX][nowY + 1]) {
                thisMax = Math.max(thisMax, search(nowX, nowY + 1) + 1);
            }
            if (nowY - 1 >= 0 && val < matrix[nowX][nowY - 1]) {
                thisMax = Math.max(thisMax, search(nowX, nowY - 1) + 1);
            }
            cache[nowX][nowY] = thisMax;
            max = Math.max(thisMax, max);
            return thisMax;
        }
    }
    ```

  9. 计算右侧小于当前元素的个数

  + 语言：java

  + 思路：本来和之前的逆序对思路一样，就是归并排序，然后在归并过程中，计算右侧小于当前元素的个数（其实也就是求逆序对的数量），后面发现，归并的合并过程，是改变数组原本的位置的，并没有想象中那么简单。这里看了他人的思路，需要用到**索引数组**，原始数组仍然用于比较数值，而交换位置只在索引数组上进行。

    > [归并排序 + 索引数组](https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/solution/gui-bing-pai-xu-suo-yin-shu-zu-python-dai-ma-java-/)

  + 代码（5ms，97.25%）：

    ```java
    class Solution {
        public List<Integer> countSmaller(int[] nums) {
            int len = nums.length;
            int[] temp = new int[len]; // 归并排序用的临时数组
            int[] indexs = new int[len]; // 为了避免修改原数组，而使用索引数组
            int[] count = new int[len]; // 统计右侧小于自己的数字的个数
    
            for(int i = 0;i<len;++i)
                indexs[i] = i;
            // 归并排序
            mergeSort(nums, 0, len-1, temp,indexs,count );
    
            ArrayList<Integer> res = new ArrayList<>(len);
            for(int num:count){
                res.add(num);
            }
            return res;
        }
    
        // 归并排序，这里主要是划分区间和调用合并函数
        public void mergeSort(int[] nums,int left,int right,int[] temp,int[] indexs,int[] count){
            if(left<right){
                int mid = left+(right-left) / 2;
                mergeSort(nums,left, mid,temp,indexs,count); // 左边归并
                mergeSort(nums,mid+1, right,temp,indexs,count); // 右边归并
                if(nums[indexs[mid]]>nums[indexs[mid+1]]) // 如果都有序了，就没必要合并了
                    merge(nums,left,mid,right,temp,indexs,count);
            }
        }
    
        // 56789 234567
    
        // 合并，并且计算右侧比自己小的数字
        public void merge(int[] nums,int left,int mid,int right,int[] temp,int[] indexs,int[] count){
            int i=left,j=mid+1,t=0;// 遍历左边、右边，填写回原数组的下标
            while(i<=mid&&j<=right){
                if(nums[indexs[i]]<=nums[indexs[j]]){
                    count[indexs[i]] += j-mid-1;
                    temp[t++] = indexs[i++];
                }else{
                    temp[t++] = indexs[j++];
                }
            }
            while(i<=mid){
                count[indexs[i]] += j-mid-1;
                temp[t++] = indexs[i++];
            }
            while(j<=right){
                temp[t++] = indexs[j++];
            }
            t = 0;
            while(left<=right){
                indexs[left++] = temp[t++];
            }
        }
    }
    ```

  + 参考代码1（7ms，73.35%）：

    > [归并排序 + 索引数组](https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/solution/gui-bing-pai-xu-suo-yin-shu-zu-python-dai-ma-java-/)

    ```java
    import java.util.ArrayList;
    import java.util.List;
    
    public class Solution {
    
        private int[] temp;
        private int[] counter;
        private int[] indexes;
    
        public List<Integer> countSmaller(int[] nums) {
            List<Integer> res = new ArrayList<>();
            int len = nums.length;
            if (len == 0) {
                return res;
            }
            temp = new int[len];
            counter = new int[len];
            indexes = new int[len];
            for (int i = 0; i < len; i++) {
                indexes[i] = i;
            }
            mergeAndCountSmaller(nums, 0, len - 1);
            for (int i = 0; i < len; i++) {
                res.add(counter[i]);
            }
            return res;
        }
    
        /**
         * 针对数组 nums 指定的区间 [l, r] 进行归并排序，在排序的过程中完成统计任务
         *
         * @param nums
         * @param l
         * @param r
         */
        private void mergeAndCountSmaller(int[] nums, int l, int r) {
            if (l == r) {
                // 数组只有一个元素的时候，没有比较，不统计
                return;
            }
            int mid = l + (r - l) / 2;
            mergeAndCountSmaller(nums, l, mid);
            mergeAndCountSmaller(nums, mid + 1, r);
            // 归并排序的优化，同样适用于该问题
            // 如果索引数组有序，就没有必要再继续计算了
            if (nums[indexes[mid]] > nums[indexes[mid + 1]]) {
                mergeOfTwoSortedArrAndCountSmaller(nums, l, mid, r);
            }
        }
    
        /**
         * [l, mid] 是排好序的
         * [mid + 1, r] 是排好序的
         *
         * @param nums
         * @param l
         * @param mid
         * @param r
         */
        private void mergeOfTwoSortedArrAndCountSmaller(int[] nums, int l, int mid, int r) {
            // 3,4  1,2
            for (int i = l; i <= r; i++) {
                temp[i] = indexes[i];
            }
            int i = l;
            int j = mid + 1;
            // 左边出列的时候，计数
            for (int k = l; k <= r; k++) {
                if (i > mid) {
                    indexes[k] = temp[j];
                    j++;
                } else if (j > r) {
                    indexes[k] = temp[i];
                    i++;
                    // 此时 j 用完了，[7,8,9 | 1,2,3]
                    // 之前的数就和后面的区间长度构成逆序
                    counter[indexes[k]] += (r - mid);
                } else if (nums[temp[i]] <= nums[temp[j]]) {
                    indexes[k] = temp[i];
                    i++;
                    // 此时 [4,5, 6   | 1,2,3 10 12 13]
                    //           mid          j
                    counter[indexes[k]] += (j - mid - 1);
                } else {
                    // nums[indexes[i]] > nums[indexes[j]] 构成逆序
                    indexes[k] = temp[j];
                    j++;
                }
            }
        }
    
        public static void main(String[] args) {
            int[] nums = new int[]{5, 2, 6, 1};
            Solution solution = new Solution();
            List<Integer> countSmaller = solution.countSmaller(nums);
            System.out.println(countSmaller);
        }
    }
    ```

  + 参考代码2（2ms）：
  
    ```java
    class Solution {
        public List<Integer> countSmaller(int[] nums) {
            if (nums.length == 0) {
                return new ArrayList<>();
            }
    
            //nums数组最小值
            int min = Integer.MAX_VALUE;
            for (int value : nums) {
                if (value < min) {
                    min = value;
                }
            }
    
            //减去最小值，保证都是正数
            for (int i = 0; i < nums.length; i++) {
                nums[i] = nums[i] - min + 1;
            }
    
            //nums数组最大值
            int max = Integer.MIN_VALUE;
            for (int value : nums) {
                if (value > max) {
                    max = value;
                }
            }
    
            int[] BITree = new int[max + 1];
            BITree[0] = 0;
            int[] countArr = new int[nums.length];
            for (int i = nums.length - 1; i >= 0; i--) {
                int count = getSum(nums[i] - 1, BITree);
                countArr[i] = count;
                update(nums[i], BITree);
            }
            List<Integer> result = new ArrayList<>();
            for (int value : countArr) {
                result.add(value);
            }
            return result;
        }
        //获得a[i]从1，value的和
        private int getSum(int value, int[] BITree) {
            int sum = 0;
            while (value > 0) {
                sum += BITree[value];
                value -= lowbit(value);
            }
            return sum;
        }
    
        //更新树状数组
        private void update(int value, int[] BITree) {
            while (value <= BITree.length - 1) {
                BITree[value] += 1;
                value += lowbit(value);
            }
        }
    
        //求出m的二进制表示的末尾1的位置
        private int lowbit(int x){
            return x & (-x);
        }
    }
    ```
  
  + 参考代码3（11ms）：
  
    > [利用二叉排序树](https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/solution/li-yong-er-cha-pai-xu-shu-by-huihuiyue/)
  
    ```java
    class Solution {
        public List<Integer> countSmaller(int[] nums) {
            Integer[] ret = new Integer[nums.length];
            for (int i = 0; i < nums.length; i++) {
                ret[i] = 0;
            }
            List<Integer> list = new ArrayList<>();
            TreeNode root = null;
            for (int i = nums.length - 1; i >= 0; i--) {
                root = insert(root, new TreeNode(nums[i]), ret, i);
            }
            return Arrays.asList(ret);
        }
    
        public TreeNode insert(TreeNode root, TreeNode node, Integer[] ret, int i) {
            if (root == null) {
                root = node;
                return root;
            }
            if (root.val >= node.val) { // 注意小于等于插入到左子树，防止多加1
                root.count++;
                root.left = insert(root.left, node, ret, i);
            } else {
                ret[i] += root.count + 1;
                root.right = insert(root.right, node, ret, i);
            }
            return root;
        }
    }
    
    class TreeNode {
        int val;
        int count;
        TreeNode left;
        TreeNode right;
        TreeNode(int val) {
            this.val = val;
            left = null;
            right = null;
            count = 0;
        }
    }
    ```
  
  + 看了参考代码3后，尝试写一个（6ms，79.17%）：
  
    ```java
    class Solution {
        public List<Integer> countSmaller(int[] nums) {
            int len = nums.length;
            int[] count = new int[len]; // 统计右侧小于自己的数字的个数
    
            TreeNode root = null;
            for(int i = len-1;i>=0;--i){ // 二叉搜索树，从右边开始创建
                root = insert(nums,root,new TreeNode(nums[i]),i,count);
            }
    
            ArrayList<Integer> res = new ArrayList<>(len);
            for(int num:count){
                res.add(num);
            }
            return res;
        }
    
        public TreeNode insert(int[]nums,TreeNode root, TreeNode node,int i,int[] count){
            if(root==null){
                root = node;
                return root;
            }
            if(root.val>=node.val){
                root.left = insert(nums,root.left,node,i,count);
                root.count ++; // 当前新进来的节点比当前树节点小，之前的树节点分量+1，这样之后别的树直接和当前树比较，不用再往下计算count了。
            } else{
                root.right = insert(nums,root.right,node,i,count);
                count[i] += root.count+1; // 当前的新节点比树根节点大，把当前树根节点的份额加上这个树本身，root.count+1赋值给当前count[i]
            }
    
            return root;
        }
    
    
        class TreeNode{
            int val; // 当前值
            int count; // 右边小于自己的数值的 总数量
            TreeNode left;
            TreeNode right;
            TreeNode(int val){
                this.val = val;
            }
        }
    }
    ```
  
    

