# 设计模式_菜鸟教程-学习笔记

> [设计模式-菜鸟教程](https://www.runoob.com/design-pattern/design-pattern-tutorial.html)
>
> **标题标星号，表示我觉得比较重要的**。

# 0. 设计模式简介

## 0.1 GOF(四人帮，Gang of Four)

 在 1994 年，由 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 四人合著出版了一本名为 **Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素）** 的书，该书首次提到了软件开发中设计模式的概念。

四位作者合称 **GOF（四人帮，全拼 Gang of Four）**。他们所提出的设计模式主要是基于以下的面向对象设计原则。

- **对接口编程而不是对实现编程。**
- **优先使用对象组合而不是继承。**

## 0.2 * 设计模式的类型

​	根据设计模式的参考书 **Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素）** 中所提到的，总共有 23 种设计模式。

这些模式可以分为三大类：

+ 创建型模式（Creational Patterns）
+ 结构型模式（Structural Patterns）
+ 行为型模式（Behavioral Patterns）

当然，我们还会讨论另一类设计模式：J2EE 设计模式。

| 序号 | 模式 & 描述                                                  | 包括                                                         |
| :--- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| 1    | **创建型模式** <br>这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。 | 工厂模式（Factory Pattern） <br/>抽象工厂模式（Abstract Factory Pattern） <br/>单例模式（Singleton Pattern） <br/>建造者模式（Builder Pattern） <br/>原型模式（Prototype Pattern） |
| 2    | **结构型模式** <br/>这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。 | 适配器模式（Adapter Pattern） <br/>桥接模式（Bridge Pattern） <br/>过滤器模式（Filter、Criteria Pattern） <br/>组合模式（Composite Pattern） <br/>装饰器模式（Decorator Pattern） <br/>外观模式（Facade Pattern） <br/>享元模式（Flyweight Pattern） <br/>代理模式（Proxy Pattern） |
| 3    | **行为型模式**  <br/>这些设计模式特别关注对象之间的通信。    | 责任链模式（Chain of Responsibility Pattern） <br/>命令模式（Command Pattern） <br/>解释器模式（Interpreter Pattern） <br/>迭代器模式（Iterator Pattern） <br/>中介者模式（Mediator Pattern） <br/>备忘录模式（Memento Pattern） <br/>观察者模式（Observer Pattern） <br/>状态模式（State Pattern） <br/>空对象模式（Null Object Pattern） <br/>策略模式（Strategy Pattern） <br/>模板模式（Template Pattern） <br/>访问者模式（Visitor Pattern） |
| 4    | **J2EE 模式**  <br/>这些设计模式特别关注表示层。这些模式是由 Sun Java Center 鉴定的。 | MVC 模式（MVC Pattern）<br/>业务代表模式（Business Delegate Pattern）<br/>组合实体模式（Composite Entity Pattern）<br/>数据访问对象模式（Data Access Object Pattern）<br/>前端控制器模式（Front Controller Pattern）<br/>拦截过滤器模式（Intercepting Filter Pattern）<br/>服务定位器模式（Service Locator Pattern）<br/>传输对象模式（Transfer Object Pattern）<br/>................................................................................................. |

下面用一个图片来整体描述一下设计模式之间的关系：

![设计模式之间的关系](https://www.runoob.com/wp-content/uploads/2014/08/the-relationship-between-design-patterns.jpg)

## 0.3 * 设计模式-七大原则

1. 开闭原则（Open Close Principle）

   开闭原则的意思是：**对扩展开放，对修改关闭**。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。

2. 里氏代换原则（Liskov Substitution Principle）

   里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。

3. 依赖倒转原则（Dependence Inversion Principle）

   这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。

4. 接口隔离原则（Interface Segregation Principle）

   这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。

5. 迪米特法则，又称最少知道原则（Demeter Principle）

   最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。

6. 合成复用原则（Composite Reuse Principle）

   合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。
   
7. 单一职责原则（Single Responsibilities Principle）

   单一职责原则其实就是为了提高内聚性一个说明，它的目的就保证了内聚性，只有一个引起变化的原因，说明类内成员之间的关系较高，内聚性不强的就不要写到一个类中。这就是单一职责的真正用意。

# 1. 工厂模式

​	工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。

​	在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。

## 1.1 介绍

**意图：**定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，<u>工厂模式使其创建过程延迟到子类进行</u>。

**主要解决：**主要解决接口选择的问题。

**何时使用：**我们明确地计划不同条件下创建不同实例时。

**如何解决：**让其子类实现工厂接口，返回的也是一个抽象的产品。

**关键代码：**创建过程在其子类执行。

**应用实例：** 1、您需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现。 2、Hibernate 换数据库只需换方言和驱动就可以。

**优点：** 1、一个调用者想创建一个对象，只要知道其名称就可以了。 2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 3、屏蔽产品的具体实现，调用者只关心产品的接口。

**缺点：**每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。

**使用场景：** 1、日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。 2、数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。 3、设计一个连接服务器的框架，需要三个协议，"POP3"、"IMAP"、"HTTP"，可以把这三个作为产品类，共同实现一个接口。

**注意事项：**作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的地方就是<u>复杂对象适合使用工厂模式</u>，而简单对象，特别是只需要通过 new 就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。

## 1.2 实现

​	我们将创建一个 *Shape* 接口和实现 *Shape* 接口的实体类。下一步是定义工厂类 *ShapeFactory*。

​	*FactoryPatternDemo* 类使用 *ShapeFactory* 来获取 *Shape* 对象。它将向 *ShapeFactory* 传递信息（*CIRCLE / RECTANGLE / SQUARE*），以便获取它所需对象的类型。

![工厂模式的 UML 图](https://www.runoob.com/wp-content/uploads/2014/08/AB6B814A-0B09-4863-93D6-1E22D6B07FF8.jpg)

**步骤1**

创建一个接口：

```java
public interface Shape {
   void draw();
}
```

**步骤2**

创建实现接口的实体类。

```java
public class Rectangle implements Shape {
   @Override
   public void draw() {
      System.out.println("Inside Rectangle::draw() method.");
   }
}
```

```java
public class Square implements Shape {
   @Override
   public void draw() {
      System.out.println("Inside Square::draw() method.");
   }
}
```

```java
public class Circle implements Shape {
   @Override
   public void draw() {
      System.out.println("Inside Circle::draw() method.");
   }
}
```

**步骤3**

创建一个工厂，生成基于给定信息的实体类的对象。

```java
public class ShapeFactory {
   //使用 getShape 方法获取形状类型的对象
   public Shape getShape(String shapeType){
      if(shapeType == null){
         return null;
      }
      if(shapeType.equalsIgnoreCase("CIRCLE")){
         return new Circle();
      } else if(shapeType.equalsIgnoreCase("RECTANGLE")){
         return new Rectangle();
      } else if(shapeType.equalsIgnoreCase("SQUARE")){
         return new Square();
      }
      return null;
   }
}
```

**步骤4**

使用该工厂，通过传递类型信息来获取实体类的对象。

```java
public class FactoryPatternDemo {
   public static void main(String[] args) {
      ShapeFactory shapeFactory = new ShapeFactory();
      //获取 Circle 的对象，并调用它的 draw 方法
      Shape shape1 = shapeFactory.getShape("CIRCLE");
      //调用 Circle 的 draw 方法
      shape1.draw();
      //获取 Rectangle 的对象，并调用它的 draw 方法
      Shape shape2 = shapeFactory.getShape("RECTANGLE");
      //调用 Rectangle 的 draw 方法
      shape2.draw();
      //获取 Square 的对象，并调用它的 draw 方法
      Shape shape3 = shapeFactory.getShape("SQUARE");
      //调用 Square 的 draw 方法
      shape3.draw();
   }
}
```

**步骤5**

执行程序，输出结果：

```java
Inside Circle::draw() method.
Inside Rectangle::draw() method.
Inside Square::draw() method.
```

## 1.3 评论区补充

1. 工厂模式概述

   > **一、一句话概括工厂模式**
   >
   > -  **简单工厂**：一个工厂类，一个产品抽象类。
   > -  **工厂方法**：多个工厂类，一个产品抽象类。
   > -  **抽象工厂**：多个工厂类，多个产品抽象类。
   >
   > **二、生活中的工厂模式**
   >
   > -  简单工厂类：一个麦当劳店，可以生产多种汉堡。
   > -  工厂方法类：一个麦当劳店，可以生产多种汉堡。一个肯德基店，也可以生产多种汉堡。
   > -  抽象工厂类：百胜餐饮集团下有肯德基和百事公司，肯德基生产汉堡，百事公司生成百事可乐。

# 2. 抽象工厂模式

​	抽象工厂模式（Abstract Factory Pattern）是围绕**一个超级工厂创建其他工厂**。该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。

​	在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。

## 2.1 介绍

**意图：**提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。

**主要解决：**主要解决接口选择的问题。

**何时使用：**系统的产品有多于一个的产品族，而系统只消费其中某一族的产品。

**如何解决：**在一个产品族里面，定义多个产品。

**关键代码：**在一个工厂里聚合多个同类产品。

**应用实例：**工作了，为了参加一些聚会，肯定有两套或多套衣服吧，比如说有商务装（成套，一系列具体产品）、时尚装（成套，一系列具体产品），甚至对于一个家庭来说，可能有商务女装、商务男装、时尚女装、时尚男装，这些也都是成套的，即一系列具体产品。假设一种情况（现实中是不存在的，要不然，没法进入共产主义了，但有利于说明抽象工厂模式），在您的家中，某一个衣柜（具体工厂）只能存放某一种这样的衣服（成套，一系列具体产品），每次拿这种成套的衣服时也自然要从这个衣柜中取出了。用 OOP 的思想去理解，所有的衣柜（具体工厂）都是衣柜类的（抽象工厂）某一个，而每一件成套的衣服又包括具体的上衣（某一具体产品），裤子（某一具体产品），这些具体的上衣其实也都是上衣（抽象产品），具体的裤子也都是裤子（另一个抽象产品）。

**优点：**当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。

**缺点：**产品族扩展非常困难，要增加一个系列的某一产品，既要在抽象的 Creator 里加代码，又要在具体的里面加代码。

**使用场景：** 1、QQ 换皮肤，一整套一起换。 2、生成不同操作系统的程序。

**注意事项：**产品族难扩展，产品等级易扩展。

## 2.2 实现

​	我们将创建 *Shape* 和 *Color* 接口和实现这些接口的实体类。下一步是创建抽象工厂类 *AbstractFactory*。接着定义工厂类 *ShapeFactory* 和 *ColorFactory*，这两个工厂类都是扩展了 *AbstractFactory*。然后创建一个工厂创造器/生成器类 *FactoryProducer*。

​	*AbstractFactoryPatternDemo* 类使用 *FactoryProducer* 来获取 *AbstractFactory* 对象。它将向 *AbstractFactory* 传递形状信息 *Shape*（*CIRCLE / RECTANGLE / SQUARE*），以便获取它所需对象的类型。同时它还向 *AbstractFactory* 传递颜色信息 *Color*（*RED / GREEN / BLUE*），以便获取它所需对象的类型。

![抽象工厂模式的 UML 图](https://www.runoob.com/wp-content/uploads/2014/08/3E13CDD1-2CD2-4C66-BD33-DECBF172AE03.jpg)

**步骤1**

为形状创建一个接口。

```java
public interface Shape {
   void draw();
}
```

**步骤2**

创建实现接口的实体类。

```java
public class Rectangle implements Shape {
  @Override
  public void draw() {
    System.out.println("Inside Rectangle::draw() method.");
  }
}
```

```java
public class Square implements Shape {
  @Override
  public void draw() {
    System.out.println("Inside Square::draw() method.");
  }
}
```

```java
public class Circle implements Shape {
  @Override
  public void draw() {
    System.out.println("Inside Circle::draw() method.");
  }
}
```

**步骤3**

为颜色创建一个接口。

```java
public interface Color {
  void fill();
}
```

**步骤4**

创建实现接口的实体类。

```java
public class Red implements Color {
  @Override
  public void fill() {
    System.out.println("Inside Red::fill() method.");
  }
}
```

```java
public class Green implements Color {
  @Override
  public void fill() {
    System.out.println("Inside Green::fill() method.");
  }
}
```

```java
public class Blue implements Color {
  @Override
  public void fill() {
    System.out.println("Inside Blue::fill() method.");
  }
}
```

**步骤5**

为 Color 和 Shape 对象创建抽象类来获取工厂。

```java
public abstract class AbstractFactory {
  public abstract Color getColor(String color);
  public abstract Shape getShape(String shape) ;
}
```

 **步骤6**

创建扩展了 AbstractFactory 的工厂类，基于给定的信息生成实体类的对象。

```java
public class ShapeFactory extends AbstractFactory {
  @Override
  public Shape getShape(String shapeType){
    if(shapeType == null){
      return null;
    }        
    if(shapeType.equalsIgnoreCase("CIRCLE")){
      return new Circle();
    } else if(shapeType.equalsIgnoreCase("RECTANGLE")){
      return new Rectangle();
    } else if(shapeType.equalsIgnoreCase("SQUARE")){
      return new Square();
    }
    return null;
  }
  @Override
  public Color getColor(String color) {
    return null;
  }
}
```

```java
public class ColorFactory extends AbstractFactory {
  @Override
  public Shape getShape(String shapeType){
    return null;
  }
  @Override
  public Color getColor(String color) {
    if(color == null){
      return null;
    }        
    if(color.equalsIgnoreCase("RED")){
      return new Red();
    } else if(color.equalsIgnoreCase("GREEN")){
      return new Green();
    } else if(color.equalsIgnoreCase("BLUE")){
      return new Blue();
    }
    return null;
  }
}
```

**步骤7**

创建一个工厂创造器/生成器类，通过传递形状或颜色信息来获取工厂。

```java
public class FactoryProducer {
  public static AbstractFactory getFactory(String choice){
    if(choice.equalsIgnoreCase("SHAPE")){
      return new ShapeFactory();
    } else if(choice.equalsIgnoreCase("COLOR")){
      return new ColorFactory();
    }
    return null;
  }
}
```

**步骤8**

使用 FactoryProducer 来获取 AbstractFactory，通过传递类型信息来获取实体类的对象。

```java
public class AbstractFactoryPatternDemo {
  public static void main(String[] args) {
    //获取形状工厂
    AbstractFactory shapeFactory = FactoryProducer.getFactory("SHAPE");
    //获取形状为 Circle 的对象
    Shape shape1 = shapeFactory.getShape("CIRCLE");
    //调用 Circle 的 draw 方法
    shape1.draw();
    //获取形状为 Rectangle 的对象
    Shape shape2 = shapeFactory.getShape("RECTANGLE");
    //调用 Rectangle 的 draw 方法
    shape2.draw();
    //获取形状为 Square 的对象
    Shape shape3 = shapeFactory.getShape("SQUARE");
    //调用 Square 的 draw 方法
    shape3.draw();
    //获取颜色工厂
    AbstractFactory colorFactory = FactoryProducer.getFactory("COLOR");
    //获取颜色为 Red 的对象
    Color color1 = colorFactory.getColor("RED");
    //调用 Red 的 fill 方法
    color1.fill();
    //获取颜色为 Green 的对象
    Color color2 = colorFactory.getColor("Green");
    //调用 Green 的 fill 方法
    color2.fill();
    //获取颜色为 Blue 的对象
    Color color3 = colorFactory.getColor("BLUE");
    //调用 Blue 的 fill 方法
    color3.fill();
  }
}
```

**步骤9**

执行程序，输出结果：

```java
Inside Circle::draw() method.
Inside Rectangle::draw() method.
Inside Square::draw() method.
Inside Red::fill() method.
Inside Green::fill() method.
Inside Blue::fill() method.
```

## 2.3 * 评论区补充

1. 简单工厂模式、工厂模式、抽象工厂模式

   下面例子中鼠标，键盘，耳麦为产品，惠普，戴尔为工厂。

   **简单工厂模式**

   简单工厂模式不是 23 种里的一种，简而言之，就是有一个专门生产某个产品的类。

   比如下图中的鼠标工厂，专业生产鼠标，给参数 0，生产戴尔鼠标，给参数 1，生产惠普鼠标。

   ![img](https://www.runoob.com/wp-content/uploads/2018/07/1530601914-2143-DP-SimpleFactory.png)

   **工厂模式**

   工厂模式也就是鼠标工厂是个父类，有生产鼠标这个接口。

   戴尔鼠标工厂，惠普鼠标工厂继承它，可以分别生产戴尔鼠标，惠普鼠标。

   生产哪种鼠标不再由参数决定，而是创建鼠标工厂时，由戴尔鼠标工厂创建。

   后续直接调用**鼠标工厂.生产鼠标()**即可

   ![img](https://www.runoob.com/wp-content/uploads/2018/07/1530601917-1999-DP-Factory.png)

   **抽象工厂模式**

   抽象工厂模式也就是不仅生产鼠标，同时生产键盘。

   也就是 PC 厂商是个父类，有生产鼠标，生产键盘两个接口。

   戴尔工厂，惠普工厂继承它，可以分别生产戴尔鼠标+戴尔键盘，和惠普鼠标+惠普键盘。

   创建工厂时，由戴尔工厂创建。

   后续**工厂.生产鼠标()**则生产戴尔鼠标，**工厂.生产键盘()**则生产戴尔键盘。

   ![img](https://www.runoob.com/wp-content/uploads/2018/07/1530601916-7298-DP-AbstractFactory.png)

   > 在抽象工厂模式中，假设我们需要增加一个工厂

   假设我们增加华硕工厂，则我们需要增加华硕工厂，和戴尔工厂一样，继承 PC 厂商。

   之后创建华硕鼠标，继承鼠标类。创建华硕键盘，继承键盘类即可。

   ![img](https://www.runoob.com/wp-content/uploads/2018/07/1530601980-8080-P-AbstractFactory-AddFactory.png)

   > 在抽象工厂模式中，假设我们需要增加一个产品

   假设我们增加耳麦这个产品，则首先我们需要增加耳麦这个父类，再加上戴尔耳麦，惠普耳麦这两个子类。

   之后在PC厂商这个父类中，增加生产耳麦的接口。最后在戴尔工厂，惠普工厂这两个类中，分别实现生产戴尔耳麦，惠普耳麦的功能。 以上。

   ![img](https://www.runoob.com/wp-content/uploads/2018/07/1530601917-7462-P-AbstractFactory-AddProduct.png)

# 3. 单例模式

​	单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。

​	这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。

**注意：**

- 1、单例类只能有一个实例。
- 2、单例类必须自己创建自己的唯一实例。
- 3、单例类必须给所有其他对象提供这一实例。

## 3.1 介绍

**意图：**<u>保证一个类仅有一个实例，并提供一个访问它的全局访问点</u>。

**主要解决：**一个全局使用的类频繁地创建与销毁。

**何时使用：**当您想控制实例数目，节省系统资源的时候。

**如何解决：**判断系统是否已经有这个单例，如果有则返回，如果没有则创建。

**关键代码：**构造函数是私有的。

**应用实例：**

- 1、一个班级只有一个班主任。
- 2、Windows 是多进程多线程的，在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行。
- 3、一些设备管理器常常设计为单例模式，比如一个电脑有两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件。

**优点：**

- 1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。
- 2、<u>避免对资源的多重占用（比如写文件操作）</u>。

**缺点：**没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。

**使用场景：**

- 1、要求生产唯一序列号。
- 2、<u>WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来</u>。
- 3、<u>创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等</u>。

**注意事项：**getInstance() 方法中需要使用同步锁 synchronized (Singleton.class) 防止多线程同时进入造成 instance 被多次实例化。

## 3.2 实现

我们将创建一个 *SingleObject* 类。*SingleObject* 类有它的私有构造函数和本身的一个静态实例。

*SingleObject* 类提供了一个静态方法，供外界获取它的静态实例。*SingletonPatternDemo* 类使用 *SingleObject* 类来获取 *SingleObject* 对象。

![单例模式的 UML 图](https://www.runoob.com/wp-content/uploads/2014/08/62576915-36E0-4B67-B078-704699CA980A.jpg)

**步骤1**

创建一个 Singleton 类。

```java
public class SingleObject {
  //创建 SingleObject 的一个对象
  private static SingleObject instance = new SingleObject();
  //让构造函数为 private，这样该类就不会被实例化
  private SingleObject(){}
  //获取唯一可用的对象
  public static SingleObject getInstance(){
    return instance;
  }
  public void showMessage(){
    System.out.println("Hello World!");
  }
}
```

**步骤2**

从 singleton 类获取唯一的对象。

```java
public class SingletonPatternDemo {
  public static void main(String[] args) {
    //不合法的构造函数
    //编译时错误：构造函数 SingleObject() 是不可见的
    //SingleObject object = new SingleObject();
    //获取唯一可用的对象
    SingleObject object = SingleObject.getInstance();
    //显示消息
    object.showMessage();
  }
}
```

**步骤3**

执行程序，输出结果：

```java
Hello World!
```

## 3.3 单例模式的几种实现方式

单例模式的实现有多种方式，如下所示：

### 1、懒汉式，线程不安全

**是否 Lazy 初始化：**是

**是否多线程安全：**否

**实现难度：**易

**描述：**这种方式是最基本的实现方式，这种实现最大的问题就是不支持多线程。因为没有加锁 synchronized，所以严格意义上它并不算单例模式。
这种方式 lazy loading 很明显，不要求线程安全，在多线程不能正常工作。

```java
public class Singleton {  
  private static Singleton instance;  
  private Singleton (){}  
  public static Singleton getInstance() {  
    if (instance == null) {  
      instance = new Singleton();  
    }  
    return instance;  
  }  
}
```

**接下来介绍的几种实现方式都支持多线程，但是在性能上有所差异。**

### 2、懒汉式，线程安全

**是否 Lazy 初始化：**是

**是否多线程安全：**是

**实现难度：**易

**描述：**这种方式具备很好的 lazy loading，能够在多线程中很好的工作，但是，效率很低，99% 情况下不需要同步。
**优点**：第一次调用才初始化，避免内存浪费。
**缺点**：必须加锁 synchronized 才能保证单例，但加锁会影响效率。
getInstance() 的性能对应用程序不是很关键（该方法使用不太频繁）。

```java
public class Singleton {  
  private static Singleton instance;  
  private Singleton (){}  
  public static synchronized Singleton getInstance() {  
    if (instance == null) {  
      instance = new Singleton();  
    }  
    return instance;  
  }  
}
```

### 3、饿汉式

**是否 Lazy 初始化：**否

**是否多线程安全：**是

**实现难度：**易

**描述：**这种方式比较常用，但容易产生垃圾对象。
**优点**：没有加锁，执行效率会提高。
**缺点**：类加载时就初始化，浪费内存。
它基于 classloader 机制避免了多线程的同步问题，不过，instance 在类装载时就实例化，虽然导致类装载的原因有很多种，在单例模式中大多数都是调用 getInstance 方法， 但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化 instance 显然没有达到 lazy loading 的效果。

```java
public class Singleton {  
  private static Singleton instance = new Singleton();  
  private Singleton (){}  
  public static Singleton getInstance() {  
    return instance;  
  }  
}
```

### 4、双检锁/双重校验锁（DCL，即 double-checked locking）

**JDK 版本：**JDK1.5 起

**是否 Lazy 初始化：**是

**是否多线程安全：**是

**实现难度：**较复杂

**描述：**这种方式采用双锁机制，安全且在多线程情况下能保持高性能。
getInstance() 的性能对应用程序很关键。

```java
public class Singleton {  
  private volatile static Singleton singleton;  
  private Singleton (){}  
  public static Singleton getSingleton() {  
    if (singleton == null) {  
      synchronized (Singleton.class) {  
        if (singleton == null) {  
          singleton = new Singleton();  
        }  
      }  
    }  
    return singleton;  
  }  
}
```

### 5、登记式/静态内部类

> [关于final对象回收的疑问](https://bbs.csdn.net/topics/320255560)
>
> [final对象的生命周期](https://bbs.csdn.net/topics/220029494?page=2)	<=	很有意思的文章。强烈推荐阅读

**是否 Lazy 初始化：**是

**是否多线程安全：**是

**实现难度：**一般

**描述：**这种方式能达到双检锁方式一样的功效，但实现更简单。对静态域使用延迟初始化，应使用这种方式而不是双检锁方式。<u>这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用</u>。
这种方式同样**利用了 classloader 机制来保证初始化 instance 时只有一个线程**，它跟第 3 种方式不同的是：第 3 种方式只要 Singleton 类被装载了，那么 instance 就会被实例化（没有达到 lazy loading 效果），而这种方式是 Singleton 类被装载了，instance 不一定被初始化。因为 SingletonHolder 类没有被主动使用，只有通过显式调用 getInstance 方法时，才会显式装载 SingletonHolder 类，从而实例化 instance。想象一下，如果实例化 instance 很消耗资源，所以想让它延迟加载，另外一方面，又不希望在 Singleton 类加载时就实例化，因为不能确保 Singleton 类还可能在其他的地方被主动使用从而被加载，那么这个时候实例化 instance 显然是不合适的。这个时候，这种方式相比第 3 种方式就显得很合理。

```java
public class Singleton {  
  private static class SingletonHolder {  
    private static final Singleton INSTANCE = new Singleton();  
  }  
  private Singleton (){}  
  public static final Singleton getInstance() {  
    return SingletonHolder.INSTANCE;  
  }  
}
```

### 6、* 枚举

> [为什么要用枚举实现单例模式（避免反射、序列化问题）](https://www.cnblogs.com/chiclee/p/9097772.html)	<=	推荐阅读
>
> [Java transient关键字使用小记](https://www.cnblogs.com/lanxuezaipiao/p/3369962.html)
>
> [为什么用枚举实现的单例模式可以防止反序列化？](https://leokongwq.github.io/2017/08/21/why-enum-singleton-are-serialization-safe.html)	<=	里面还有单例类如何防反射/反序列化攻击的解说
>
> + **反射**在java源码中会检查是否是Enum类型，是的话直接反射失败
>
> + Java的**序列化**机制针对枚举类型是特殊处理的。<u>简单来讲，在序列化枚举类型时，只会存储**枚举类的引用**和**枚举常量的名称**。随后的反序列化的过程中，这些信息被用来在运行时环境中查找存在的枚举类型对象</u>。
>
>   这样你就可以在同一个运行时环境中反序列化枚举常量，并且你会得到同一个实例对象。
>
>   然而，在不同的JVM中对枚举类型进行反序列化，可能会得到不同的`hashcode`。但是，对单例对象来说，拥有相同的`hashcode`并不是一个必要的条件。重点是该类永远不能有多余一个的实例(同一个JVM)，**<u>枚举类型的序列化机制保证只会查找已经存在的枚举类型实例，而不是创建新的实例</u>**。

**JDK 版本：**JDK1.5 起

**是否 Lazy 初始化：**否

**是否多线程安全：**是

**实现难度：**易

**描述：**这种实现方式还没有被广泛采用，但这是实现单例模式的最佳方法。它更简洁，自动**支持序列化机制，绝对防止多次实例化**。
这种方式是 Effective Java 作者 Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还自动支持序列化机制，**防止反序列化重新创建新的对象，绝对防止多次实例化**。不过，由于 JDK1.5 之后才加入 enum 特性，用这种方式写不免让人感觉生疏，在实际工作中，也很少用。
不能通过 reflection attack 来调用私有构造方法。

```java
public enum Singleton {  
  INSTANCE;  
  public void whateverMethod() {  
  }  
}
```

### * 经验之谈

一般情况下，不建议使用第 1 种和第 2 种懒汉方式，建议使用第 3 种饿汉方式。只有在要明确实现 lazy loading 效果时，才会使用第 5 种登记方式。<u>如果涉及到反序列化创建对象时，可以尝试使用第 6 种枚举方式</u>。如果有其他特殊的需求，可以考虑使用第 4 种双检锁方式。

## 3.4 * 评论区补充

> ps:
>
> + 序列化不需要调用构造函数
> + 反射调用无参构造函数

1. 懒汉式和饿汉式

   懒汉式与饿汉式的根本区别在与是否在类内方法外创建自己的对象。

   并且声明对象都需要私有化，构造方法都要私有化，这样外部才不能通过 new 对象的方式来访问。

   饿汉式的话是声明并创建对象(因为他饿)，懒汉式的话只是声明对象，在调用该类的 getinstance() 方法时才会进行 new 对象。

2. **反射机制破解单例模式（枚举除外）**

   ```java
   public class BreakSingleton{
     public static void main(String[] args) throw Exception{
       Class clazz = Class.forName("Singleton");
       Constructor c = clazz.getDeclaredConstructor(null);
   
       c.setAccessible(true);
   
       Singleton s1 = c.newInstance();
       Singleton s2 = c.newInstance();
       //通过反射，得到的两个不同对象
       System.out.println(s1);
       System.out.println(s2);
     }
   }
   ```

   避免以上楼漏洞的方法

   ```java
   class Singleton{
     private static final Singleton singleton = new Singleton(); 
     private Singleton() {
       //在构造器中加个逻辑判断,多次调用抛出异常
       if(instance!= null){
         throw new RuntimeException()
       }
     }
     public static Singleton getInstance(){
       return singleton;
     }
   }
   ```

3. **反序列化机制破解单例模式（枚举除外）**

   ```java
   public class BreakSingleton{
   
     public static void main(String[] args) throws Exception{
   
       //先根据单例模式创建对象(单例模式所以s1,s2是一样的)
       Singleton s1=Singleton.getInstance();
       Singleton s2=Singleton.getInstance();
   
       //将s1写入本地某个路径
       FileOutputStream fos=new FileOutputStream("本地某个路径下文件");
       ObjectOutputStream oos=new ObjectOutputStream(fos);
       oos.writeObject(s1);
       oos.close();
       fos.close();
   
       //从本地某个路径读取写入的对象
       ObjectInputStream ois=new ObjectInputStream(new FileInputStream("和上面的本地参数路径相同"));
       Singleton s3=(Singleton) ois.readObject();
       System.out.println(s1);
       System.out.println(s2);
       System.out.println(s3);//s3是一个新对象
     }
   
   }
   ```

   如何避免实现序列化单例模式的漏洞

   ```java
   class Singleton implements Serializable{
   
     private static final Singleton singleton = new Singleton(); 
   
     private Singleton() {
     }
     public static Singleton getInstance(){
       return singleton;
     }
     //反序列化定义该方法，则不需要创建新对象
     private Object readResolve() throws ObjectStreamException{
       return singleton;
     }
   }
   ```

4. 登记式单例模式是对一组单例模式进行的维护, 保证 map 中的对象是同一份 Spring 中使用的就是类似的模式

   ```java
   import java.util.Map;
   import java.util.concurrent.ConcurrentHashMap;
   
   public class RegisterSingleton {
     /** * 登记式单例模式, 保证map中的对象是同一份 */
     private static Map<String, Object> map;
   
     static {
       map = new ConcurrentHashMap<>();
       map.put(RegisterSingleton.class.getName(), new RegisterSingleton());
     }
   
     private RegisterSingleton() {
       System.out.println("this Constructor is called");
     }
   
     public static Object getInstance(String name) {
       if (name == null) {
         name = RegisterSingleton.class.getName();
       }
       if (map.get(name) == null) {
         try {
           map.put(name, Class.forName(name).newInstance());
         } catch (Exception e) {
           e.printStackTrace();
         }
       }
       return map.get(name);
     }
   }
   ```

> + [为什么用枚举实现的单例模式可以防止反序列化？](https://leokongwq.github.io/2017/08/21/why-enum-singleton-are-serialization-safe.html)
>
>   + 单例类防止反序列化
>
>     ```java
>     public class Singleton implements java.io.Serializable {
>       public static Singleton INSTANCE = new Singleton();
>       protected Singleton() {
>         // Exists only to thwart instantiation.
>       }
>       private Object readResolve() {
>         return INSTANCE;
>       }
>     }
>     ```
>
>   + 单例类如何防止反射？
>
>     ```java
>     public class Singleton {  
>       private static boolean flag = false;  
>       private Singleton(){  
>         synchronized(Singleton.class){  
>           if(flag == false){  
>             flag = !flag;  
>           } else {  
>             throw new RuntimeException("单例模式被侵犯！");  
>           }  
>         }  
>       }  
>       private  static class SingletonHolder {  
>         private static final Singleton INSTANCE = new Singleton();  
>       }  
>       public static Singleton getInstance(){  
>         return SingletonHolder.INSTANCE;  
>       }  
>     }
>     ```

# 4. 建造者模式

​	建造者模式（Builder Pattern）使用多个简单的对象一步一步构建成一个复杂的对象。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。

​	一个 Builder 类会一步一步构造最终的对象。该 Builder 类是独立于其他对象的。

## 4.1 介绍

**意图：**将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。

**主要解决：**主要解决在软件系统中，有时候面临着"一个复杂对象"的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。

**何时使用：**一些基本部件不会变，而其组合经常变化的时候。

**如何解决：**将变与不变分离开。

**关键代码：**建造者：创建和提供实例，导演：管理建造出来的实例的依赖关系。

**应用实例：** 1、去肯德基，汉堡、可乐、薯条、炸鸡翅等是不变的，而其组合是经常变化的，生成出所谓的"套餐"。 2、<u>JAVA 中的 StringBuilder</u>。

**优点：** <u>1、建造者独立，易扩展。 2、便于控制细节风险。</u>

**缺点：** 1、产品必须有共同点，范围有限制。 2、<u>如内部变化复杂，会有很多的建造类</u>。

**使用场景：** 1、需要生成的对象具有复杂的内部结构。 2、需要生成的对象内部属性本身相互依赖。

**注意事项：**<u>与工厂模式的区别是：建造者模式更加关注与零件装配的顺序</u>。

## 4.2 实现

​	我们假设一个快餐店的商业案例，其中，一个典型的套餐可以是一个汉堡（Burger）和一杯冷饮（Cold drink）。汉堡（Burger）可以是素食汉堡（Veg Burger）或鸡肉汉堡（Chicken Burger），它们是包在纸盒中。冷饮（Cold drink）可以是可口可乐（coke）或百事可乐（pepsi），它们是装在瓶子中。

​	我们将创建一个表示食物条目（比如汉堡和冷饮）的 *Item* 接口和实现 *Item* 接口的实体类，以及一个表示食物包装的 *Packing* 接口和实现 *Packing* 接口的实体类，汉堡是包在纸盒中，冷饮是装在瓶子中。

​	然后我们创建一个 *Meal* 类，带有 *Item* 的 *ArrayList* 和一个通过结合 *Item* 来创建不同类型的 *Meal* 对象的 *MealBuilder*。*BuilderPatternDemo* 类使用 *MealBuilder* 来创建一个 *Meal*。

![建造者模式的 UML 图](https://www.runoob.com/wp-content/uploads/2014/08/20210315-builder-pattern.svg)

**步骤 1**

创建一个表示食物条目和食物包装的接口。

```java
public interface Item {
  public String name();
  public Packing packing();
  public float price();    
}
```

```java
public interface Packing {
  public String pack();
}
```

**步骤 2**

创建实现 Packing 接口的实体类。

```java
public class Wrapper implements Packing {
  @Override
  public String pack() {
    return "Wrapper";
  }
}
```

```java
public class Bottle implements Packing {
  @Override
  public String pack() {
    return "Bottle";
  }
}
```

**步骤 3**

创建实现 Item 接口的抽象类，该类提供了默认的功能。

```java
public abstract class Burger implements Item {
  @Override
  public Packing packing() {
    return new Wrapper();
  }
  @Override
  public abstract float price();
}
```

```java
public abstract class ColdDrink implements Item {
  @Override
  public Packing packing() {
    return new Bottle();
  }
  @Override
  public abstract float price();
}
```

**步骤 4**

创建扩展了 Burger 和 ColdDrink 的实体类。

```java
public class VegBurger extends Burger {
  @Override
  public float price() {
    return 25.0f;
  }
  @Override
  public String name() {
    return "Veg Burger";
  }
}
```

```java
public class Coke extends ColdDrink {
  @Override
  public float price() {
    return 30.0f;
  }
  @Override
  public String name() {
    return "Coke";
  }
}
```

```java
public class Pepsi extends ColdDrink {
  @Override
  public float price() {
    return 35.0f;
  }
  @Override
  public String name() {
    return "Pepsi";
  }
}
```

**步骤 5**

创建一个 Meal 类，带有上面定义的 Item 对象。

```java
import java.util.ArrayList;
import java.util.List;

public class Meal {
  private List<Item> items = new ArrayList<Item>();    

  public void addItem(Item item){
    items.add(item);
  }

  public float getCost(){
    float cost = 0.0f;
    for (Item item : items) {
      cost += item.price();
    }        
    return cost;
  }

  public void showItems(){
    for (Item item : items) {
      System.out.print("Item : "+item.name());
      System.out.print(", Packing : "+item.packing().pack());
      System.out.println(", Price : "+item.price());
    }        
  }    
}
```

**步骤 6**

创建一个 MealBuilder 类，实际的 builder 类负责创建 Meal 对象。

```java
public class MealBuilder {

  public Meal prepareVegMeal (){
    Meal meal = new Meal();
    meal.addItem(new VegBurger());
    meal.addItem(new Coke());
    return meal;
  }   

  public Meal prepareNonVegMeal (){
    Meal meal = new Meal();
    meal.addItem(new ChickenBurger());
    meal.addItem(new Pepsi());
    return meal;
  }
}
```

**步骤 7**

BuiderPatternDemo 使用 MealBuilder 来演示建造者模式（Builder Pattern）。

```java
public class BuilderPatternDemo {
  public static void main(String[] args) {
    MealBuilder mealBuilder = new MealBuilder();

    Meal vegMeal = mealBuilder.prepareVegMeal();
    System.out.println("Veg Meal");
    vegMeal.showItems();
    System.out.println("Total Cost: " +vegMeal.getCost());

    Meal nonVegMeal = mealBuilder.prepareNonVegMeal();
    System.out.println("\n\nNon-Veg Meal");
    nonVegMeal.showItems();
    System.out.println("Total Cost: " +nonVegMeal.getCost());
  }
}
```

**步骤 8**

执行程序，输出结果：

```shell
Veg Meal
Item : Veg Burger, Packing : Wrapper, Price : 25.0
Item : Coke, Packing : Bottle, Price : 30.0
Total Cost: 55.0


Non-Veg Meal
Item : Chicken Burger, Packing : Wrapper, Price : 50.5
Item : Pepsi, Packing : Bottle, Price : 35.0
Total Cost: 85.5
```

## 4.3 * 相关文章

> - [设计模式之建造者(Builder)模式](https://www.runoob.com/w3cnote/builder-pattern.html)
> - [设计模式：Builder模式](https://www.runoob.com/w3cnote/builder-pattern-2.html)

![img](https://images2018.cnblogs.com/blog/1157683/201806/1157683-20180626180216963-8235726.png)

1. 前言

   今天我们讨论一下 Builder 建造者模式，这个 Builder，其实和模板模式非常的像，但是也有区别，那就是在模板模式中父类对子类中的实现进行操作，在父类之中进行一件事情的处理，但是在 Builder 模式之中，父类和子类都不用关心怎么处理，而是用另一个类来完成对这些方法的有机组合，这个类的职责就是**监工**，规定了到底要怎么样有机的组合这些方法。在监工类（Director）中，将父类组合进去，然后调用父类的操作来抽象的实现一件事情，这就是面向接口（抽象）变成的妙处了，当然这个 Builder 可以使接口也可以是抽象类，在这里我们使用抽象类。

2. 实现代码

   + Builder 抽象类：

     ```java
     public abstract class Builder {
       public abstract void makeString(String str);
       public abstract void makeTitle(String title);
       public abstract void makeItems(String[] items);
       public abstract void close();
     }
     ```

   + HtmlBuilder 实现类：

     ```java
     import java.io.FileWriter;
     import java.io.IOException;
     import java.io.PrintWriter;
     
     public class HtmlBuilder extends Builder {
     
       private String filename;
       private PrintWriter pw;
       public void makeTitle(String title) {
         filename="D:\\"+title+".html";
         try {
           pw=new PrintWriter(new FileWriter(filename));
         } catch (IOException e) {
           e.printStackTrace();
         }
         pw.println("<html><head><title>"+title+"</title></head><body>");
         pw.println("<h1>"+title+"</h1>");
       }
     
       public void makeString(String str) {
         pw.println("<p>"+str+"</p>");
       }
     
       public void makeItems(String[] items) {
         pw.println("<ul>");
         for(int i=0;i<items.length;i++){
           pw.println("<li>"+items[i]+"</li>");
         }
         pw.println("</ul>");
       }
     
       public void close() {
         pw.println("</body></html>");
         pw.close();
       }
       public String getResult(){
         return filename;
       }
     }
     ```

   + TextBuilder 实现类：

     ```java
     public class TextBuilder extends Builder {
     
       StringBuffer sb=new StringBuffer();
     
       public void makeTitle(String title) {
         sb.append("=====================");
         sb.append("["+title+"]"+"\n");
       }
     
       public void makeString(String str) {
         sb.append("@"+str+"\n");
       }
     
       public void makeItems(String[] items) {
         for(int i=0;i<items.length;i++){
           sb.append("   ."+items[i]+"\n");
         }
       }
     
       public void close() {
         sb.append("=====================");
       }
     
       public String getResult(){
         return sb.toString();
       }
     
     }
     ```

   + Director 监工类：

     ```java
     public class Director {
       private Builder builder;
       public Director(Builder builder){
         this.builder=builder;
       }
       public void construct(){
         String [] items1=new String[]{"奏国歌","升国旗"};
         String [] items2=new String[]{"观众鼓掌","有序撤离"};
         builder.makeTitle("今日头条");
         builder.makeString("毕业典礼");
         builder.makeItems(items1);
         builder.makeString("典礼结束");
         builder.makeItems(items2);
         builder.close();
       }
     }
     ```

   + Main 类：

     ```java
     public class Main {
     
       public static void main(String[] args) {
         //String choice="plain";
         String choice="html";
         if(choice=="plain"){
           TextBuilder t=new TextBuilder();
           Director d=new Director(t);
           d.construct();
           System.out.println(t.getResult());
         }else if(choice=="html"){
           HtmlBuilder html=new HtmlBuilder();
           Director d=new Director(html);
           d.construct();
           System.out.println(html.getResult());
         }else{
           usage();
         }
     
       }
     
       private static void usage() {
         System.out.println("使用 plain，编辑文本文件");
         System.out.println("使用 html，编辑网页文件");
       }
     
     }
     ```

3. 运行结果

   ![img](https://www.runoob.com/wp-content/uploads/2019/08/1157683-20180626181209288-2015291769.png)

4. 总结

   <small> 关于Builder模式，我们一定要分清和模板方法的区别，其实就是到底谁承担了“监工”的责任，在模板方法中父类承担了这个责任，而在Builder中，有另外一个专门的类来完成这样的操作，这样做的好处是类的隔离，比如说在Main中，用户根本就不知道有Builder这个抽象类，同样的Director这个监工的根本就不管到底是哪一个实现类，因为任何一个都会被转换为父类，然后进行处理（面向抽象编程的思想），因此很好的实现了隔离，同样的这样设计的好处是复用了，隔离的越好复用起来就越方便，我们完全可以思考，假如还有另外一个监工，使用了不同的construct方法来组装这些复杂的事件，那么对于原来的代码我们不用做任何的修改，只用增加这样的一个监工类，然后定义好相应的方法就好了，之后再Main中使用，这样的一种思想使得我们不用修改源代码，复用（Builder以及其子类）就很方便了，同样的，如果想增加一个新的Builder的子类，只要照着父类的方法进行填充，再加上自己的方法就好了，完全不用修改代码，这也是一种复用，因此这种复用（组件）的思想在设计模式中随处可见，本质就是高内聚低耦合，组件开发，尽量不修改原来的代码，有可扩展性，理解了这一点，我们再看看模板方法，责任全放在了父类里，如果责任需要改变，则必须要修改父类中的责任方法了，这样就修改了原来的代码，不利于复用，这也是两者的本质区别。</small>

## 4.4 评论区补充

1. 建造者模式三大角色：建造者、具体的建造者、监工。

   建造者模式，又称生成器模式：将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。

   +  **建造者角色**：定义生成实例所需要的所有方法；
   +  **具体的建造者角色**：实现生成实例所需要的所有方法，并且定义获取最终生成实例的方法；
   +  **监工角色**：<u>定义使用建造者角色中的方法来生成实例的方法</u>；

   > **注意**：定义中“**将一个复杂的构建过程与其表示相分离**”，表示并不是由建造者负责一切，而是<u>由监工负责控制（定义）一个复杂的构建过程，由各个不同的建造者分别负责实现构建过程中所用到的所有构建步骤</u>。不然，就无法做到“使得同样的构建过程可以创建不同的表示”这一目标。

   建造者角色：

   ```java
   public abstract class Builder {
     public abstract void buildPart1();
     public abstract void buildPart2();
     public abstract void buildPart3();
   }
   ```

   监工角色：

   ```java
   public class Director {    // 将一个复杂的构建过程与其表示相分离
     private Builder builder;    // 针对接口编程，而不是针对实现编程
     public Director(Builder builder) {
       this.builder = builder;
     }
     public void setBuilder(Builder builder) {
       this.builder = builder;
     }
   
     public void construct() {   // 控制（定义）一个复杂的构建过程
       builder.buildPart1();
       for (int i = 0; i < 5; i++) {   // 提示：如果想在运行过程中替换构建算法，可以考虑结合策略模式。
         builder.buildPart2();
       }
       builder.buildPart3();
     }
   }
   ```

   具体的建造者角色：

   ```java
   /**
    * 此处实现了建造纯文本文档的具体建造者。
    * 可以考虑再实现一个建造HTML文档、XML文档，或者其它什么文档的具体建造者。
    * 这样，就可以使得同样的构建过程可以创建不同的表示
    */
   public class ConcreteBuilder1 extends Builder {
     private StringBuffer buffer = new StringBuffer();//假设 buffer.toString() 就是最终生成的产品
   
     @Override
     public void buildPart1() {//实现构建最终实例需要的所有方法
       buffer.append("Builder1 : Part1\n");
     }
   
     @Override
     public void buildPart2() {
       buffer.append("Builder1 : Part2\n");
     }
   
     @Override
     public void buildPart3() {
       buffer.append("Builder1 : Part3\n");
     }
   
     public String getResult() {//定义获取最终生成实例的方法
       return buffer.toString();
     }
   }
   ```

   客户角色：

   ```java
   public class Client {
     public void testBuilderPattern() {
       ConcreteBuilder1 b1 = new ConcreteBuilder1();//建造者
       Director director = new Director(b1);//监工
       director.construct();//建造实例(监工负责监督，建造者实际建造)
       String result = b1.getResult();//获取最终生成结果
       System.out.printf("the result is :%n%s", result);
     }
   }
   ```

# 5. 原型模式

​	原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。

​	这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。例如，一个对象需要在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。

## 5.1 介绍

**意图：**用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。

**主要解决：**在运行期建立和删除原型。

**何时使用：** 1、当一个系统应该独立于它的产品创建，构成和表示时。 2、当要实例化的类是在运行时刻指定时，例如，通过动态装载。 3、为了避免创建一个与产品类层次平行的工厂类层次时。 4、<u>当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些</u>。

**如何解决：**利用已有的一个原型对象，快速地生成和原型对象一样的实例。

**关键代码：** 1、实现克隆操作，在 JAVA 继承 Cloneable，重写 clone()，在 .NET 中可以使用 Object 类的 MemberwiseClone() 方法来实现对象的浅拷贝或通过序列化的方式来实现深拷贝。 2、原型模式同样用于隔离类对象的使用者和具体类型（易变类）之间的耦合关系，它同样要求这些"易变类"拥有稳定的接口。

**应用实例：** 1、细胞分裂。 2、JAVA 中的 Object clone() 方法。

**优点：** 1、性能提高。 2、逃避构造函数的约束。

**缺点：** 1、配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候。 2、<u>必须实现 Cloneable 接口</u>。

**使用场景：** 1、资源优化场景。 2、类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等。 3、性能和安全要求的场景。 4、通过 new 产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。 5、一个对象多个修改者的场景。 6、一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用。 7、在实际项目中，原型模式很少单独出现，一般是和工厂方法模式一起出现，通过 clone 的方法创建一个对象，然后由工厂方法提供给调用者。原型模式已经与 Java 融为浑然一体，大家可以随手拿来使用。

**注意事项：**<u>与通过对一个类进行实例化来构造新对象不同的是，原型模式是通过拷贝一个现有对象生成新对象的。浅拷贝实现 Cloneable，重写，深拷贝是通过实现 Serializable 读取二进制流</u>。

## 5.2 实现

我们将创建一个抽象类 *Shape* 和扩展了 *Shape* 类的实体类。下一步是定义类 *ShapeCache*，该类把 shape 对象存储在一个 *Hashtable* 中，并在请求的时候返回它们的克隆。

*PrototypePatternDemo* 类使用 *ShapeCache* 类来获取 *Shape* 对象。

![原型模式的 UML 图](https://www.runoob.com/wp-content/uploads/2014/08/20201202-prototype-pattern.png)

**步骤 1**

创建一个实现了 *Cloneable* 接口的抽象类。

```java
public abstract class Shape implements Cloneable {

  private String id;
  protected String type;

  abstract void draw();

  public String getType(){
    return type;
  }

  public String getId() {
    return id;
  }

  public void setId(String id) {
    this.id = id;
  }

  public Object clone() {
    Object clone = null;
    try {
      clone = super.clone();
    } catch (CloneNotSupportedException e) {
      e.printStackTrace();
    }
    return clone;
  }
}
```

**步骤 2**

创建扩展了上面抽象类的实体类。

```java
public class Rectangle extends Shape {

  public Rectangle(){
    type = "Rectangle";
  }

  @Override
  public void draw() {
    System.out.println("Inside Rectangle::draw() method.");
  }
}
```

```java
public class Square extends Shape {

  public Square(){
    type = "Square";
  }

  @Override
  public void draw() {
    System.out.println("Inside Square::draw() method.");
  }
}
```

```java
public class Circle extends Shape {

  public Circle(){
    type = "Circle";
  }

  @Override
  public void draw() {
    System.out.println("Inside Circle::draw() method.");
  }
}
```

**步骤 3**

创建一个类，从数据库获取实体类，并把它们存储在一个 *Hashtable* 中。

```java
import java.util.Hashtable;

public class ShapeCache {

  private static Hashtable<String, Shape> shapeMap 
    = new Hashtable<String, Shape>();

  public static Shape getShape(String shapeId) {
    Shape cachedShape = shapeMap.get(shapeId);
    return (Shape) cachedShape.clone();
  }

  // 对每种形状都运行数据库查询，并创建该形状
  // shapeMap.put(shapeKey, shape);
  // 例如，我们要添加三种形状
  public static void loadCache() {
    Circle circle = new Circle();
    circle.setId("1");
    shapeMap.put(circle.getId(),circle);

    Square square = new Square();
    square.setId("2");
    shapeMap.put(square.getId(),square);

    Rectangle rectangle = new Rectangle();
    rectangle.setId("3");
    shapeMap.put(rectangle.getId(),rectangle);
  }
}
```

**步骤 4**

*PrototypePatternDemo* 使用 *ShapeCache* 类来获取存储在 *Hashtable* 中的形状的克隆。

```java
public class PrototypePatternDemo {
  public static void main(String[] args) {
    ShapeCache.loadCache();

    Shape clonedShape = (Shape) ShapeCache.getShape("1");
    System.out.println("Shape : " + clonedShape.getType());        

    Shape clonedShape2 = (Shape) ShapeCache.getShape("2");
    System.out.println("Shape : " + clonedShape2.getType());        

    Shape clonedShape3 = (Shape) ShapeCache.getShape("3");
    System.out.println("Shape : " + clonedShape3.getType());        
  }
}
```

**步骤 5**

执行程序，输出结果：

```shell
Shape : Circle
Shape : Square
Shape : Rectangle
```

## 5.3 评论区补充

1. 原型模式的三个角色

   原型模式中有三个登场角色：

   **原型角色**：定义用于复制现有实例来生成新实例的方法；

   ```java
   // 以贴主示例代码为例  
   implements Cloneable   // 1.（抽象类或者接口）实现 java.lang.Cloneable 接口
   public Shape clone();  // 2.定义复制现有实例来生成新实例的方法
   ```

   **具体原型角色**：实现用于复制现有实例来生成新实例的方法

   ```java
   public Shape clone() {// 2.实现复制现有实例来生成新实例的方法（也可以由超类完成）
     Shape clone = null;
     try {
       clone = (Shape) clone();
     } catch (CloneNotSupportedException e) {
       e.printStackTrace();
     }
     return clone;
   }
   ```

   **使用者角色**：维护一个注册表，并提供一个找出正确实例原型的方法。最后，提供一个获取新实例的方法，用来委托复制实例的方法生成新实例。

   ```java
   private static Hashtable<String, Shape> shapeMap = new Hashtable<String, Shape>();//维护一个注册表
   public static void loadCache() {
     Circle circle = new Circle();
     circle.setId("1");
     shapeMap.put(circle.getId(),circle);
   
     Square square = new Square();
     square.setId("2");
     shapeMap.put(square.getId(),square);
   
     Rectangle rectangle = new Rectangle();
     rectangle.setId("3");
     shapeMap.put(rectangle.getId(),rectangle);
   }
   public static Shape getShape(String shapeId) {//提供一个获取新实例的方法
     Shape cachedShape = shapeMap.get(shapeId);//提供一个找出正确实例原型的方法
     return (Shape) cachedShape.clone();//委托复制实例的方法生成新实例。
   }
   ```

# 6. 适配器模式

​	适配器模式（Adapter Pattern）是作为<u>两个不兼容的接口之间的桥梁</u>。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。

​	这种模式涉及到一个单一的类，该类负责加入独立的或不兼容的接口功能。举个真实的例子，<u>读卡器是作为内存卡和笔记本之间的适配器</u>。您将内存卡插入读卡器，再将读卡器插入笔记本，这样就可以通过笔记本来读取内存卡。

​	我们通过下面的实例来演示适配器模式的使用。其中，音频播放器设备只能播放 mp3 文件，通过使用一个更高级的音频播放器来播放 vlc 和 mp4 文件。

## 6.1 介绍

**意图：**将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。

**主要解决：**主要解决在软件系统中，常常要将一些"现存的对象"放到新的环境中，而新环境要求的接口是现对象不能满足的。

**何时使用：** 1、系统需要使用现有的类，而此类的接口不符合系统的需要。 2、想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作，这些源类不一定有一致的接口。 3、通过接口转换，将一个类插入另一个类系中。（比如老虎和飞禽，现在多了一个飞虎，在不增加实体的需求下，增加一个适配器，在里面包容一个虎对象，实现飞的接口。）

**如何解决：**继承或<u>依赖（推荐）</u>。

**关键代码：**适配器继承或依赖已有的对象，实现想要的目标接口。

**应用实例：** 1、美国电器 110V，中国 220V，就要有一个适配器将 110V 转化为 220V。 2、<u>JAVA JDK 1.1 提供了 Enumeration 接口，而在 1.2 中提供了 Iterator 接口，想要使用 1.2 的 JDK，则要将以前系统的 Enumeration 接口转化为 Iterator 接口，这时就需要适配器模式</u>。 3、在 LINUX 上运行 WINDOWS 程序。 4、JAVA 中的 jdbc。

**优点：** 1、可以让任何两个没有关联的类一起运行。 2、提高了类的复用。 3、增加了类的透明度。 4、灵活性好。

**缺点：** 1、过多地使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。 2.由于 JAVA 至多继承一个类，所以至多只能适配一个适配者类，而且目标类必须是抽象类。

**使用场景：**<u>有动机地修改一个正常运行的系统的接口，这时应该考虑使用适配器模式</u>。

**注意事项：**<u>适配器不是在详细设计时添加的，而是解决正在服役的项目的问题</u>。

## 6.2 实现

​	我们有一个 *MediaPlayer* 接口和一个实现了 *MediaPlayer* 接口的实体类 *AudioPlayer*。默认情况下，*AudioPlayer* 可以播放 mp3 格式的音频文件。

​	我们还有另一个接口 *AdvancedMediaPlayer* 和实现了 *AdvancedMediaPlayer* 接口的实体类。该类可以播放 vlc 和 mp4 格式的文件。

​	我们想要让 *AudioPlayer* 播放其他格式的音频文件。为了实现这个功能，我们需要创建一个实现了 *MediaPlayer* 接口的适配器类 *MediaAdapter*，并使用 *AdvancedMediaPlayer* 对象来播放所需的格式。

​	*AudioPlayer* 使用适配器类 *MediaAdapter* 传递所需的音频类型，不需要知道能播放所需格式音频的实际类。*AdapterPatternDemo* 类使用 *AudioPlayer* 类来播放各种格式。

![适配器模式的 UML 图](https://www.runoob.com/wp-content/uploads/2014/08/20210223-adapter.png)

**步骤 1**

为媒体播放器和更高级的媒体播放器创建接口。

```java
public interface MediaPlayer {
  public void play(String audioType, String fileName);
}
```

```java
public interface AdvancedMediaPlayer { 
  public void playVlc(String fileName);
  public void playMp4(String fileName);
}
```

**步骤 2**

创建实现了 *AdvancedMediaPlayer* 接口的实体类。

```java
public class VlcPlayer implements AdvancedMediaPlayer{
  @Override
  public void playVlc(String fileName) {
    System.out.println("Playing vlc file. Name: "+ fileName);      
  }

  @Override
  public void playMp4(String fileName) {
    //什么也不做
  }
}
```

```java
public class Mp4Player implements AdvancedMediaPlayer{

  @Override
  public void playVlc(String fileName) {
    //什么也不做
  }

  @Override
  public void playMp4(String fileName) {
    System.out.println("Playing mp4 file. Name: "+ fileName);      
  }
}
```

**步骤 3**

创建实现了 *MediaPlayer* 接口的适配器类。

```java
public class MediaAdapter implements MediaPlayer {

  AdvancedMediaPlayer advancedMusicPlayer;

  public MediaAdapter(String audioType){
    if(audioType.equalsIgnoreCase("vlc") ){
      advancedMusicPlayer = new VlcPlayer();       
    } else if (audioType.equalsIgnoreCase("mp4")){
      advancedMusicPlayer = new Mp4Player();
    }  
  }

  @Override
  public void play(String audioType, String fileName) {
    if(audioType.equalsIgnoreCase("vlc")){
      advancedMusicPlayer.playVlc(fileName);
    }else if(audioType.equalsIgnoreCase("mp4")){
      advancedMusicPlayer.playMp4(fileName);
    }
  }
}
```

**步骤 4**

创建实现了 *MediaPlayer* 接口的实体类。

```java
public class AudioPlayer implements MediaPlayer {
  MediaAdapter mediaAdapter; 

  @Override
  public void play(String audioType, String fileName) {    

    //播放 mp3 音乐文件的内置支持
    if(audioType.equalsIgnoreCase("mp3")){
      System.out.println("Playing mp3 file. Name: "+ fileName);         
    } 
    //mediaAdapter 提供了播放其他文件格式的支持
    else if(audioType.equalsIgnoreCase("vlc") 
            || audioType.equalsIgnoreCase("mp4")){
      mediaAdapter = new MediaAdapter(audioType);
      mediaAdapter.play(audioType, fileName);
    }
    else{
      System.out.println("Invalid media. "+
                         audioType + " format not supported");
    }
  }   
}
```

**步骤 5**

使用 AudioPlayer 来播放不同类型的音频格式。

```java
public class AdapterPatternDemo {
  public static void main(String[] args) {
    AudioPlayer audioPlayer = new AudioPlayer();

    audioPlayer.play("mp3", "beyond the horizon.mp3");
    audioPlayer.play("mp4", "alone.mp4");
    audioPlayer.play("vlc", "far far away.vlc");
    audioPlayer.play("avi", "mind me.avi");
  }
}
```

**步骤 6**

执行程序，输出结果：

```shell
Playing mp3 file. Name: beyond the horizon.mp3
Playing mp4 file. Name: alone.mp4
Playing vlc file. Name: far far away.vlc
Invalid media. avi format not supported
```

## 6.3 * 评论区补充

1. 分享一个例子：笔记本通过读卡去读取TF卡；

   + **先模拟计算机读取SD卡**

     1. 先创建一个SD卡的接口：

        ```java
        public interface SDCard {
          //读取SD卡方法
          String readSD();
          //写入SD卡功能
          int writeSD(String msg);
        }
        ```

     2. 创建SD卡接口的实现类，模拟SD卡的功能：

        ```java
        public class SDCardImpl implements SDCard {
          @Override    
          public String readSD() {
            String msg = "sdcard read a msg :hello word SD";
            return msg;  
          }
          @Override  
          public int writeSD(String msg) {      
            System.out.println("sd card write msg : " + msg);    
            return 1;   
          }
        }
        ```

     3. 创建计算机接口，计算机提供读取SD卡方法：

        ```java
        public interface Computer {    
          String readSD(SDCard sdCard);
        }
        ```

     4. 创建一个计算机实例，实现计算机接口，并实现其读取SD卡方法：

        ```java
        public class ThinkpadComputer implements Computer {
          @Override    
          public String readSD(SDCard sdCard) {        
            if(sdCard == null)throw new NullPointerException("sd card null");        
            return sdCard.readSD();    
          }
        }
        ```

     5. 这时候就可以模拟计算机读取SD卡功能：

        ```java
        public class ComputerReadDemo {    
          public static void main(String[] args) {        
            Computer computer = new ThinkpadComputer();        
            SDCard sdCard = new SDCardImpl();       
            System.out.println(computer.readSD(sdCard));    
          }
        }
        ```

   + **接下来在不改变计算机读取SD卡接口的情况下，通过适配器模式读取TF卡：**

     1. 创建TF卡接口：

        ```java
        public interface TFCard {    
          String readTF();    
          int writeTF(String msg);
        }
        ```

     2. 创建TF卡实例：

        ```java
        public class TFCardImpl implements TFCard {    
          @Override    
          public String readTF() {        
            String msg ="tf card reade msg : hello word tf card";        
            return msg;    
          }    
          @Override    
          public int writeTF(String msg) {        
            System.out.println("tf card write a msg : " + msg);        
            return 1;    
          }
        }
        ```

     3. 创建SD适配TF （也可以说是SD兼容TF，相当于读卡器）：

        实现SDCard接口，并将要适配的对象作为适配器的属性引入。

        ```java
        public class SDAdapterTF implements SDCard {    
          private TFCard tfCard;    
          public SDAdapterTF(TFCard tfCard) {        
            this.tfCard = tfCard;    
          }    
          @Override    
          public String readSD() {        
            System.out.println("adapter read tf card ");        
            return tfCard.readTF();    
          }    
          @Override    
          public int writeSD(String msg) {        
            System.out.println("adapter write tf card");        
            return tfCard.writeTF(msg);    
          }
        }
        ```

     4. 通过上面的例子测试计算机通过SD读卡器读取TF卡：

        ```java
        public class ComputerReadDemo {    
          public static void main(String[] args) {        
            Computer computer = new ThinkpadComputer();        
            SDCard sdCard = new SDCardImpl();        
            System.out.println(computer.readSD(sdCard));        
            System.out.println("====================================");        
            TFCard tfCard = new TFCardImpl();        
            SDCard tfCardAdapterSD = new SDAdapterTF(tfCard);        
            System.out.println(computer.readSD(tfCardAdapterSD));    
          }
        }
        ```

     5. 输出：

        ```shell
        sdcard read a msg :hello word SD
        ====================================
        adapter read tf card 
        tf card reade msg : hello word tf card
        ```

     ​	在这种模式下，计算机并不需要知道具体是什么卡，只需要负责操作接口即可，具体操作的什么类，由适配器决定。

# 7. 桥接模式

​	桥接（Bridge）是用于**把抽象化与实现化解耦**，使得二者可以独立变化。这种类型的设计模式属于结构型模式，它通过提供抽象化和实现化之间的桥接结构，来实现二者的解耦。

​	这种模式涉及到一个作为桥接的接口，使得实体类的功能独立于接口实现类。这两种类型的类可被结构化改变而互不影响。

​	我们通过下面的实例来演示桥接模式（Bridge Pattern）的用法。其中，可以使用相同的抽象类方法但是不同的桥接实现类，来画出不同颜色的圆。

## 7.1 介绍

**意图：**将抽象部分与实现部分分离，使它们都可以独立的变化。

**主要解决：**在有多种可能会变化的情况下，用继承会造成类爆炸问题，扩展起来不灵活。

**何时使用：**<u>实现系统可能有多个角度分类，每一种角度都可能变化</u>。

**如何解决：**把这种多角度分类分离出来，让它们独立变化，减少它们之间耦合。

**关键代码：**抽象类依赖实现类。

**应用实例：** 1、猪八戒从天蓬元帅转世投胎到猪，转世投胎的机制将尘世划分为两个等级，即：灵魂和肉体，前者相当于抽象化，后者相当于实现化。生灵通过功能的委派，调用肉体对象的功能，使得生灵可以动态地选择。 2、墙上的开关，可以看到的开关是抽象的，不用管里面具体怎么实现的。

**优点：** 1、抽象和实现的分离。 2、优秀的扩展能力。 3、实现细节对客户透明。

**缺点：**桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程。

**使用场景：** 1、如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。 2、对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。 3、一个类存在两个独立变化的维度，且这两个维度都需要进行扩展。

**注意事项：**<u>对于两个独立变化的维度，使用桥接模式再适合不过了</u>。

## 7.2 实现

​	我们有一个作为桥接实现的 *DrawAPI* 接口和实现了 *DrawAPI* 接口的实体类 *RedCircle*、*GreenCircle*。*Shape* 是一个抽象类，将使用 *DrawAPI* 的对象。*BridgePatternDemo* 类使用 *Shape* 类来画出不同颜色的圆。

![桥接模式的 UML 图](https://www.runoob.com/wp-content/uploads/2014/08/20201015-bridge.svg)

**步骤 1**

创建桥接实现接口。

```java
public interface DrawAPI {
  public void drawCircle(int radius, int x, int y);
}
```

**步骤 2**

创建实现了 *DrawAPI* 接口的实体桥接实现类。

```java
public class RedCircle implements DrawAPI {
  @Override
  public void drawCircle(int radius, int x, int y) {
    System.out.println("Drawing Circle[ color: red, radius: "
                       + radius +", x: " +x+", "+ y +"]");
  }
}
```

```java
public class GreenCircle implements DrawAPI {
  @Override
  public void drawCircle(int radius, int x, int y) {
    System.out.println("Drawing Circle[ color: green, radius: "
                       + radius +", x: " +x+", "+ y +"]");
  }
}
```

**步骤 3**

使用 *DrawAPI* 接口创建抽象类 *Shape*。

```java
public abstract class Shape {
  protected DrawAPI drawAPI;
  protected Shape(DrawAPI drawAPI){
    this.drawAPI = drawAPI;
  }
  public abstract void draw();  
}
```

**步骤 4**

创建实现了 *Shape* 抽象类的实体类。

```java
public class Circle extends Shape {
  private int x, y, radius;

  public Circle(int x, int y, int radius, DrawAPI drawAPI) {
    super(drawAPI);
    this.x = x;  
    this.y = y;  
    this.radius = radius;
  }

  public void draw() {
    drawAPI.drawCircle(radius,x,y);
  }
}
```

**步骤 5**

使用 *Shape* 和 *DrawAPI* 类画出不同颜色的圆。

```java
public class BridgePatternDemo {
  public static void main(String[] args) {
    Shape redCircle = new Circle(100,100, 10, new RedCircle());
    Shape greenCircle = new Circle(100,100, 10, new GreenCircle());

    redCircle.draw();
    greenCircle.draw();
  }
}
```

**步骤 6**

执行程序，输出结果：

```
Drawing Circle[ color: red, radius: 10, x: 100, 100]
Drawing Circle[  color: green, radius: 10, x: 100, 100]
```

## 7.3 相关文章

> + [设计模式读书笔记-----桥接模式 ](https://www.cnblogs.com/chenssy/p/3317866.html) <= 下面只截取了部分内容

​	开始学java的时候老师讲到继承的时候，总是喜欢用一个例子来讲解，那就是画图，这里有一个画笔，可以画正方形、长方形、圆形（这个大家都知道怎么做吧，我就不解释了）。但是现在我们需要给这些形状进行上色，这里有三种颜色：白色、灰色、黑色。这里我们可以画出3*3=9中图形：白色正方形、白色长方形、白色圆形。。。。。。到这里了我们几乎到知道了这里存在两种解决方案：

+ 方案一：为每种形状都提供各种颜色的版本。

+ 方案二：根据实际需要对颜色和形状进行组合。

​	我们我们采用方案一来实现的话，我们是不是也可以这样来理解呢？为每种颜色都提供各种形状的版本呢？这个是完全的可以的。如下：

[![1111](https://images0.cnblogs.com/blog/381060/201309/12212904-5e7bdaf5860647ea85bd1259c38d9da9.png)](https://images0.cnblogs.com/blog/381060/201309/12212904-68f2e220b140481ba36b304f0b6f129b.png)

 

​	对于中两个图形，我们都会很清楚这样一个问题：加入我们添加椭圆，我们是不是又要增加三种颜色呢？假如我们在增加一个绿色，我们就要增加其四种形状了，继续加。继续加……每次增加都会增加若干个类(如果增加颜色则会增加形状个数个类，若增加形状则会增加颜色个数个类)，这样的情况我想每个程序员都不会想要吧！那么我们看方案二。

​	方案二所提供的就是解决方法是：提供两个父类一个是颜色、一个形状，颜色父类和形状父类两个类都包含了相应的子类，然后根据需要对颜色和形状进行组合。

[![33333](https://images0.cnblogs.com/blog/381060/201309/12212905-282280c2326b4864acb1dc87dd3c3d84.jpg)](https://images0.cnblogs.com/blog/381060/201309/12212905-60051681d812432a947e145508b66161.jpg)

 

​	对于有几个变化的维度，我们一般采用方案二来实现，这样除了减少系统中的类个数，也利于系统扩展。对于方案二的应用我们称之为桥接模式。

[![4444](https://images0.cnblogs.com/blog/381060/201309/12212906-694e391dae0e4553982b1a80222f1b72.png)](https://images0.cnblogs.com/blog/381060/201309/12212905-3f7da9d436f6426d8d4d166d2b427670.png)

## 7.4 * 评论区补充

1. 桥接模式：Bridge Pattern

   将抽象和实现放在两个不同的类层次中，使它们可以独立地变化。——《Head First 设计模式》

   **将类的功能层次结构和实现层次结构相分离**，**使二者能够独立地变化**，**并在两者之间搭建桥梁，实现桥接**。—— 《图解设计模式》

   类的功能层次结构：父类具有基本功能，在子类中增加新的功能；

   类的实现层次结构：父类通过声明抽象方法来定义接口，子类通过实现具体方法来实现接口；

   桥接模式中有四个角色：

   **抽象化角色**：使用实现者角色提供的接口来定义基本功能接口。

   持有实现者角色，并在功能接口中委托给它，起到搭建桥梁的作用；

   注意，抽象化角色并不是指它就是一个抽象类，而是指抽象了实现。

   **改善后的抽象化角色**：作为抽象化角色的子类，增加新的功能，也就是增加新的接口（方法）；与其构成类的功能层次结构；

   **实现者角色**：提供了用于抽象化角色的接口；它是一个抽象类或者接口。

   **具体的实现者角色**：作为实现者角色的子类，通过实现具体方法来实现接口；与其构成类的实现层次结构。

   **如果抽象和实现两者做不到独立地变化，就不算桥接模式**。

2. 示例中的桥梁

   桥接模式中，具体的实现类放在作为“桥梁”的接口中实现，而“桥梁”接口中只有实现功能的抽象方法；具体实现类是继承“桥梁”，而不直接继承实现类的抽象类，抽象类与具体的实现类在结构上是相互独立的，两者的相互变化并不会影响到彼此，只要“桥梁”没变，两者的变化并不会影响到彼此。

   <u>就以上教程的实例程序来说，具体的实现是RedCircle、GreenCircle，它们的抽象类为Shape，按一般逻辑来说，我们是直接继承Shape来创建不同的具体对象，但桥接模式中是通过“桥梁”DrawAPI建立抽象与具体实现之间的联系，调用DrawAPI中的方法来具体实现</u>。

# 8. 过滤器模式

​	过滤器模式（Filter Pattern）或标准模式（Criteria Pattern）是一种设计模式，这种模式允许开发人员使用不同的标准来过滤一组对象，通过逻辑运算以解耦的方式把它们连接起来。这种类型的设计模式属于结构型模式，它结合多个标准来获得单一标准。

## 8.1 实现

​	我们将创建一个 *Person* 对象、*Criteria* 接口和实现了该接口的实体类，来过滤 *Person* 对象的列表。*CriteriaPatternDemo* 类使用 *Criteria* 对象，基于各种标准和它们的结合来过滤 *Person* 对象的列表。

![过滤器模式的 UML 图](https://www.runoob.com/wp-content/uploads/2014/08/20201015-filter-md-20201230.svg)

**步骤 1**

创建一个类，在该类上应用标准。

```java
public class Person {

  private String name;
  private String gender;
  private String maritalStatus;

  public Person(String name,String gender,String maritalStatus){
    this.name = name;
    this.gender = gender;
    this.maritalStatus = maritalStatus;    
  }
  public String getName() {
    return name;
  }
  public String getGender() {
    return gender;
  }
  public String getMaritalStatus() {
    return maritalStatus;
  }  
}
```

**步骤 2**

为标准（Criteria）创建一个接口。

```java
import java.util.List;
public interface Criteria {
  public List<Person> meetCriteria(List<Person> persons);
}
```

**步骤 3**

创建实现了 *Criteria* 接口的实体类。

```java
import java.util.ArrayList;
import java.util.List;
public class CriteriaMale implements Criteria {
  @Override
  public List<Person> meetCriteria(List<Person> persons) {
    List<Person> malePersons = new ArrayList<Person>(); 
    for (Person person : persons) {
      if(person.getGender().equalsIgnoreCase("MALE")){
        malePersons.add(person);
      }
    }
    return malePersons;
  }
}
```

```java
import java.util.ArrayList;
import java.util.List;
public class CriteriaFemale implements Criteria {
  @Override
  public List<Person> meetCriteria(List<Person> persons) {
    List<Person> femalePersons = new ArrayList<Person>(); 
    for (Person person : persons) {
      if(person.getGender().equalsIgnoreCase("FEMALE")){
        femalePersons.add(person);
      }
    }
    return femalePersons;
  }
}
```

```java
import java.util.ArrayList;
import java.util.List;
public class CriteriaSingle implements Criteria {
  @Override
  public List<Person> meetCriteria(List<Person> persons) {
    List<Person> singlePersons = new ArrayList<Person>(); 
    for (Person person : persons) {
      if(person.getMaritalStatus().equalsIgnoreCase("SINGLE")){
        singlePersons.add(person);
      }
    }
    return singlePersons;
  }
}
```

```java
import java.util.List;

public class AndCriteria implements Criteria {
  private Criteria criteria;
  private Criteria otherCriteria;

  public AndCriteria(Criteria criteria, Criteria otherCriteria) {
    this.criteria = criteria;
    this.otherCriteria = otherCriteria; 
  }
  @Override
  public List<Person> meetCriteria(List<Person> persons) {
    List<Person> firstCriteriaPersons = criteria.meetCriteria(persons);     
    return otherCriteria.meetCriteria(firstCriteriaPersons);
  }
}
```

```java
import java.util.List;

public class OrCriteria implements Criteria {

  private Criteria criteria;
  private Criteria otherCriteria;

  public OrCriteria(Criteria criteria, Criteria otherCriteria) {
    this.criteria = criteria;
    this.otherCriteria = otherCriteria; 
  }

  @Override
  public List<Person> meetCriteria(List<Person> persons) {
    List<Person> firstCriteriaItems = criteria.meetCriteria(persons);
    List<Person> otherCriteriaItems = otherCriteria.meetCriteria(persons);

    for (Person person : otherCriteriaItems) {
      if(!firstCriteriaItems.contains(person)){
        firstCriteriaItems.add(person);
      }
    }  
    return firstCriteriaItems;
  }
}
```

**步骤4**

使用不同的标准（Criteria）和它们的结合来过滤 *Person* 对象的列表。

```java
import java.util.ArrayList; 
import java.util.List;

public class CriteriaPatternDemo {
  public static void main(String[] args) {
    List<Person> persons = new ArrayList<Person>();

    persons.add(new Person("Robert","Male", "Single"));
    persons.add(new Person("John","Male", "Married"));
    persons.add(new Person("Laura","Female", "Married"));
    persons.add(new Person("Diana","Female", "Single"));
    persons.add(new Person("Mike","Male", "Single"));
    persons.add(new Person("Bobby","Male", "Single"));

    Criteria male = new CriteriaMale();
    Criteria female = new CriteriaFemale();
    Criteria single = new CriteriaSingle();
    Criteria singleMale = new AndCriteria(single, male);
    Criteria singleOrFemale = new OrCriteria(single, female);

    System.out.println("Males: ");
    printPersons(male.meetCriteria(persons));

    System.out.println("\nFemales: ");
    printPersons(female.meetCriteria(persons));

    System.out.println("\nSingle Males: ");
    printPersons(singleMale.meetCriteria(persons));

    System.out.println("\nSingle Or Females: ");
    printPersons(singleOrFemale.meetCriteria(persons));
  }

  public static void printPersons(List<Person> persons){
    for (Person person : persons) {
      System.out.println("Person : [ Name : " + person.getName() 
                         +", Gender : " + person.getGender() 
                         +", Marital Status : " + person.getMaritalStatus()
                         +" ]");
    }
  }      
}
```

**步骤 5**

执行程序，输出结果：

```shell
Males: 
Person : [ Name : Robert, Gender : Male, Marital Status : Single ]
Person : [ Name : John, Gender : Male, Marital Status : Married ]
Person : [ Name : Mike, Gender : Male, Marital Status : Single ]
Person : [ Name : Bobby, Gender : Male, Marital Status : Single ]

Females: 
Person : [ Name : Laura, Gender : Female, Marital Status : Married ]
Person : [ Name : Diana, Gender : Female, Marital Status : Single ]

Single Males: 
Person : [ Name : Robert, Gender : Male, Marital Status : Single ]
Person : [ Name : Mike, Gender : Male, Marital Status : Single ]
Person : [ Name : Bobby, Gender : Male, Marital Status : Single ]

Single Or Females: 
Person : [ Name : Robert, Gender : Male, Marital Status : Single ]
Person : [ Name : Diana, Gender : Female, Marital Status : Single ]
Person : [ Name : Mike, Gender : Male, Marital Status : Single ]
Person : [ Name : Bobby, Gender : Male, Marital Status : Single ]
Person : [ Name : Laura, Gender : Female, Marital Status : Married ]
```

## 8.2 * 评论区补充

1. 过滤模式的实现在java8里面有典型的应用方法就是分组操作，可以根据指定的指标进行分组筛选。

   ```
   Map<Integer, List<Person >> groupMap = persons.stream().collect(Collectors.groupingBy(Person::getGender));
   groupMap.forEach((k, v) -> {
       System.out.println(k);
       v.forEach(System.out::println);
   });
   ```

   得到的结果形式就是：

   -  **k**：是分组的指标，上面代码中的 gender
   -  **v**：是一个list的集合对象，就是 personList

2. Java8 中有单独的过滤器。

   ```
   List<String> aList = Lists.newArrayList("1","2","");
   aList.stream().filter(x -> StringUtils.isNotEmpty(x))
   ```

   这个方法可以可获取到全部非空的字符串。

# 9. 组合模式

​	组合模式（Composite Pattern），又叫部分整体模式，是用于把一组相似的对象当作一个单一的对象。<u>组合模式依据树形结构来组合对象，用来表示部分以及整体层次</u>。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。

​	<u>这种模式创建了一个包含自己对象组的类。该类提供了修改相同对象组的方式。</u>

​	我们通过下面的实例来演示组合模式的用法。实例演示了一个组织中员工的层次结构。

## 9.1 介绍

**意图：**将对象组合成树形结构以表示"部分-整体"的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。

**主要解决：**它在我们树型结构的问题中，模糊了简单元素和复杂元素的概念，客户程序可以像处理简单元素一样来处理复杂元素，从而使得客户程序与复杂元素的内部结构解耦。

**何时使用：** 1、您想表示对象的部分-整体层次结构（树形结构）。 2、您希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。

**如何解决：**<u>树枝和叶子实现统一接口，树枝内部组合该接口</u>。

**关键代码：**<u>树枝内部组合该接口，并且含有内部属性 List，里面放 Component</u>。

**应用实例：** 1、算术表达式包括操作数、操作符和另一个操作数，其中，另一个操作符也可以是操作数、操作符和另一个操作数。 2、在 JAVA AWT 和 SWING 中，对于 Button 和 Checkbox 是树叶，Container 是树枝。

**优点：** 1、高层模块调用简单。 2、节点自由增加。

**缺点：**<u>在使用组合模式时，其叶子和树枝的声明都是实现类，而不是接口，违反了依赖倒置原则</u>。

**使用场景：**部分、整体场景，如树形菜单，文件、文件夹的管理。

**注意事项：**定义时为具体类。

## 9.2 实现

我们有一个类 *Employee*，该类被当作组合模型类。*CompositePatternDemo* 类使用 *Employee* 类来添加部门层次结构，并打印所有员工。

![组合模式的 UML 图](https://www.runoob.com/wp-content/uploads/2014/08/20201015-composite.svg)

**步骤 1**

创建 *Employee* 类，该类带有 *Employee* 对象的列表。

```java
import java.util.ArrayList;
import java.util.List;

public class Employee {
  private String name;
  private String dept;
  private int salary;
  private List<Employee> subordinates;

  //构造函数
  public Employee(String name,String dept, int sal) {
    this.name = name;
    this.dept = dept;
    this.salary = sal;
    subordinates = new ArrayList<Employee>();
  }

  public void add(Employee e) {
    subordinates.add(e);
  }

  public void remove(Employee e) {
    subordinates.remove(e);
  }

  public List<Employee> getSubordinates(){
    return subordinates;
  }

  public String toString(){
    return ("Employee :[ Name : "+ name 
            +", dept : "+ dept + ", salary :"
            + salary+" ]");
  }   
}
```

**步骤 2**

使用 *Employee* 类来创建和打印员工的层次结构。

```java
public class CompositePatternDemo {
  public static void main(String[] args) {
    Employee CEO = new Employee("John","CEO", 30000);

    Employee headSales = new Employee("Robert","Head Sales", 20000);

    Employee headMarketing = new Employee("Michel","Head Marketing", 20000);

    Employee clerk1 = new Employee("Laura","Marketing", 10000);
    Employee clerk2 = new Employee("Bob","Marketing", 10000);

    Employee salesExecutive1 = new Employee("Richard","Sales", 10000);
    Employee salesExecutive2 = new Employee("Rob","Sales", 10000);

    CEO.add(headSales);
    CEO.add(headMarketing);

    headSales.add(salesExecutive1);
    headSales.add(salesExecutive2);

    headMarketing.add(clerk1);
    headMarketing.add(clerk2);

    //打印该组织的所有员工
    System.out.println(CEO); 
    for (Employee headEmployee : CEO.getSubordinates()) {
      System.out.println(headEmployee);
      for (Employee employee : headEmployee.getSubordinates()) {
        System.out.println(employee);
      }
    }        
  }
}
```

**步骤 3**

执行程序，输出结果为：

```java
Employee :[ Name : John, dept : CEO, salary :30000 ]
Employee :[ Name : Robert, dept : Head Sales, salary :20000 ]
Employee :[ Name : Richard, dept : Sales, salary :10000 ]
Employee :[ Name : Rob, dept : Sales, salary :10000 ]
Employee :[ Name : Michel, dept : Head Marketing, salary :20000 ]
Employee :[ Name : Laura, dept : Marketing, salary :10000 ]
Employee :[ Name : Bob, dept : Marketing, salary :10000 ]
```

## 9.3 * 评论区补充

1. 组合模式讲解。

   1. 组合模式，就是在一个对象中包含其他对象，这些被包含的对象可能是终点对象（不再包含别的对象），也有可能是非终点对象（其内部还包含其他对象，或叫组对象），我们将对象称为节点，即一个根节点包含许多子节点，这些子节点有的不再包含子节点，而有的仍然包含子节点，以此类推。

   2. 所谓组合模式，其实说的是对象包含对象的问题，通过组合的方式（在对象内部引用对象）来进行布局，我认为这种组合是区别于继承的，而另一层含义是指树形结构子节点的抽象（将叶子节点与数枝节点抽象为子节点），区别于普通的分别定义叶子节点与数枝节点的方式。

   **更多内容请查看：[Java 设计模式之组合模式及应用场景](https://www.runoob.com/w3cnote/java-composite-pattern-2.html)**

# 10. * 装饰器模式

​	装饰器模式（Decorator Pattern）<u>允许向一个现有的对象添加新的功能，同时又不改变其结构</u>。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。

​	这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。

​	我们通过下面的实例来演示装饰器模式的用法。其中，我们将把一个形状装饰上不同的颜色，同时又不改变形状类。

## 10.1 介绍

**意图：**<u>动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活</u>。

**主要解决：**一般的，我们为了扩展一个类经常使用继承方式实现，由于继承为类引入静态特征，并且随着扩展功能的增多，子类会很膨胀。

**何时使用：**在不想增加很多子类的情况下扩展类。

**如何解决：**将具体功能职责划分，同时继承装饰者模式。

**关键代码：** 1、Component 类充当抽象角色，不应该具体实现。 2、修饰类引用和继承 Component 类，具体扩展类重写父类方法。

**应用实例：** 1、孙悟空有 72 变，当他变成"庙宇"后，他的根本还是一只猴子，但是他又有了庙宇的功能。 2、不论一幅画有没有画框都可以挂在墙上，但是通常都是有画框的，并且实际上是画框被挂在墙上。在挂在墙上之前，画可以被蒙上玻璃，装到框子里；这时画、玻璃和画框形成了一个物体。

**优点：**<u>装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能</u>。

**缺点：**多层装饰比较复杂。

**使用场景：** 1、扩展一个类的功能。 2、动态增加功能，动态撤销。

**注意事项：**<u>可代替继承</u>。

## 10.2 实现

我们将创建一个 *Shape* 接口和实现了 *Shape* 接口的实体类。然后我们创建一个实现了 *Shape* 接口的抽象装饰类 *ShapeDecorator*，并把 *Shape* 对象作为它的实例变量。

*RedShapeDecorator* 是实现了 *ShapeDecorator* 的实体类。

*DecoratorPatternDemo* 类使用 *RedShapeDecorator* 来装饰 *Shape* 对象。

![装饰器模式的 UML 图](https://www.runoob.com/wp-content/uploads/2014/08/20210420-decorator-1-decorator-decorator.svg)

**步骤 1**

创建一个接口：

```java
public interface Shape {
  void draw();
}
```

**步骤 2**

创建实现接口的实体类。

```java
public class Rectangle implements Shape {
  @Override
  public void draw() {
    System.out.println("Shape: Rectangle");
  }
}
```

```java
public class Circle implements Shape {
  @Override
  public void draw() {
    System.out.println("Shape: Circle");
  }
}
```

**步骤 3**

创建实现了 *Shape* 接口的抽象装饰类。

```java
public abstract class ShapeDecorator implements Shape {
  protected Shape decoratedShape;

  public ShapeDecorator(Shape decoratedShape){
    this.decoratedShape = decoratedShape;
  }

  public void draw(){
    decoratedShape.draw();
  }  
}
```

**步骤 4**

创建扩展了 *ShapeDecorator* 类的实体装饰类。

```java
public class RedShapeDecorator extends ShapeDecorator {

  public RedShapeDecorator(Shape decoratedShape) {
    super(decoratedShape);     
  }

  @Override
  public void draw() {
    decoratedShape.draw();         
    setRedBorder(decoratedShape);
  }

  private void setRedBorder(Shape decoratedShape){
    System.out.println("Border Color: Red");
  }
}
```

**步骤 5**

使用 *RedShapeDecorator* 来装饰 *Shape* 对象。

```java
public class DecoratorPatternDemo {
  public static void main(String[] args) {

    Shape circle = new Circle();
    ShapeDecorator redCircle = new RedShapeDecorator(new Circle());
    ShapeDecorator redRectangle = new RedShapeDecorator(new Rectangle());
    //Shape redCircle = new RedShapeDecorator(new Circle());
    //Shape redRectangle = new RedShapeDecorator(new Rectangle());
    System.out.println("Circle with normal border");
    circle.draw();

    System.out.println("\nCircle of red border");
    redCircle.draw();

    System.out.println("\nRectangle of red border");
    redRectangle.draw();
  }
}
```

**步骤 6**

执行程序，输出结果：

```shell
Circle with normal border
Shape: Circle

Circle of red border
Shape: Circle
Border Color: Red

Rectangle of red border
Shape: Rectangle
Border Color: Red
```

## 10.3 * 评论区补充

1. 一个更易理解的实例：

   装饰模式为已有类动态附加额外的功能就像LOL、王者荣耀等类Dota游戏中，英雄升级一样。每次英雄升级都会附加一个额外技能点学习技能。具体的英雄就是ConcreteComponent，技能栏就是装饰器Decorator，每个技能就是ConcreteDecorator；

   ```java
   //Component 英雄接口 
   public interface Hero {
     //学习技能
     void learnSkills();
   }
   //ConcreteComponent 具体英雄盲僧
   public class BlindMonk implements Hero {
   
     private String name;
   
     public BlindMonk(String name) {
       this.name = name;
     }
   
     @Override
     public void learnSkills() {
       System.out.println(name + "学习了以上技能！");
     }
   }
   //Decorator 技能栏
   public class Skills implements Hero{
   
     //持有一个英雄对象接口
     private Hero hero;
   
     public Skills(Hero hero) {
       this.hero = hero;
     }
   
     @Override
     public void learnSkills() {
       if(hero != null)
         hero.learnSkills();
     }    
   }
   //ConreteDecorator 技能：Q
   public class Skill_Q extends Skills{
   
     private String skillName;
   
     public Skill_Q(Hero hero,String skillName) {
       super(hero);
       this.skillName = skillName;
     }
   
     @Override
     public void learnSkills() {
       System.out.println("学习了技能Q:" +skillName);
       super.learnSkills();
     }
   }
   //ConreteDecorator 技能：W
   public class Skill_W extends Skills{
   
     private String skillName;
   
     public Skill_W(Hero hero,String skillName) {
       super(hero);
       this.skillName = skillName;
     }
   
     @Override
     public void learnSkills() {
       System.out.println("学习了技能W:" + skillName);
       super.learnSkills();
     }
   }
   //ConreteDecorator 技能：E
   public class Skill_E extends Skills{
   
     private String skillName;
   
     public Skill_E(Hero hero,String skillName) {
       super(hero);
       this.skillName = skillName;
     }
   
     @Override
     public void learnSkills() {
       System.out.println("学习了技能E:"+skillName);
       super.learnSkills();
     }
   }
   //ConreteDecorator 技能：R
   public class Skill_R extends Skills{    
   
     private String skillName;
   
     public Skill_R(Hero hero,String skillName) {
       super(hero);
       this.skillName = skillName;
     }
   
     @Override
     public void learnSkills() {
       System.out.println("学习了技能R:" +skillName );
       super.learnSkills();
     }
   }
   //客户端：召唤师
   public class Player {
     public static void main(String[] args) {
       //选择英雄
       Hero hero = new BlindMonk("李青");
   
       Skills skills = new Skills(hero);
       Skills r = new Skill_R(skills,"猛龙摆尾");
       Skills e = new Skill_E(r,"天雷破/摧筋断骨");
       Skills w = new Skill_W(e,"金钟罩/铁布衫");
       Skills q = new Skill_Q(w,"天音波/回音击");
       //学习技能
       q.learnSkills();
     }
   }
   ```

   输出：

   ```shell
   学习了技能Q:天音波/回音击
   学习了技能W:金钟罩/铁布衫
   学习了技能E:天雷破/摧筋断骨
   学习了技能R:猛龙摆尾
   李青学习了以上技能！
   ```

# 11. 外观模式

​	外观模式（Facade Pattern）隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。这种类型的设计模式属于结构型模式，它向现有的系统添加一个接口，来隐藏系统的复杂性。

​	这种模式涉及到一个单一的类，该类提供了客户端请求的简化方法和对现有系统类方法的委托调用。

## 11.1 介绍

**意图：**为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。

**主要解决：**降低访问复杂系统的内部子系统时的复杂度，简化客户端与之的接口。

**何时使用：** 1、客户端不需要知道系统内部的复杂联系，整个系统只需提供一个"接待员"即可。 2、定义系统的入口。

**如何解决：**客户端不与系统耦合，外观类与系统耦合。

**关键代码：**在客户端和复杂系统之间再加一层，这一层将调用顺序、依赖关系等处理好。

**应用实例：** 1、去医院看病，可能要去挂号、门诊、划价、取药，让患者或患者家属觉得很复杂，如果有提供接待人员，只让接待人员来处理，就很方便。 2、JAVA 的三层开发模式。

**优点：** 1、减少系统相互依赖。 2、提高灵活性。 3、提高了安全性。

**缺点：**不符合开闭原则，如果要改东西很麻烦，继承重写都不合适。

**使用场景：** 1、为复杂的模块或子系统提供外界访问的模块。 2、子系统相对独立。 3、预防低水平人员带来的风险。

**注意事项：**在层次化结构中，可以使用外观模式定义系统中每一层的入口。

## 11.2 实现

​	我们将创建一个 *Shape* 接口和实现了 *Shape* 接口的实体类。下一步是定义一个外观类 *ShapeMaker*。

​	*ShapeMaker* 类使用实体类来代表用户对这些类的调用。*FacadePatternDemo* 类使用 *ShapeMaker* 类来显示结果。

![外观模式的 UML 图](https://www.runoob.com/wp-content/uploads/2014/08/20201015-facade.svg)

**步骤 1**

创建一个接口。

```java
public interface Shape {
   void draw();
}
```

**步骤 2**

创建实现接口的实体类。

```java
public class Rectangle implements Shape {
  @Override
  public void draw() {
    System.out.println("Rectangle::draw()");
  }
}
```

```java
public class Square implements Shape {
  @Override
  public void draw() {
    System.out.println("Square::draw()");
  }
}
```

```java
public class Circle implements Shape {
  @Override
  public void draw() {
    System.out.println("Circle::draw()");
  }
}
```

**步骤 3**

创建一个外观类。

```java
public class ShapeMaker {
  private Shape circle;
  private Shape rectangle;
  private Shape square;

  public ShapeMaker() {
    circle = new Circle();
    rectangle = new Rectangle();
    square = new Square();
  }

  public void drawCircle(){
    circle.draw();
  }
  public void drawRectangle(){
    rectangle.draw();
  }
  public void drawSquare(){
    square.draw();
  }
}
```

**步骤 4**

使用该外观类画出各种类型的形状。

```java
public class FacadePatternDemo {
  public static void main(String[] args) {
    ShapeMaker shapeMaker = new ShapeMaker();

    shapeMaker.drawCircle();
    shapeMaker.drawRectangle();
    shapeMaker.drawSquare();      
  }
}
```

**步骤 5**

执行程序，输出结果：

```shell
Circle::draw()
Rectangle::draw()
Square::draw()
```

## 11.3 评论区补充

1. 举例子

   感觉电脑的例子更形象：

   电脑整机是 CPU、内存、硬盘的外观。有了外观以后，启动电脑和关闭电脑都简化了。

   直接 new 一个电脑。

   在 new 电脑的同时把 cpu、内存、硬盘都初始化好并且接好线。

   对外暴露方法（启动电脑，关闭电脑）。

   启动电脑（按一下电源键）：启动CPU、启动内存、启动硬盘

   关闭电脑（按一下电源键）：关闭硬盘、关闭内存、关闭CPU

   **更多参考内容**

   -  [Java 设计模式 – 外观模式](https://www.runoob.com/w3cnote/facade-pattern-2.html)
   -  [JAVA设计模式之门面模式 - 医院实例](https://www.runoob.com/w3cnote/facade-pattern-3.html)

# 12. * 享元模式

​	享元模式（Flyweight Pattern）主要用于减少创建对象的数量，以减少内存占用和提高性能。这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式。

​	享元模式尝试重用现有的同类对象，如果未找到匹配的对象，则创建新对象。我们将通过创建 5 个对象来画出 20 个分布于不同位置的圆来演示这种模式。由于只有 5 种可用的颜色，所以 color 属性被用来检查现有的 *Circle* 对象。

## 12.1 介绍

**意图：**运用共享技术有效地支持大量细粒度的对象。

**主要解决：**<u>在有大量对象时，有可能会造成内存溢出，我们把其中共同的部分抽象出来，如果有相同的业务请求，直接返回在内存中已有的对象，避免重新创建</u>。

**何时使用：** 1、系统中有大量对象。 2、这些对象消耗大量内存。 3、这些对象的状态大部分可以外部化。 4、这些对象可以按照内蕴状态分为很多组，当把外蕴对象从对象中剔除出来时，每一组对象都可以用一个对象来代替。 5、系统不依赖于这些对象身份，这些对象是不可分辨的。

**如何解决：**用唯一标识码判断，如果在内存中有，则返回这个唯一标识码所标识的对象。

**关键代码：**用 HashMap 存储这些对象。

**应用实例：** 1、JAVA 中的 String，如果有则返回，如果没有则创建一个字符串保存在字符串缓存池里面。 2、数据库的数据池。

**优点：**大大减少对象的创建，降低系统的内存，使效率提高。

**缺点：**提高了系统的复杂度，需要分离出外部状态和内部状态，而且外部状态具有固有化的性质，不应该随着内部状态的变化而变化，否则会造成系统的混乱。

**使用场景：** 1、系统有大量相似对象。 2、<u>需要缓冲池的场景</u>。

**注意事项：** 1、注意划分外部状态和内部状态，否则可能会引起线程安全问题。 2、这些类必须有一个工厂对象加以控制。

## 12.2 实现

![享元模式的 UML 图](https://www.runoob.com/wp-content/uploads/2014/08/20201015-fiyweight.svg)

**步骤 1**

创建一个接口。

```java
public interface Shape {
  void draw();
}
```

**步骤 2**

创建实现接口的实体类。

```java
public class Circle implements Shape {
  private String color;
  private int x;
  private int y;
  private int radius;

  public Circle(String color){
    this.color = color;     
  }

  public void setX(int x) {
    this.x = x;
  }

  public void setY(int y) {
    this.y = y;
  }

  public void setRadius(int radius) {
    this.radius = radius;
  }

  @Override
  public void draw() {
    System.out.println("Circle: Draw() [Color : " + color 
                       +", x : " + x +", y :" + y +", radius :" + radius);
  }
}
```

**步骤 3**

创建一个工厂，生成基于给定信息的实体类的对象。

```java
import java.util.HashMap;

public class ShapeFactory {
  private static final HashMap<String, Shape> circleMap = new HashMap<>();

  public static Shape getCircle(String color) {
    Circle circle = (Circle)circleMap.get(color);

    if(circle == null) {
      circle = new Circle(color);
      circleMap.put(color, circle);
      System.out.println("Creating circle of color : " + color);
    }
    return circle;
  }
}
```

**步骤 4**

使用该工厂，通过传递颜色信息来获取实体类的对象。

```java
public class FlyweightPatternDemo {
  private static final String colors[] = 
  { "Red", "Green", "Blue", "White", "Black" };
  public static void main(String[] args) {

    for(int i=0; i < 20; ++i) {
      Circle circle = 
        (Circle)ShapeFactory.getCircle(getRandomColor());
      circle.setX(getRandomX());
      circle.setY(getRandomY());
      circle.setRadius(100);
      circle.draw();
    }
  }
  private static String getRandomColor() {
    return colors[(int)(Math.random()*colors.length)];
  }
  private static int getRandomX() {
    return (int)(Math.random()*100 );
  }
  private static int getRandomY() {
    return (int)(Math.random()*100);
  }
}
```

**步骤 5**

执行程序，输出结果：

```shell
Creating circle of color : Black
Circle: Draw() [Color : Black, x : 36, y :71, radius :100
Creating circle of color : Green
Circle: Draw() [Color : Green, x : 27, y :27, radius :100
Creating circle of color : White
Circle: Draw() [Color : White, x : 64, y :10, radius :100
Creating circle of color : Red
Circle: Draw() [Color : Red, x : 15, y :44, radius :100
Circle: Draw() [Color : Green, x : 19, y :10, radius :100
Circle: Draw() [Color : Green, x : 94, y :32, radius :100
Circle: Draw() [Color : White, x : 69, y :98, radius :100
Creating circle of color : Blue
Circle: Draw() [Color : Blue, x : 13, y :4, radius :100
Circle: Draw() [Color : Green, x : 21, y :21, radius :100
Circle: Draw() [Color : Blue, x : 55, y :86, radius :100
Circle: Draw() [Color : White, x : 90, y :70, radius :100
Circle: Draw() [Color : Green, x : 78, y :3, radius :100
Circle: Draw() [Color : Green, x : 64, y :89, radius :100
Circle: Draw() [Color : Blue, x : 3, y :91, radius :100
Circle: Draw() [Color : Blue, x : 62, y :82, radius :100
Circle: Draw() [Color : Green, x : 97, y :61, radius :100
Circle: Draw() [Color : Green, x : 86, y :12, radius :100
Circle: Draw() [Color : Green, x : 38, y :93, radius :100
Circle: Draw() [Color : Red, x : 76, y :82, radius :100
Circle: Draw() [Color : Blue, x : 95, y :82, radius :100
```

## 12.3 评论区补充

1. 享元模式介绍

   ​	享元模式，换句话说就是共享对象，在某些对象需要重复创建，且最终只需要得到单一结果的情况下使用。因为此种模式是利用先前创建的已有对象，通过某种规则去判断当前所需对象是否可以利用原有对象做相应修改后得到想要的效果，如以上教程的实例，创建了20个不同效果的圆，但相同颜色的圆只需要创建一次便可，相同颜色的只需要引用原有对象，改变其坐标值便可。此种模式下，同一颜色的圆虽然位置不同，但其地址都是同一个，所以说此模式适用于结果注重单一结果的情况。

   ​	举一个简单例子，一个游戏中有不同的英雄角色，同一类型的角色也有不同属性的英雄，如刺客类型的英雄有很多个，按此种模式设计，利用英雄所属类型去引用原有同一类型的英雄实例，然后对其相应属性进行修改，便可得到最终想得到的最新英雄；比如说你创建了第一个刺客型英雄，然后需要设计第二个刺客型英雄，你利用第一个英雄改变属性得到第二个刺客英雄，最新的刺客英雄是诞生了，但第一个刺客英雄的属性也随之变得与第二个相同，这种情况显然是不可以的。

# 13. * 代理模式

​	在代理模式（Proxy Pattern）中，一个类代表另一个类的功能。这种类型的设计模式属于结构型模式。

​	在代理模式中，我们创建具有现有对象的对象，以便向外界提供功能接口。

## 13.1 介绍

**意图：**为其他对象提供一种代理以控制对这个对象的访问。

**主要解决：**在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层。

**何时使用：**想在访问一个类时做一些控制。

**如何解决：**增加中间层。

**关键代码：**实现与被代理类组合。

**应用实例：** 1、Windows 里面的快捷方式。 2、猪八戒去找高翠兰结果是孙悟空变的，可以这样理解：把高翠兰的外貌抽象出来，高翠兰本人和孙悟空都实现了这个接口，猪八戒访问高翠兰的时候看不出来这个是孙悟空，所以说孙悟空是高翠兰代理类。 3、买火车票不一定在火车站买，也可以去代售点。 4、一张支票或银行存单是账户中资金的代理。支票在市场交易中用来代替现金，并提供对签发人账号上资金的控制。 5、spring aop。

**优点：** 1、职责清晰。 2、高扩展性。 3、智能化。

**缺点：** 1、由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。 2、实现代理模式需要额外的工作，有些代理模式的实现非常复杂。

**使用场景：**<u>按职责来划分，通常有以下使用场景： 1、远程代理。 2、虚拟代理。 3、Copy-on-Write 代理。 4、保护（Protect or Access）代理。 5、Cache代理。 6、防火墙（Firewall）代理。 7、同步化（Synchronization）代理。 8、智能引用（Smart Reference）代理。</u>

**注意事项：** <u>1、和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。 2、和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。</u>

## 13.2 实现

​	我们将创建一个 *Image* 接口和实现了 *Image* 接口的实体类。*ProxyImage* 是一个代理类，减少 *RealImage* 对象加载的内存占用。

*ProxyPatternDemo* 类使用 *ProxyImage* 来获取要加载的 *Image* 对象，并按照需求进行显示。

![代理模式的 UML 图](https://www.runoob.com/wp-content/uploads/2014/08/20201015-proxy.svg)

**步骤 1**

创建一个接口。

```java
public interface Image {
  void display();
}
```

**步骤 2**

创建实现接口的实体类。

```java
public class RealImage implements Image {

  private String fileName;

  public RealImage(String fileName){
    this.fileName = fileName;
    loadFromDisk(fileName);
  }

  @Override
  public void display() {
    System.out.println("Displaying " + fileName);
  }

  private void loadFromDisk(String fileName){
    System.out.println("Loading " + fileName);
  }
}
```

```java
public class ProxyImage implements Image{

  private RealImage realImage;
  private String fileName;

  public ProxyImage(String fileName){
    this.fileName = fileName;
  }

  @Override
  public void display() {
    if(realImage == null){
      realImage = new RealImage(fileName);
    }
    realImage.display();
  }
}
```

**步骤 3**

当被请求时，使用 *ProxyImage* 来获取 *RealImage* 类的对象。

```java
public class ProxyPatternDemo {

  public static void main(String[] args) {
    Image image = new ProxyImage("test_10mb.jpg");

    // 图像将从磁盘加载
    image.display(); 
    System.out.println("");
    // 图像不需要从磁盘加载
    image.display();  
  }
}
```

**步骤 4**

执行程序，输出结果：

```shell
Loading test_10mb.jpg
Displaying test_10mb.jpg

Displaying test_10mb.jpg
```

## 13.3 * 评论区补充

1. JDK 自带的动态代理

   +  java.lang.reflect.Proxy：生成动态代理类和对象；
   +  java.lang.reflect.InvocationHandler（处理器接口）：可以通过invoke方法实现对真实角色的代理访问。

   每次通过 Proxy 生成的代理类对象都要指定对应的处理器对象。

   代码：

   1. 接口：Subject.java

      ```java
      public interface Subject {
        public int sellBooks();
        public String speak();
      }
      ```

   2. 真实对象：RealSubject.java

      ```java
      public class RealSubject implements Subject{
        @Override
        public int sellBooks() {
          System.out.println("卖书");
          return 1 ;
        }
        @Override
        public String speak() {
          System.out.println("说话");
          return "张三";
        }
      }
      ```

   3. 处理器对象：MyInvocationHandler.java

      ```java
      public class MyInvocationHandler implements InvocationHandler {
        /**
           * 因为需要处理真实角色，所以要把真实角色传进来
           */
        Subject realSubject ;
      
        public MyInvocationHandler(Subject realSubject) {
          this.realSubject = realSubject;
        }
      
        /**
           *
           * @param proxy    代理类
           * @param method    正在调用的方法
           * @param args      方法的参数
           * @return
           * @throws Throwable
           */
        @Override
        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
          System.out.println("调用代理类");
          if(method.getName().equals("sellBooks")){
            int invoke = (int)method.invoke(realSubject, args);
            System.out.println("调用的是卖书的方法");
            return invoke ;
          }else {
            String string = (String) method.invoke(realSubject,args) ;
            System.out.println("调用的是说话的方法");
            return  string ;
          }
        }
      }
      ```

   4. 调用端：Main.java

      ```java
      public class Client {
        public static void main(String[] args) {
          //真实对象
          Subject realSubject =  new RealSubject();
      
          MyInvocationHandler myInvocationHandler = new MyInvocationHandler(realSubject);
          //代理对象
          Subject proxyClass = (Subject) Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(), new Class[]{Subject.class}, myInvocationHandler);
      
          proxyClass.sellBooks();
      
          proxyClass.speak();
        }
      }
      ```

2. CGlib

   [Cglib](https://www.runoob.com/w3cnote/cglibcode-generation-library-intro.html) 动态代理是针对代理的类，动态生成一个子类，然后子类覆盖代理类中的方法，如果是private或是final类修饰的方法,则不会被重写。

   CGLIB是一个功能强大，高性能的代码生成包。它为没有实现接口的类提供代理，为JDK的动态代理提供了很好的补充。通常可以使用Java的动态代理创建代理，但当要代理的类没有实现接口或者为了更好的性能，CGLIB是一个好的选择。

   CGLIB作为一个开源项目，其代码托管在github，地址为：https://github.com/cglib/cglib

   + 需要代理的类:

     ```java
     public class Engineer {
       // 可以被代理
       public void eat() {
         System.out.println("工程师正在吃饭");
       }
       // final 方法不会被生成的字类覆盖
       public final void work() {
         System.out.println("工程师正在工作");
       }
       // private 方法不会被生成的字类覆盖
       private void play() {
         System.out.println("this engineer is playing game");
       }
     }
     ```

   + CGLIB 代理类:

     ```java
     public class CglibProxy implements MethodInterceptor {
       private Object target;
     
       public CglibProxy(Object target) {
         this.target = target;
       }
     
       @Override
       public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {
         System.out.println("###   before invocation");
         Object result = method.invoke(target, objects);
         System.out.println("###   end invocation");
         return result;
       }
     
       public static Object getProxy(Object target) {
         Enhancer enhancer = new Enhancer();
         // 设置需要代理的对象
         enhancer.setSuperclass(target.getClass());
         // 设置代理人
         enhancer.setCallback(new CglibProxy(target));
         return enhancer.create();
       }
     }
     ```

   + 测试方法：

     ```java
     public class CglibMainTest {
       public static void main(String[] args) {
         // 生成 Cglib 代理类
         Engineer engineerProxy = (Engineer) CglibProxy.getProxy(new Engineer());
         // 调用相关方法
         engineerProxy.eat();
       }
     }
     ```

   + 运行结果:

     ```shell
     ###   before invocation
     工程师正在吃饭
     ###   end invocation
     ```

   > 更多内容可以参考：[CGLIB(Code Generation Library) 介绍与原理](https://www.runoob.com/w3cnote/cglibcode-generation-library-intro.html)

# 14. * 责任链模式

​	顾名思义，责任链模式（Chain of Responsibility Pattern）为请求创建了一个接收者对象的链。这种模式给予请求的类型，对请求的发送者和接收者进行解耦。这种类型的设计模式属于行为型模式。

​	在这种模式中，通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。

## 14.1 介绍

**意图：**避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。

**主要解决：**职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了。

**何时使用：**在处理消息的时候以过滤很多道。

**如何解决：**拦截的类都实现统一接口。

**关键代码：**Handler 里面聚合它自己，在 HandlerRequest 里判断是否合适，如果没达到条件则向下传递，向谁传递之前 set 进去。

**应用实例：** 1、红楼梦中的"击鼓传花"。 2、<u>JS 中的事件冒泡</u>。 3、<u>JAVA WEB 中 Apache Tomcat 对 Encoding 的处理，Struts2 的拦截器，jsp servlet 的 Filter</u>。

**优点：** 1、降低耦合度。它将请求的发送者和接收者解耦。 2、简化了对象。使得对象不需要知道链的结构。 3、增强给对象指派职责的灵活性。通过改变链内的成员或者调动它们的次序，允许动态地新增或者删除责任。 4、增加新的请求处理类很方便。

**缺点：** 1、不能保证请求一定被接收。 2、系统性能将受到一定影响，而且在进行代码调试时不太方便，可能会造成循环调用。 3、可能不容易观察运行时的特征，有碍于除错。

**使用场景：** 1、有多个对象可以处理同一个请求，具体哪个对象处理该请求由运行时刻自动确定。 2、在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。 3、可动态指定一组对象处理请求。

**注意事项：**在 JAVA WEB 中遇到很多应用。

## 14.2 实现

我们创建抽象类 *AbstractLogger*，带有详细的日志记录级别。然后我们创建三种类型的记录器，都扩展了 *AbstractLogger*。每个记录器消息的级别是否属于自己的级别，如果是则相应地打印出来，否则将不打印并把消息传给下一个记录器。

![责任链模式的 UML 图](https://www.runoob.com/wp-content/uploads/2014/08/2021-chain-of-responsibility.svg)

**步骤 1**

创建抽象的记录器类。

```java
public abstract class AbstractLogger {
  public static int INFO = 1;
  public static int DEBUG = 2;
  public static int ERROR = 3;

  protected int level;

  //责任链中的下一个元素
  protected AbstractLogger nextLogger;

  public void setNextLogger(AbstractLogger nextLogger){
    this.nextLogger = nextLogger;
  }

  public void logMessage(int level, String message){
    if(this.level <= level){
      write(message);
    }
    if(nextLogger !=null){
      nextLogger.logMessage(level, message);
    }
  }

  abstract protected void write(String message);

}
```

**步骤 2**

创建扩展了该记录器类的实体类。

```java
public class ConsoleLogger extends AbstractLogger {

  public ConsoleLogger(int level){
    this.level = level;
  }

  @Override
  protected void write(String message) {    
    System.out.println("Standard Console::Logger: " + message);
  }
}
```

```java
public class ErrorLogger extends AbstractLogger {

  public ErrorLogger(int level){
    this.level = level;
  }

  @Override
  protected void write(String message) {    
    System.out.println("Error Console::Logger: " + message);
  }
}
```

```java
public class FileLogger extends AbstractLogger {

  public FileLogger(int level){
    this.level = level;
  }

  @Override
  protected void write(String message) {    
    System.out.println("File::Logger: " + message);
  }
}
```

**步骤 3**

创建不同类型的记录器。赋予它们不同的错误级别，并在每个记录器中设置下一个记录器。每个记录器中的下一个记录器代表的是链的一部分。

```java
public class ChainPatternDemo {

  private static AbstractLogger getChainOfLoggers(){

    AbstractLogger errorLogger = new ErrorLogger(AbstractLogger.ERROR);
    AbstractLogger fileLogger = new FileLogger(AbstractLogger.DEBUG);
    AbstractLogger consoleLogger = new ConsoleLogger(AbstractLogger.INFO);

    errorLogger.setNextLogger(fileLogger);
    fileLogger.setNextLogger(consoleLogger);

    return errorLogger;  
  }

  public static void main(String[] args) {
    AbstractLogger loggerChain = getChainOfLoggers();

    loggerChain.logMessage(AbstractLogger.INFO, "This is an information.");

    loggerChain.logMessage(AbstractLogger.DEBUG, 
                           "This is a debug level information.");

    loggerChain.logMessage(AbstractLogger.ERROR, 
                           "This is an error information.");
  }
}
```

**步骤 4**

执行程序，输出结果：

```shell
Standard Console::Logger: This is an information.
File::Logger: This is a debug level information.
Standard Console::Logger: This is a debug level information.
Error Console::Logger: This is an error information.
File::Logger: This is an error information.
Standard Console::Logger: This is an error information.
```

# 15. 命令模式

​	命令模式（Command Pattern）是一种数据驱动的设计模式，它属于行为型模式。请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。

## 15.1 介绍

**意图：**将一个请求封装成一个对象，从而使您可以用不同的请求对客户进行参数化。

**主要解决：**在软件系统中，行为请求者与行为实现者通常是一种紧耦合的关系，但某些场合，比如需要对行为进行记录、撤销或重做、事务等处理时，这种无法抵御变化的紧耦合的设计就不太合适。

**何时使用：**在某些场合，比如要对行为进行"记录、撤销/重做、事务"等处理，这种无法抵御变化的紧耦合是不合适的。在这种情况下，如何将"行为请求者"与"行为实现者"解耦？将一组行为抽象为对象，可以实现二者之间的松耦合。

**如何解决：**通过调用者调用接受者执行命令，顺序：调用者→命令→接受者。

**关键代码：**定义三个角色：1、received 真正的命令执行对象 2、Command 3、invoker 使用命令对象的入口

**应用实例：**<u>struts 1 中的 action 核心控制器 ActionServlet 只有一个，相当于 Invoker，而模型层的类会随着不同的应用有不同的模型类，相当于具体的 Command</u>。

**优点：** 1、降低了系统耦合度。 2、新的命令可以很容易添加到系统中去。

**缺点：**使用命令模式可能会导致某些系统有过多的具体命令类。

**使用场景：**认为是命令的地方都可以使用命令模式，比如： 1、GUI 中每一个按钮都是一条命令。 2、模拟 CMD。

**注意事项：**系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作，也可以考虑使用命令模式，见命令模式的扩展。

命令模式结构示意图:

![img](https://www.runoob.com/wp-content/uploads/2014/08/commanduml.jpg)

## 15.2 实现

​	我们首先创建作为命令的接口 *Order*，然后创建作为请求的 *Stock* 类。实体命令类 *BuyStock* 和 *SellStock*，实现了 *Order* 接口，将执行实际的命令处理。创建作为调用对象的类 *Broker*，它接受订单并能下订单。

​	*Broker* 对象使用命令模式，基于命令的类型确定哪个对象执行哪个命令。*CommandPatternDemo* 类使用 *Broker* 类来演示命令模式。

![img](https://www.runoob.com/wp-content/uploads/2014/08/20201015-command-1.svg)

**步骤 1**

创建一个命令接口。

```java
public interface Order {
  void execute();
}
```

**步骤 2**

创建一个请求类。

```java
public class Stock {

  private String name = "ABC";
  private int quantity = 10;

  public void buy(){
    System.out.println("Stock [ Name: "+name+",Quantity: " + quantity +" ] bought");
  }
  public void sell(){
    System.out.println("Stock [ Name: "+name+", Quantity: " + quantity +" ] sold");
  }
}
```

**步骤 3**

创建实现了 *Order* 接口的实体类。

```java
public class BuyStock implements Order {
  private Stock abcStock;

  public BuyStock(Stock abcStock){
    this.abcStock = abcStock;
  }

  public void execute() {
    abcStock.buy();
  }
}
```

```java
public class SellStock implements Order {
  private Stock abcStock;

  public SellStock(Stock abcStock){
    this.abcStock = abcStock;
  }

  public void execute() {
    abcStock.sell();
  }
}
```

**步骤 4**

创建命令调用类。

```java
import java.util.ArrayList;
import java.util.List;

public class Broker {
  private List<Order> orderList = new ArrayList<Order>(); 

  public void takeOrder(Order order){
    orderList.add(order);      
  }

  public void placeOrders(){
    for (Order order : orderList) {
      order.execute();
    }
    orderList.clear();
  }
}
```

**步骤 5**

使用 Broker 类来接受并执行命令。

```java
public class CommandPatternDemo {
  public static void main(String[] args) {
    Stock abcStock = new Stock();

    BuyStock buyStockOrder = new BuyStock(abcStock);
    SellStock sellStockOrder = new SellStock(abcStock);

    Broker broker = new Broker();
    broker.takeOrder(buyStockOrder);
    broker.takeOrder(sellStockOrder);

    broker.placeOrders();
  }
}
```

**步骤 6**

执行程序，输出结果：

```shell
Stock [ Name: ABC, Quantity: 10 ] bought
Stock [ Name: ABC, Quantity: 10 ] sold
```

# 16. 解释器模式

​	解释器模式（Interpreter Pattern）提供了评估语言的语法或表达式的方式，它属于行为型模式。这种模式实现了一个表达式接口，该接口解释一个特定的上下文。<u>这种模式被用在 SQL 解析、符号处理引擎等</u>。

## 16.1 介绍

**意图：**给定一个语言，定义它的文法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子。

**主要解决：**对于一些固定文法构建一个解释句子的解释器。

**何时使用：**如果一种特定类型的问题发生的频率足够高，那么可能就值得将该问题的各个实例表述为一个简单语言中的句子。这样就可以构建一个解释器，该解释器通过解释这些句子来解决该问题。

**如何解决：**<u>构建语法树，定义终结符与非终结符</u>。

**关键代码：**构建环境类，包含解释器之外的一些全局信息，一般是 HashMap。

**应用实例：**编译器、运算表达式计算。

**优点：** 1、可扩展性比较好，灵活。 2、增加了新的解释表达式的方式。 3、易于实现简单文法。

**缺点：** 1、可利用场景比较少。 2、对于复杂的文法比较难维护。 3、解释器模式会引起类膨胀。 4、解释器模式采用递归调用方法。

**使用场景：** <u>1、可以将一个需要解释执行的语言中的句子表示为一个抽象语法树。 2、一些重复出现的问题可以用一种简单的语言来进行表达。 3、一个简单语法需要解释的场景。</u>

**注意事项：**可利用场景比较少，JAVA 中如果碰到可以用 expression4J 代替。

## 16.2 实现

我们将创建一个接口 *Expression* 和实现了 *Expression* 接口的实体类。定义作为上下文中主要解释器的 *TerminalExpression* 类。其他的类 *OrExpression*、*AndExpression* 用于创建组合式表达式。

*InterpreterPatternDemo*，我们的演示类使用 *Expression* 类创建规则和演示表达式的解析。

![解释器模式的 UML 图](https://www.runoob.com/wp-content/uploads/2014/08/interpreter_pattern_uml_diagram.jpg)

**步骤 1**

创建一个表达式接口。

```java
public interface Expression {
  public boolean interpret(String context);
}
```

**步骤 2**

创建实现了上述接口的实体类。

```java
public class TerminalExpression implements Expression {

  private String data;

  public TerminalExpression(String data){
    this.data = data; 
  }

  @Override
  public boolean interpret(String context) {
    if(context.contains(data)){
      return true;
    }
    return false;
  }
}
```

```java
public class OrExpression implements Expression {

  private Expression expr1 = null;
  private Expression expr2 = null;

  public OrExpression(Expression expr1, Expression expr2) { 
    this.expr1 = expr1;
    this.expr2 = expr2;
  }

  @Override
  public boolean interpret(String context) {      
    return expr1.interpret(context) || expr2.interpret(context);
  }
}
```

```java
public class AndExpression implements Expression {

  private Expression expr1 = null;
  private Expression expr2 = null;

  public AndExpression(Expression expr1, Expression expr2) { 
    this.expr1 = expr1;
    this.expr2 = expr2;
  }

  @Override
  public boolean interpret(String context) {      
    return expr1.interpret(context) && expr2.interpret(context);
  }
}
```

**步骤 3**

*InterpreterPatternDemo* 使用 *Expression* 类来创建规则，并解析它们。

```java
public class InterpreterPatternDemo {

  //规则：Robert 和 John 是男性
  public static Expression getMaleExpression(){
    Expression robert = new TerminalExpression("Robert");
    Expression john = new TerminalExpression("John");
    return new OrExpression(robert, john);    
  }

  //规则：Julie 是一个已婚的女性
  public static Expression getMarriedWomanExpression(){
    Expression julie = new TerminalExpression("Julie");
    Expression married = new TerminalExpression("Married");
    return new AndExpression(julie, married);    
  }

  public static void main(String[] args) {
    Expression isMale = getMaleExpression();
    Expression isMarriedWoman = getMarriedWomanExpression();

    System.out.println("John is male? " + isMale.interpret("John"));
    System.out.println("Julie is a married women? " 
                       + isMarriedWoman.interpret("Married Julie"));
  }
}
```

**步骤 4**

执行程序，输出结果：

```shell
John is male? true
Julie is a married women? true
```

# 17. * 迭代器模式

​	迭代器模式（Iterator Pattern）是 Java 和 .Net 编程环境中非常常用的设计模式。这种模式用于顺序访问集合对象的元素，不需要知道集合对象的底层表示。

​	迭代器模式属于行为型模式。

## 17.1 介绍

**意图：**提供一种方法顺序访问一个聚合对象中各个元素, 而又无须暴露该对象的内部表示。

**主要解决：**不同的方式来遍历整个整合对象。

**何时使用：**遍历一个聚合对象。

**如何解决：**把在元素之间游走的责任交给迭代器，而不是聚合对象。

**关键代码：**定义接口：hasNext, next。

**应用实例：**JAVA 中的 iterator。

**优点：** 1、它支持以不同的方式遍历一个聚合对象。 2、迭代器简化了聚合类。 3、在同一个聚合上可以有多个遍历。 4、在迭代器模式中，增加新的聚合类和迭代器类都很方便，无须修改原有代码。

**缺点：**由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性。

**使用场景：** 1、访问一个聚合对象的内容而无须暴露它的内部表示。 2、需要为聚合对象提供多种遍历方式。 3、为遍历不同的聚合结构提供一个统一的接口。

**注意事项：**迭代器模式就是分离了集合对象的遍历行为，抽象出一个迭代器类来负责，这样既可以做到不暴露集合的内部结构，又可让外部代码透明地访问集合内部的数据。

## 17.2 实现

我们将创建一个叙述导航方法的 *Iterator* 接口和一个返回迭代器的 *Container* 接口。实现了 *Container* 接口的实体类将负责实现 *Iterator* 接口。

*IteratorPatternDemo*，我们的演示类使用实体类 *NamesRepository* 来打印 *NamesRepository* 中存储为集合的 *Names*。

![迭代器模式的 UML 图](https://www.runoob.com/wp-content/uploads/2014/08/iterator_pattern_uml_diagram.jpg)

**步骤 1**

创建接口:

```java
public interface Iterator {
  public boolean hasNext();
  public Object next();
}
```

```java
public interface Container {
  public Iterator getIterator();
}
```

**步骤 2**

创建实现了 *Container* 接口的实体类。该类有实现了 *Iterator* 接口的内部类 *NameIterator*。

```java
public class NameRepository implements Container {
  public String[] names = {"Robert" , "John" ,"Julie" , "Lora"};

  @Override
  public Iterator getIterator() {
    return new NameIterator();
  }

  private class NameIterator implements Iterator {
    
    int index;
    
    @Override
    public boolean hasNext() {
      if(index < names.length){
        return true;
      }
      return false;
    }
    
    @Override
    public Object next() {
      if(this.hasNext()){
        return names[index++];
      }
      return null;
    }     
  }
}
```

**步骤 3**

使用 *NameRepository* 来获取迭代器，并打印名字。

```java
public class IteratorPatternDemo {
  public static void main(String[] args) {
    NameRepository namesRepository = new NameRepository();
    for(Iterator iter = namesRepository.getIterator(); iter.hasNext();){
      String name = (String)iter.next();
      System.out.println("Name : " + name);
    }  
  }
}
```

**步骤 4**

执行程序，输出结果：

```
Name : Robert
Name : John
Name : Julie
Name : Lora
```

# 18. 中介者模式

​	中介者模式（Mediator Pattern）是用来降低多个对象和类之间的通信复杂性。这种模式提供了一个中介类，该类通常处理不同类之间的通信，并支持松耦合，使代码易于维护。中介者模式属于行为型模式。

## 18.1 介绍

**意图：**用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。

**主要解决：**对象与对象之间存在大量的关联关系，这样势必会导致系统的结构变得很复杂，同时若一个对象发生改变，我们也需要跟踪与之相关联的对象，同时做出相应的处理。

**何时使用：**多个类相互耦合，形成了网状结构。

**如何解决：**将上述网状结构分离为星型结构。

**关键代码：**对象 Colleague 之间的通信封装到一个类中单独处理。

**应用实例：** 1、中国加入 WTO 之前是各个国家相互贸易，结构复杂，现在是各个国家通过 WTO 来互相贸易。 2、机场调度系统。 3、<u>MVC 框架，其中C（控制器）就是 M（模型）和 V（视图）的中介者</u>。

**优点：** 1、降低了类的复杂度，将一对多转化成了一对一。 2、各个类之间的解耦。 3、符合迪米特原则。

**缺点：**中介者会庞大，变得复杂难以维护。

**使用场景：** 1、系统中对象之间存在比较复杂的引用关系，导致它们之间的依赖关系结构混乱而且难以复用该对象。 2、想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。

**注意事项：**不应当在职责混乱的时候使用。

## 18.2 实现

我们通过聊天室实例来演示中介者模式。实例中，多个用户可以向聊天室发送消息，聊天室向所有的用户显示消息。我们将创建两个类 *ChatRoom* 和 *User*。*User* 对象使用 *ChatRoom* 方法来分享他们的消息。

*MediatorPatternDemo*，我们的演示类使用 *User* 对象来显示他们之间的通信。

![中介者模式的 UML 图](https://www.runoob.com/wp-content/uploads/2014/08/mediator_pattern_uml_diagram.jpg)

**步骤 1**

创建中介类。

```java
public class ChatRoom {
  public static void showMessage(User user, String message){
    System.out.println(new Date().toString() + " [" + user.getName() +"] : " + message);
  }
}
```

**步骤 2**

创建 user 类。

```java
public class User {
  private String name;

  public String getName() {
    return name;
  }
  public void setName(String name) {
    this.name = name;
  }
  public User(String name){
    this.name  = name;
  }
  public void sendMessage(String message){
    ChatRoom.showMessage(this,message);
  }
}
```

**步骤 3**

使用 *User* 对象来显示他们之间的通信。

```java
public class MediatorPatternDemo {
  public static void main(String[] args) {
    User robert = new User("Robert");
    User john = new User("John");

    robert.sendMessage("Hi! John!");
    john.sendMessage("Hello! Robert!");
  }
}
```

**步骤 4**

执行程序，输出结果：

```shell
Thu Jan 31 16:05:46 IST 2013 [Robert] : Hi! John!
Thu Jan 31 16:05:46 IST 2013 [John] : Hello! Robert!
```

## 18.3 * 评论区补充

1. 什么是中介者模式

   ![img](https://www.runoob.com/wp-content/uploads/2018/11/mediator-pattern21.jpg)

   在现实生活中，有很多中介者模式的身影，例如QQ游戏平台，聊天室、QQ群、短信平台和房产中介。不论是QQ游戏还是QQ群，它们都是充当一个中间平台，QQ用户可以登录这个中间平台与其他QQ用户进行交流，如果没有这些中间平台，我们如果想与朋友进行聊天的话，可能就需要当面才可以了。电话、短信也同样是一个中间平台，有了这个中间平台，每个用户都不要直接依赖与其他用户，只需要依赖这个中间平台就可以了，一切操作都由中间平台去分发。

   中介者模式，定义了一个中介对象来封装一系列对象之间的交互关系。中介者使各个对象之间不需要显式地相互引用，从而使耦合性降低，而且可以独立地改变它们之间的交互行为。

   ![img](https://www.runoob.com/wp-content/uploads/2018/11/mediator-pattern22.png)

   **设计思路及代码实现:**

   ![img](https://www.runoob.com/wp-content/uploads/2018/11/mediator-pattern23.jpeg)

   以现实生活中打牌的例子来实现下中介者模式。打牌总有输赢，对应的则是货币的变化，如果不用中介者模式的话，实现如下：

   ```c++
   /// <summary>
   /// 抽象牌友类
   /// </summary>
   public abstract class AbstractCardPartner
   {
       public int Money { get; set; }
    
       public abstract void ChangeMoney(int money, AbstractCardPartner other);
   }
    
   /// <summary>
   /// 牌友A
   /// </summary>
   public class PartnerA : AbstractCardPartner
   {
       public override void ChangeMoney(int money, AbstractCardPartner other)
       {
           Money += money;
           other.Money -= money;
       }
   }
    
   /// <summary>
   /// 牌友B
   /// </summary>
   public class PartnerB : AbstractCardPartner
   {
       public override void ChangeMoney(int money, AbstractCardPartner other)
       {
           Money += money;
           other.Money -= money;
       }
   }
    
   /// <summary>
   /// 调用
   /// </summary>
   /// <param name="args"></param>
   static void Main(string[] args)
   {
       AbstractCardPartner A = new PartnerA();
       A.Money = 20;
       AbstractCardPartner B = new PartnerB();
       B.Money = 20;
    
       // A赢了B的钱减少
       A.ChangeMoney(5, B);
       Console.WriteLine("A 现在的钱是：{0}", A.Money); // 应该是25
       Console.WriteLine("B 现在的钱是：{0}", B.Money); // 应该是15
    
       // B赢了A的钱减少
       B.ChangeMoney(10, A);
       Console.WriteLine("A 现在的钱是：{0}", A.Money); // 应该是15
       Console.WriteLine("B 现在的钱是：{0}", B.Money); // 应该是25
    
       Console.ReadLine();
   }
   ```

   这样的实现确实解决了上面场景中的问题，并且使用了抽象类使具体牌友A和牌友B都依赖于抽象类，从而降低了同事类之间的耦合度。但是如果其中牌友A发生变化时，此时就会影响到牌友B的状态，如果涉及的对象变多的话，这时候某一个牌友的变化将会影响到其他所有相关联的牌友状态。例如牌友A算错了钱，这时候牌友A和牌友B的钱数都不正确了，如果是多个人打牌的话，影响的对象就会更多。这时候就会思考——能不能把算钱的任务交给程序或者算数好的人去计算呢，这时候就有了我们QQ游戏中的欢乐斗地主等牌类游戏了。

   进一步完善的方案，即加入一个中介者对象来协调各个对象之间的关联，这也就是中介者模式的应用了，具体完善后的实现代码如下所示：

   ```c++
   /// <summary>
   /// 抽象牌友类
   /// </summary>
   public abstract class AbstractCardPartner
   {
       public int Money { get; set; }
    
       public abstract void ChangeMoney(int money, AbstractMediator mediator);
   }
    
   /// <summary>
   /// 牌友A
   /// </summary>
   public class PartnerA : AbstractCardPartner
   {
       public override void ChangeMoney(int money, AbstractMediator mediator)
       {
           mediator.AWin(money);
       }
   }
    
   /// <summary>
   /// 牌友B
   /// </summary>
   public class PartnerB : AbstractCardPartner
   {
       public override void ChangeMoney(int money, AbstractMediator mediator)
       {
           mediator.BWin(money);
       }
   }
    
   /// <summary>
   /// 抽象中介者类
   /// </summary>
   public abstract class AbstractMediator
   {
       protected AbstractCardPartner A;
       protected AbstractCardPartner B;
    
       public AbstractMediator(AbstractCardPartner a, AbstractCardPartner b)
       {
           A = a;
           B = b;
       }
    
       public abstract void AWin(int money);
       public abstract void BWin(int money);
   }
    
   /// <summary>
   /// 调用
   /// </summary>
   /// <param name="args"></param>
   static void Main(string[] args)
   {
       AbstractCardPartner A = new PartnerA();
       AbstractCardPartner B = new PartnerB();
       A.Money = 20;
       B.Money = 20;
    
       AbstractMediator mediator = new MediatorPater(A, B);
    
       // A赢了
       A.ChangeMoney(5, mediator);
       Console.WriteLine("A 现在的钱是：{0}", A.Money); // 应该是25
       Console.WriteLine("B 现在的钱是：{0}", B.Money); // 应该是15
    
       // B赢了
       B.ChangeMoney(10, mediator);
       Console.WriteLine("A 现在的钱是：{0}", A.Money); // 应该是15
       Console.WriteLine("B 现在的钱是：{0}", B.Money); // 应该是25
    
       Console.ReadLine();
   }
   ```

   在上面的实现代码中，抽象中介者类保存了两个抽象牌友类，如果新添加一个牌友类似时，此时就不得不去更改这个抽象中介者类。可以结合观察者模式来解决这个问题，即抽象中介者对象保存抽象牌友的类别，然后添加Register和UnRegister方法来对该列表进行管理，然后在具体中介者类中修改AWin和BWin方法，遍历列表，改变自己和其他牌友的钱数。这样的设计还是存在一个问题——即增加一个新牌友时，此时虽然解决了抽象中介者类不需要修改的问题，但此时还是不得不去修改具体中介者类，即添加CWin方法，我们可以采用状态模式来解决这个问题，关于状态模式的介绍将会在下一篇进行介绍。

   **中介者模式的优缺点**

   **优点：**

   - 简化了对象之间的关系，将系统的各个对象之间的相互关系进行封装，将各个同事类解耦，使得系统变为松耦合。
   - 提供系统的灵活性，使得各个同事对象独立而易于复用。

   **缺点：**

   - 中介者模式中，中介者角色承担了较多的责任，所以一旦这个中介者对象出现了问题，整个系统将会受到重大的影响。
   - 新增加一个同事类时，不得不去修改抽象中介者类和具体中介者类，此时可以使用观察者模式和状态模式来解决这个问题。

   **中介者模式的适用场景**

   以下情况下可以考虑使用中介者模式：

   - 一组定义良好的对象，现在要进行复杂的相互通信。
   - 想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。

# 19. 备忘录模式

​	备忘录模式（Memento Pattern）保存一个对象的某个状态，以便在适当的时候恢复对象。备忘录模式属于行为型模式。

## 19.1 介绍

**意图：**在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。

**主要解决：**所谓备忘录模式就是在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态。

**何时使用：**很多时候我们总是需要记录一个对象的内部状态，这样做的目的就是为了允许用户取消不确定或者错误的操作，能够恢复到他原先的状态，使得他有"后悔药"可吃。

**如何解决：**通过一个备忘录类专门存储对象状态。

**关键代码：**客户不与备忘录类耦合，与备忘录管理类耦合。

**应用实例：** 1、后悔药。 2、打游戏时的存档。 3、Windows 里的 ctri + z。 4、IE 中的后退。 4、数据库的事务管理。

**优点：** 1、给用户提供了一种可以恢复状态的机制，可以使用户能够比较方便地回到某个历史的状态。 2、实现了信息的封装，使得用户不需要关心状态的保存细节。

**缺点：**消耗资源。如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定的内存。

**使用场景：** 1、需要保存/恢复数据的相关状态场景。 2、提供一个可回滚的操作。

**注意事项：** 1、为了符合迪米特原则，还要增加一个管理备忘录的类。 2、<u>为了节约内存，可使用原型模式+备忘录模式。</u>

## 19.2 实现

备忘录模式使用三个类 *Memento*、*Originator* 和 *CareTaker*。Memento 包含了要被恢复的对象的状态。Originator 创建并在 Memento 对象中存储状态。Caretaker 对象负责从 Memento 中恢复对象的状态。

*MementoPatternDemo*，我们的演示类使用 *CareTaker* 和 *Originator* 对象来显示对象的状态恢复。

![备忘录模式的 UML 图](https://www.runoob.com/wp-content/uploads/2014/08/memento_pattern_uml_diagram.jpg)

**步骤 1**

创建 Memento 类。

```java
public class Memento {
  private String state;

  public Memento(String state){
    this.state = state;
  }
  public String getState(){
    return state;
  }  
}
```

**步骤 2**

创建 Originator 类。

```java
public class Originator {
  private String state;

  public void setState(String state){
    this.state = state;
  }
  public String getState(){
    return state;
  }

  public Memento saveStateToMemento(){
    return new Memento(state);
  }
  public void getStateFromMemento(Memento Memento){
    state = Memento.getState();
  }
}
```

**步骤 3**

创建 CareTaker 类。

```java
import java.util.ArrayList;
import java.util.List;

public class CareTaker {
  private List<Memento> mementoList = new ArrayList<Memento>();

  public void add(Memento state){
    mementoList.add(state);
  }

  public Memento get(int index){
    return mementoList.get(index);
  }
}
```

**步骤 4**

使用 *CareTaker* 和 *Originator* 对象。

```java
public class MementoPatternDemo {
  public static void main(String[] args) {
    Originator originator = new Originator();
    CareTaker careTaker = new CareTaker();
    originator.setState("State #1");
    originator.setState("State #2");
    careTaker.add(originator.saveStateToMemento());
    originator.setState("State #3");
    careTaker.add(originator.saveStateToMemento());
    originator.setState("State #4");

    System.out.println("Current State: " + originator.getState());    
    originator.getStateFromMemento(careTaker.get(0));
    System.out.println("First saved State: " + originator.getState());
    originator.getStateFromMemento(careTaker.get(1));
    System.out.println("Second saved State: " + originator.getState());
  }
}
```

**步骤 5**

验证输出。

```shell
Current State: State #4
First saved State: State #2
Second saved State: State #3
```

# 20. * 观察者模式

​	当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知依赖它的对象。观察者模式属于行为型模式。

## 20.1 介绍

**意图：**定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。

**主要解决：**一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作。

**何时使用：**一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知，进行广播通知。

**如何解决：**使用面向对象技术，可以将这种依赖关系弱化。

**关键代码：**在抽象类里有一个 ArrayList 存放观察者们。

**应用实例：** 1、拍卖的时候，拍卖师观察最高标价，然后通知给其他竞价者竞价。 2、西游记里面悟空请求菩萨降服红孩儿，菩萨洒了一地水招来一个老乌龟，这个乌龟就是观察者，他观察菩萨洒水这个动作。

**优点：** 1、观察者和被观察者是抽象耦合的。 2、建立一套触发机制。

**缺点：** 1、如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。 2、<u>如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃</u>。 3、观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。

**使用场景：**

- 一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。
- 一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度。
- 一个对象必须通知其他对象，而并不知道这些对象是谁。
- 需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制。

**注意事项：** <u>1、JAVA 中已经有了对观察者模式的支持类。 2、避免循环引用。 3、如果顺序执行，某一观察者错误会导致系统卡壳，一般采用异步方式。</u>

## 20.2 实现

观察者模式使用三个类 Subject、Observer 和 Client。Subject 对象带有绑定观察者到 Client 对象和从 Client 对象解绑观察者的方法。我们创建 *Subject* 类、*Observer* 抽象类和扩展了抽象类 *Observer* 的实体类。

*ObserverPatternDemo*，我们的演示类使用 *Subject* 和实体类对象来演示观察者模式。

![观察者模式的 UML 图](https://www.runoob.com/wp-content/uploads/2014/08/observer_pattern_uml_diagram.jpg)

**步骤 1**

创建 Subject 类。

```java
import java.util.ArrayList;
import java.util.List;

public class Subject {

  private List<Observer> observers 
    = new ArrayList<Observer>();
  private int state;

  public int getState() {
    return state;
  }

  public void setState(int state) {
    this.state = state;
    notifyAllObservers();
  }

  public void attach(Observer observer){
    observers.add(observer);      
  }

  public void notifyAllObservers(){
    for (Observer observer : observers) {
      observer.update();
    }
  }  
}
```

**步骤 2**

创建 Observer 类。

```java
public abstract class Observer {
  protected Subject subject;
  public abstract void update();
}
```

**步骤 3**

创建实体观察者类。

```java
public class BinaryObserver extends Observer{

  public BinaryObserver(Subject subject){
    this.subject = subject;
    this.subject.attach(this);
  }

  @Override
  public void update() {
    System.out.println( "Binary String: " + Integer.toBinaryString( subject.getState() ) ); 
  }
}
```

```java
public class OctalObserver extends Observer{

  public OctalObserver(Subject subject){
    this.subject = subject;
    this.subject.attach(this);
  }

  @Override
  public void update() {
    System.out.println( "Octal String: "+ Integer.toOctalString( subject.getState() ) ); 
  }
}
```

```java
public class HexaObserver extends Observer{

  public HexaObserver(Subject subject){
    this.subject = subject;
    this.subject.attach(this);
  }

  @Override
  public void update() {
    System.out.println( "Hex String: " + Integer.toHexString( subject.getState()).toUpperCase() ); 
  }
}
```

**步骤 4**

使用 *Subject* 和实体观察者对象。

```java
public class ObserverPatternDemo {
  public static void main(String[] args) {
    Subject subject = new Subject();

    new HexaObserver(subject);
    new OctalObserver(subject);
    new BinaryObserver(subject);

    System.out.println("First state change: 15");   
    subject.setState(15);
    System.out.println("Second state change: 10");  
    subject.setState(10);
  }
}
```

**步骤 5**

执行程序，输出结果：

```shell
First state change: 15
Hex String: F
Octal String: 17
Binary String: 1111
Second state change: 10
Hex String: A
Octal String: 12
Binary String: 1010
```

## 20.3 评论区补充

1. 观察者模式的定义

   ​	Observer 模式的定义：该模式**定义了对象之间的一对多依赖关系**，Subject 对象是一，Observer 对象是多。**当 Subject 对象的状态发生改变时，所有依赖于该 Subject 对象的 Observer 对象都会得到通知**，**并且自动更新**。

   仔细分析定义，要精确理解观察者模式主要注意三点：

   1. 定义了对象间的一对多依赖关系；

   2. 当 Subject 对象的状态发生改变时，所有依赖于该 Subject 对象的 Observer 对象都会得到通知；

   3. Observer 对象得到通知后，会自动更新，而不是被动；

   其它的所有点都是细枝末节，由具体业务需求来决定。比如：

   1. Subject 角色是应该定义成类？比如 内置的 java.util.Observable；还是应该定义成接口，以规避Java不支持多重继承的问题？比如《Head First 设计模式》中的推荐作法。

   2. 应该在什么时候订阅主题（或者说注册观察者）？是实例化观察者对象的同时？比如贴主的示例；还是由客户自主决定？比如此贴的第一篇分享笔记。

   3. 是否应该实现取消订阅功能（或者说取消注册）？

   4. 主题对象通知观察者时，是否携带消息？换句话说，是“推”消息？如贴主示例；还是“拉”消息？

   5. 是否支持多线程？

# 21. 状态模式

在状态模式（State Pattern）中，**类的行为是基于它的状态改变的**。这种类型的设计模式属于行为型模式。

在状态模式中，我们创建表示各种状态的对象和一个行为随着状态对象改变而改变的 context 对象。

## 21.1 介绍

**意图：**允许对象在内部状态发生改变时改变它的行为，对象看起来好像修改了它的类。

**主要解决：**对象的行为依赖于它的状态（属性），并且可以根据它的状态改变而改变它的相关行为。

**何时使用：**<u>代码中包含大量与对象状态有关的条件语句</u>。

**如何解决：**将各种具体的状态类抽象出来。

**关键代码：**通常命令模式的接口中只有一个方法。而状态模式的接口中有一个或者多个方法。而且，状态模式的实现类的方法，一般返回值，或者是改变实例变量的值。也就是说，状态模式一般和对象的状态有关。实现类的方法有不同的功能，覆盖接口中的方法。<u>状态模式和命令模式一样，也可以用于消除 if...else 等条件选择语句</u>。

**应用实例：** 1、打篮球的时候运动员可以有正常状态、不正常状态和超常状态。 2、曾侯乙编钟中，'钟是抽象接口','钟A'等是具体状态，'曾侯乙编钟'是具体环境（Context）。

**优点：** 1、封装了转换规则。 2、枚举可能的状态，在枚举状态之前需要确定状态种类。 3、将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为。 4、允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块。 5、可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数。

**缺点：** 1、状态模式的使用必然会增加系统类和对象的个数。 2、状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。 3、状态模式对"开闭原则"的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源代码，否则无法切换到新增状态，而且修改某个状态类的行为也需修改对应类的源代码。

**使用场景：** 1、行为随状态改变而改变的场景。 2、条件、分支语句的代替者。

**注意事项：**<u>在行为受状态约束的时候使用状态模式，而且状态不超过 5 个</u>。

## 21.2 实现

我们将创建一个 *State* 接口和实现了 *State* 接口的实体状态类。*Context* 是一个带有某个状态的类。

*StatePatternDemo*，我们的演示类使用 *Context* 和状态对象来演示 Context 在状态改变时的行为变化。

![状态模式的 UML 图](https://www.runoob.com/wp-content/uploads/2014/08/state_pattern_uml_diagram.png)

**步骤 1**

创建一个接口。

```java
public interface State {
  public void doAction(Context context);
}
```

**步骤 2**

创建实现接口的实体类。

```java
public class StartState implements State {
  public void doAction(Context context) {
    System.out.println("Player is in start state");
    context.setState(this); 
  }
  public String toString(){
    return "Start State";
  }
}
```

```java
public class StopState implements State {
  public void doAction(Context context) {
    System.out.println("Player is in stop state");
    context.setState(this); 
  }
  public String toString(){
    return "Stop State";
  }
}
```

**步骤 3**

创建 *Context* 类。

```java
public class Context {
  private State state;

  public Context(){
    state = null;
  }
  public void setState(State state){
    this.state = state;     
  }
  public State getState(){
    return state;
  }
}
```

**步骤 4**

使用 *Context* 来查看当状态 *State* 改变时的行为变化。

```java
public class StatePatternDemo {
  public static void main(String[] args) {
    Context context = new Context();

    StartState startState = new StartState();
    startState.doAction(context);

    System.out.println(context.getState().toString());

    StopState stopState = new StopState();
    stopState.doAction(context);

    System.out.println(context.getState().toString());
  }
}
```

**步骤 5**

执行程序，输出结果：

```shell
Player is in start state
Start State
Player is in stop state
Stop State
```

## 21.3 更多文章

> * [策略模式 VS 状态模式](https://www.runoob.com/w3cnote/state-vs-strategy.html)	<=	具体的看这篇文章

在行为类设计模式中，状态模式和策略模式是亲兄弟，两者非常相似，我们先看看两者的通用类图，把两者放在一起比较一下，如图所示：

![img](https://www.runoob.com/wp-content/uploads/2019/08/7462071-65db8284f6c254f6.png)

# 22. 空对象模式

​	在空对象模式（Null Object Pattern）中，一个空对象取代 NULL 对象实例的检查。Null 对象不是检查空值，而是反应一个不做任何动作的关系。这样的 Null 对象也可以在数据不可用的时候提供默认的行为。

​	在空对象模式中，我们创建一个指定各种要执行的操作的抽象类和扩展该类的实体类，还创建一个未对该类做任何实现的空对象类，该空对象类将无缝地使用在需要检查空值的地方。

## 22.1 实现

我们将创建一个定义操作（在这里，是客户的名称）的 *AbstractCustomer* 抽象类，和扩展了 *AbstractCustomer* 类的实体类。工厂类 *CustomerFactory* 基于客户传递的名字来返回 *RealCustomer* 或 *NullCustomer* 对象。

*NullPatternDemo*，我们的演示类使用 *CustomerFactory* 来演示空对象模式的用法。

![空对象模式的 UML 图](https://www.runoob.com/wp-content/uploads/2014/08/null_pattern_uml_diagram.jpg)

**步骤 1**

创建一个抽象类。

```java
public abstract class AbstractCustomer {
  protected String name;
  public abstract boolean isNil();
  public abstract String getName();
}
```

**步骤 2**

创建扩展了上述类的实体类。

```java
public class RealCustomer extends AbstractCustomer {

  public RealCustomer(String name) {
    this.name = name;    
  }

  @Override
  public String getName() {
    return name;
  }

  @Override
  public boolean isNil() {
    return false;
  }
}
```

```java
public class NullCustomer extends AbstractCustomer {

  @Override
  public String getName() {
    return "Not Available in Customer Database";
  }

  @Override
  public boolean isNil() {
    return true;
  }
}
```

**步骤 3**

创建 *CustomerFactory* 类。

```java
public class CustomerFactory {

  public static final String[] names = {"Rob", "Joe", "Julie"};

  public static AbstractCustomer getCustomer(String name){
    for (int i = 0; i < names.length; i++) {
      if (names[i].equalsIgnoreCase(name)){
        return new RealCustomer(name);
      }
    }
    return new NullCustomer();
  }
}
```

**步骤 4**

使用 *CustomerFactory*，基于客户传递的名字，来获取 *RealCustomer* 或 *NullCustomer* 对象。

```java
public class NullPatternDemo {
  public static void main(String[] args) {

    AbstractCustomer customer1 = CustomerFactory.getCustomer("Rob");
    AbstractCustomer customer2 = CustomerFactory.getCustomer("Bob");
    AbstractCustomer customer3 = CustomerFactory.getCustomer("Julie");
    AbstractCustomer customer4 = CustomerFactory.getCustomer("Laura");

    System.out.println("Customers");
    System.out.println(customer1.getName());
    System.out.println(customer2.getName());
    System.out.println(customer3.getName());
    System.out.println(customer4.getName());
  }
}
```

**步骤 5**

执行程序，输出结果：

```shell
Customers
Rob
Not Available in Customer Database
Julie
Not Available in Customer Database
```

# 23. * 策略模式

​	在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。

​	在策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的 context 对象。策略对象改变 context 对象的执行算法。

## 23.1 介绍

**意图：**定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。

**主要解决：**在有多种算法相似的情况下，使用 if...else 所带来的复杂和难以维护。

**何时使用：**一个系统有许多许多类，而区分它们的只是他们直接的行为。

**如何解决：**将这些算法封装成一个一个的类，任意地替换。

**关键代码：**实现同一个接口。

**应用实例：** 1、诸葛亮的锦囊妙计，每一个锦囊就是一个策略。 2、旅行的出游方式，选择骑自行车、坐汽车，每一种旅行方式都是一个策略。 3、JAVA AWT 中的 LayoutManager。

**优点：** 1、算法可以自由切换。 2、避免使用多重条件判断。 3、扩展性良好。

**缺点：** 1、策略类会增多。 2、所有策略类都需要对外暴露。

**使用场景：** <u>1、如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。 2、一个系统需要动态地在几种算法中选择一种。 3、如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现</u>。

**注意事项：**<u>如果一个系统的策略多于四个，就需要考虑使用混合模式，解决策略类膨胀的问题</u>。

## 23.2 实现

我们将创建一个定义活动的 *Strategy* 接口和实现了 *Strategy* 接口的实体策略类。*Context* 是一个使用了某种策略的类。

*StrategyPatternDemo*，我们的演示类使用 *Context* 和策略对象来演示 Context 在它所配置或使用的策略改变时的行为变化。

![策略模式的 UML 图](https://www.runoob.com/wp-content/uploads/2014/08/strategy_pattern_uml_diagram.jpg)

**步骤 1**

创建一个接口。

```java
public interface Strategy {
  public int doOperation(int num1, int num2);
}
```

**步骤 2**

创建实现接口的实体类。

```java
public class OperationAdd implements Strategy{
  @Override
  public int doOperation(int num1, int num2) {
    return num1 + num2;
  }
}
```

```java
public class OperationSubtract implements Strategy{
  @Override
  public int doOperation(int num1, int num2) {
    return num1 - num2;
  }
}
```

```java
public class OperationMultiply implements Strategy{
  @Override
  public int doOperation(int num1, int num2) {
    return num1 * num2;
  }
}
```

**步骤 3**

创建 *Context* 类。

```java
public class Context {
  private Strategy strategy;

  public Context(Strategy strategy){
    this.strategy = strategy;
  }
  public int executeStrategy(int num1, int num2){
    return strategy.doOperation(num1, num2);
  }
}
```

**步骤 4**

使用 *Context* 来查看当它改变策略 *Strategy* 时的行为变化。

```java
public class StrategyPatternDemo {
  public static void main(String[] args) {
    Context context = new Context(new OperationAdd());    
    System.out.println("10 + 5 = " + context.executeStrategy(10, 5));

    context = new Context(new OperationSubtract());      
    System.out.println("10 - 5 = " + context.executeStrategy(10, 5));

    context = new Context(new OperationMultiply());    
    System.out.println("10 * 5 = " + context.executeStrategy(10, 5));
  }
}
```

**步骤 5**

执行程序，输出结果：

```shell
10 + 5 = 15
10 - 5 = 5
10 * 5 = 50
```

## * 23.3 评论区补充

1. 与状态模式的比较

   ​	状态模式的类图和策略模式类似，并且都是能够动态改变对象的行为。但是**状态模式是通过状态转移来改变 Context 所组合的 State 对象，而策略模式是通过 Context 本身的决策来改变组合的 Strategy 对象。所谓的状态转移，是指 Context 在运行过程中由于一些条件发生改变而使得 State 对象发生改变，注意必须要是在运行过程中**。

   ​	<u>状态模式主要是用来解决状态转移的问题，当状态发生转移了，那么 Context 对象就会改变它的行为；而策略模式主要是用来封装一组可以互相替代的算法族，并且可以根据需要动态地去替换 Context 使用的算法</u>。

# 24. 模版模式

​	在模板模式（Template Pattern）中，一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。这种类型的设计模式属于行为型模式。

## 24.1 介绍

**意图：**定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。

**主要解决：**一些方法通用，却在每一个子类都重新写了这一方法。

**何时使用：**有一些通用的方法。

**如何解决：**将这些通用算法抽象出来。

**关键代码：**在抽象类实现，其他步骤在子类实现。

**应用实例：** 1、在造房子的时候，地基、走线、水管都一样，只有在建筑的后期才有加壁橱加栅栏等差异。 2、西游记里面菩萨定好的 81 难，这就是一个顶层的逻辑骨架。 3、<u>spring 中对 Hibernate 的支持，将一些已经定好的方法封装起来，比如开启事务、获取 Session、关闭 Session 等，程序员不重复写那些已经规范好的代码，直接丢一个实体就可以保存</u>。

**优点：** 1、封装不变部分，扩展可变部分。 2、提取公共代码，便于维护。 3、行为由父类控制，子类实现。

**缺点：**每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大。

**使用场景：** 1、有多个子类共有的方法，且逻辑相同。 2、重要的、复杂的方法，可以考虑作为模板方法。

**注意事项：**<u>为防止恶意操作，一般模板方法都加上 final 关键词</u>。

## 24.2 实现

我们将创建一个定义操作的 *Game* 抽象类，其中，模板方法设置为 final，这样它就不会被重写。*Cricket* 和 *Football* 是扩展了 *Game* 的实体类，它们重写了抽象类的方法。

*TemplatePatternDemo*，我们的演示类使用 *Game* 来演示模板模式的用法。

![模板模式的 UML 图](https://www.runoob.com/wp-content/uploads/2014/08/template_pattern_uml_diagram.jpg)

**步骤 1**

创建一个抽象类，它的模板方法被设置为 final。

```java
public abstract class Game {
  abstract void initialize();
  abstract void startPlay();
  abstract void endPlay();

  //模板
  public final void play(){
    //初始化游戏
    initialize();
    //开始游戏
    startPlay();
    //结束游戏
    endPlay();
  }
}
```

**步骤 2**

创建扩展了上述类的实体类。

```java
public class Cricket extends Game {
  @Override
  void endPlay() {
    System.out.println("Cricket Game Finished!");
  }
  @Override
  void initialize() {
    System.out.println("Cricket Game Initialized! Start playing.");
  }
  @Override
  void startPlay() {
    System.out.println("Cricket Game Started. Enjoy the game!");
  }
}
```

```java
public class Football extends Game {
  @Override
  void endPlay() {
    System.out.println("Football Game Finished!");
  }
  @Override
  void initialize() {
    System.out.println("Football Game Initialized! Start playing.");
  }
  @Override
  void startPlay() {
    System.out.println("Football Game Started. Enjoy the game!");
  }
}
```

**步骤 3**

使用 *Game* 的模板方法 play() 来演示游戏的定义方式。

```java
public class TemplatePatternDemo {
  public static void main(String[] args) {
    Game game = new Cricket();
    game.play();
    System.out.println();
    game = new Football();
    game.play();      
  }
}
```

**步骤 4**

执行程序，输出结果：

```
Cricket Game Initialized! Start playing.
Cricket Game Started. Enjoy the game!
Cricket Game Finished!

Football Game Initialized! Start playing.
Football Game Started. Enjoy the game!
Football Game Finished!
```

# 25. 访问者模式

​	在访问者模式（Visitor Pattern）中，我们使用了一个访问者类，它改变了元素类的执行算法。通过这种方式，<u>元素的执行算法可以随着访问者改变而改变</u>。这种类型的设计模式属于行为型模式。根据模式，元素对象已接受访问者对象，这样访问者对象就可以处理元素对象上的操作。

## 25.1 介绍

**意图：**主要将数据结构与数据操作分离。

**主要解决：**<u>稳定的数据结构和易变的操作耦合问题</u>。

**何时使用：**需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作"污染"这些对象的类，使用访问者模式将这些封装到类中。

**如何解决：**在被访问的类里面加一个对外提供接待访问者的接口。

**关键代码：**在数据基础类里面有一个方法接受访问者，将自身引用传入访问者。

**应用实例：**您在朋友家做客，您是访问者，朋友接受您的访问，您通过朋友的描述，然后对朋友的描述做出一个判断，这就是访问者模式。

**优点：** 1、符合单一职责原则。 2、优秀的扩展性。 3、灵活性。

**缺点：** 1、具体元素对访问者公布细节，违反了迪米特原则。 2、具体元素变更比较困难。 3、违反了依赖倒置原则，依赖了具体类，没有依赖抽象。

**使用场景：** 1、对象结构中对象对应的类很少改变，但经常需要在此对象结构上定义新的操作。 2、需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作"污染"这些对象的类，也不希望在增加新操作时修改这些类。

**注意事项：**访问者可以对功能进行统一，可以做报表、UI、拦截器与过滤器。

## 25.2 实现

我们将创建一个定义接受操作的 *ComputerPart* 接口。*Keyboard*、*Mouse*、*Monitor* 和 *Computer* 是实现了 *ComputerPart* 接口的实体类。我们将定义另一个接口 *ComputerPartVisitor*，它定义了访问者类的操作。*Computer* 使用实体访问者来执行相应的动作。

*VisitorPatternDemo*，我们的演示类使用 *Computer*、*ComputerPartVisitor* 类来演示访问者模式的用法。

![访问者模式的 UML 图](https://www.runoob.com/wp-content/uploads/2014/08/visitor_pattern_uml_diagram.jpg)

**步骤 1**

定义一个表示元素的接口。

```java
public interface ComputerPart {
  public void accept(ComputerPartVisitor computerPartVisitor);
}
```

**步骤 2**

创建扩展了上述类的实体类。

```java
public class Keyboard  implements ComputerPart {
  @Override
  public void accept(ComputerPartVisitor computerPartVisitor) {
    computerPartVisitor.visit(this);
  }
}
```

```java
public class Monitor  implements ComputerPart {
  @Override
  public void accept(ComputerPartVisitor computerPartVisitor) {
    computerPartVisitor.visit(this);
  }
}
```

```java
public class Mouse  implements ComputerPart {
  @Override
  public void accept(ComputerPartVisitor computerPartVisitor) {
    computerPartVisitor.visit(this);
  }
}
```

```java
public class Computer implements ComputerPart {
  ComputerPart[] parts;
  public Computer(){
    parts = new ComputerPart[] {new Mouse(), new Keyboard(), new Monitor()};      
  } 
  @Override
  public void accept(ComputerPartVisitor computerPartVisitor) {
    for (int i = 0; i < parts.length; i++) {
      parts[i].accept(computerPartVisitor);
    }
    computerPartVisitor.visit(this);
  }
}
```

**步骤 3**

定义一个表示访问者的接口。

```java
public interface ComputerPartVisitor {
  public void visit(Computer computer);
  public void visit(Mouse mouse);
  public void visit(Keyboard keyboard);
  public void visit(Monitor monitor);
}
```

**步骤 4**

创建实现了上述类的实体访问者。

```java
public class ComputerPartDisplayVisitor implements ComputerPartVisitor {
  @Override
  public void visit(Computer computer) {
    System.out.println("Displaying Computer.");
  }
  @Override
  public void visit(Mouse mouse) {
    System.out.println("Displaying Mouse.");
  }
  @Override
  public void visit(Keyboard keyboard) {
    System.out.println("Displaying Keyboard.");
  }
  @Override
  public void visit(Monitor monitor) {
    System.out.println("Displaying Monitor.");
  }
}
```

**步骤 5**

使用 *ComputerPartDisplayVisitor* 来显示 *Computer* 的组成部分。

```java
public class VisitorPatternDemo {
  public static void main(String[] args) {
    ComputerPart computer = new Computer();
    computer.accept(new ComputerPartDisplayVisitor());
  }
}
```

**步骤 6**

执行程序，输出结果：

```shell
Displaying Mouse.
Displaying Keyboard.
Displaying Monitor.
Displaying Computer.
```

# 26. MVC模式

MVC 模式代表 Model-View-Controller（模型-视图-控制器） 模式。这种模式用于应用程序的分层开发。

- **Model（模型）** - 模型代表一个存取数据的对象或 JAVA POJO。它也可以带有逻辑，在数据变化时更新控制器。
- **View（视图）** - 视图代表模型包含的数据的可视化。
- **Controller（控制器）** - 控制器作用于模型和视图上。它控制数据流向模型对象，并在数据变化时更新视图。它使视图与模型分离开。

![img](https://www.runoob.com/wp-content/uploads/2014/08/1200px-ModelViewControllerDiagram2.svg_.png)

## 26.1 实现

我们将创建一个作为模型的 *Student* 对象。*StudentView* 是一个把学生详细信息输出到控制台的视图类，*StudentController* 是负责存储数据到 *Student* 对象中的控制器类，并相应地更新视图 *StudentView*。

*MVCPatternDemo*，我们的演示类使用 *StudentController* 来演示 MVC 模式的用法。

![MVC 模式的 UML 图](https://www.runoob.com/wp-content/uploads/2014/08/mvc-2.svg)

**步骤 1**

创建模型。

```java
public class Student {
  private String rollNo;
  private String name;
  public String getRollNo() {
    return rollNo;
  }
  public void setRollNo(String rollNo) {
    this.rollNo = rollNo;
  }
  public String getName() {
    return name;
  }
  public void setName(String name) {
    this.name = name;
  }
}
```

**步骤 2**

创建视图。

```java
public class StudentView {
  public void printStudentDetails(String studentName, String studentRollNo){
    System.out.println("Student: ");
    System.out.println("Name: " + studentName);
    System.out.println("Roll No: " + studentRollNo);
  }
}
```

**步骤 3**

创建控制器。

```java
public class StudentController {
  private Student model;
  private StudentView view;

  public StudentController(Student model, StudentView view){
    this.model = model;
    this.view = view;
  }

  public void setStudentName(String name){
    model.setName(name);    
  }

  public String getStudentName(){
    return model.getName();    
  }

  public void setStudentRollNo(String rollNo){
    model.setRollNo(rollNo);      
  }

  public String getStudentRollNo(){
    return model.getRollNo();     
  }

  public void updateView(){           
    view.printStudentDetails(model.getName(), model.getRollNo());
  }  
}
```

**步骤 4**

使用 *StudentController* 方法来演示 MVC 设计模式的用法。

```java
public class MVCPatternDemo {
  public static void main(String[] args) {

    //从数据库获取学生记录
    Student model  = retrieveStudentFromDatabase();

    //创建一个视图：把学生详细信息输出到控制台
    StudentView view = new StudentView();

    StudentController controller = new StudentController(model, view);

    controller.updateView();

    //更新模型数据
    controller.setStudentName("John");

    controller.updateView();
  }

  private static Student retrieveStudentFromDatabase(){
    Student student = new Student();
    student.setName("Robert");
    student.setRollNo("10");
    return student;
  }
}
```

**步骤 5**

执行程序，输出结果：

```
Student: 
Name: Robert
Roll No: 10
Student: 
Name: John
Roll No: 10
```

# 27. 业务代表模式

业务代表模式（Business Delegate Pattern）用于对表示层和业务层解耦。它基本上是用来减少通信或对表示层代码中的业务层代码的远程查询功能。在业务层中我们有以下实体。

- **客户端（Client）** - 表示层代码可以是 JSP、servlet 或 UI java 代码。
- **业务代表（Business Delegate）** - 一个为客户端实体提供的入口类，它提供了对业务服务方法的访问。
- **查询服务（LookUp Service）** - 查找服务对象负责获取相关的业务实现，并提供业务对象对业务代表对象的访问。
- **业务服务（Business Service）** - 业务服务接口。实现了该业务服务的实体类，提供了实际的业务实现逻辑。

## 27.1 实现

我们将创建 *Client*、*BusinessDelegate*、*BusinessService*、*LookUpService*、*JMSService* 和 *EJBService* 来表示业务代表模式中的各种实体。

*BusinessDelegatePatternDemo* 类使用 *BusinessDelegate* 和 *Client* 来演示业务代表模式的用法。

![业务代表模式的 UML 图](https://www.runoob.com/wp-content/uploads/2014/08/business.svg)

**步骤 1**

创建 BusinessService 接口。

```java
public interface BusinessService {
  public void doProcessing();
}
```

**步骤 2**

创建实体服务类。

```java
public class EJBService implements BusinessService {
  @Override
  public void doProcessing() {
    System.out.println("Processing task by invoking EJB Service");
  }
}
```

```java
public class JMSService implements BusinessService {
  @Override
  public void doProcessing() {
    System.out.println("Processing task by invoking JMS Service");
  }
}
```

**步骤 3**

创建业务查询服务。

```java
public class BusinessLookUp {
  public BusinessService getBusinessService(String serviceType){
    if(serviceType.equalsIgnoreCase("EJB")){
      return new EJBService();
    }else {
      return new JMSService();
    }
  }
}
```

**步骤 4**

创建业务代表。

```java
public class BusinessDelegate {
  private BusinessLookUp lookupService = new BusinessLookUp();
  private BusinessService businessService;
  private String serviceType;

  public void setServiceType(String serviceType){
    this.serviceType = serviceType;
  }

  public void doTask(){
    businessService = lookupService.getBusinessService(serviceType);
    businessService.doProcessing();     
  }
}
```

**步骤 5**

创建客户端。

```java
public class Client {

  BusinessDelegate businessService;

  public Client(BusinessDelegate businessService){
    this.businessService  = businessService;
  }

  public void doTask(){      
    businessService.doTask();
  }
}
```

**步骤 6**

使用 BusinessDelegate 和 Client 类来演示业务代表模式。

```java
public class BusinessDelegatePatternDemo {

  public static void main(String[] args) {

    BusinessDelegate businessDelegate = new BusinessDelegate();
    businessDelegate.setServiceType("EJB");

    Client client = new Client(businessDelegate);
    client.doTask();

    businessDelegate.setServiceType("JMS");
    client.doTask();
  }
}
```

**步骤 7**

执行程序，输出结果：

```shell
Processing task by invoking EJB Service
Processing task by invoking JMS Service
```

# 28. 组合实体模式

组合实体模式（Composite Entity Pattern）用在 EJB 持久化机制中。一个组合实体是一个 EJB 实体 bean，代表了对象的图解。当更新一个组合实体时，内部依赖对象 beans 会自动更新，因为它们是由 EJB 实体 bean 管理的。以下是组合实体 bean 的参与者。

- **组合实体（Composite Entity）** - 它是主要的实体 bean。它可以是粗粒的，或者可以包含一个粗粒度对象，用于持续生命周期。
- **粗粒度对象（Coarse-Grained Object）** - 该对象包含依赖对象。它有自己的生命周期，也能管理依赖对象的生命周期。
- **依赖对象（Dependent Object）** - 依赖对象是一个持续生命周期依赖于粗粒度对象的对象。
- **策略（Strategies）** - 策略表示如何实现组合实体。

## 28.1 实现

我们将创建作为组合实体的 *CompositeEntity* 对象。*CoarseGrainedObject* 是一个包含依赖对象的类。

*CompositeEntityPatternDemo*，我们的演示类使用 *Client* 类来演示组合实体模式的用法。

![组合实体模式的 UML 图](https://www.runoob.com/wp-content/uploads/2014/08/compositeentity_pattern_uml_diagram.jpg)

**步骤 1**

创建依赖对象。

```java
public class DependentObject1 {

  private String data;

  public void setData(String data){
    this.data = data; 
  } 
  public String getData(){
    return data;
  }
}
```

```java
public class DependentObject2 {

  private String data;

  public void setData(String data){
    this.data = data; 
  } 
  public String getData(){
    return data;
  }
}
```

**步骤 2**

创建粗粒度对象。

```java
public class CoarseGrainedObject {
  DependentObject1 do1 = new DependentObject1();
  DependentObject2 do2 = new DependentObject2();

  public void setData(String data1, String data2){
    do1.setData(data1);
    do2.setData(data2);
  }
  public String[] getData(){
    return new String[] {do1.getData(),do2.getData()};
  }
}
```

**步骤 3**

创建组合实体。

```java
public class CompositeEntity {
  private CoarseGrainedObject cgo = new CoarseGrainedObject();

  public void setData(String data1, String data2){
    cgo.setData(data1, data2);
  }
  public String[] getData(){
    return cgo.getData();
  }
}
```

**步骤 4**

创建使用组合实体的客户端类。

```java
public class Client {
  private CompositeEntity compositeEntity = new CompositeEntity();

  public void printData(){
    for (int i = 0; i < compositeEntity.getData().length; i++) {
      System.out.println("Data: " + compositeEntity.getData()[i]);
    }
  }
  public void setData(String data1, String data2){
    compositeEntity.setData(data1, data2);
  }
}
```

**步骤 5**

使用 *Client* 来演示组合实体设计模式的用法。

```java
public class CompositeEntityPatternDemo {
  public static void main(String[] args) {
    Client client = new Client();
    client.setData("Test", "Data");
    client.printData();
    client.setData("Second Test", "Data1");
    client.printData();
  }
}
```

**步骤 6**

执行程序，输出结果：

```
Data: Test
Data: Data
Data: Second Test
Data: Data1
```

# 29. 数据访问对象模式

数据访问对象模式（Data Access Object Pattern）或 DAO 模式用于把低级的数据访问 API 或操作从高级的业务服务中分离出来。以下是数据访问对象模式的参与者。

- **数据访问对象接口（Data Access Object Interface）** - 该接口定义了在一个模型对象上要执行的标准操作。
- **数据访问对象实体类（Data Access Object concrete class）** - 该类实现了上述的接口。该类负责从数据源获取数据，数据源可以是数据库，也可以是 xml，或者是其他的存储机制。
- **模型对象/数值对象（Model Object/Value Object）** - 该对象是简单的 POJO，包含了 get/set 方法来存储通过使用 DAO 类检索到的数据。

## 29.1 实现

我们将创建一个作为模型对象或数值对象的 *Student* 对象。*StudentDao* 是数据访问对象接口。*StudentDaoImpl* 是实现了数据访问对象接口的实体类。*DaoPatternDemo*，我们的演示类使用 *StudentDao* 来演示数据访问对象模式的用法。

![数据访问对象模式的 UML 图](https://www.runoob.com/wp-content/uploads/2014/08/dao_pattern_uml_diagram.jpg)

**步骤 1**

创建数值对象。

```java
public class Student {
  private String name;
  private int rollNo;

  Student(String name, int rollNo){
    this.name = name;
    this.rollNo = rollNo;
  }

  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }

  public int getRollNo() {
    return rollNo;
  }

  public void setRollNo(int rollNo) {
    this.rollNo = rollNo;
  }
}
```

**步骤 2**

创建数据访问对象接口。

```java
import java.util.List;

public interface StudentDao {
  public List<Student> getAllStudents();
  public Student getStudent(int rollNo);
  public void updateStudent(Student student);
  public void deleteStudent(Student student);
}
```

**步骤 3**

创建实现了上述接口的实体类。

```java
import java.util.ArrayList;
import java.util.List;

public class StudentDaoImpl implements StudentDao {

  //列表是当作一个数据库
  List<Student> students;

  public StudentDaoImpl(){
    students = new ArrayList<Student>();
    Student student1 = new Student("Robert",0);
    Student student2 = new Student("John",1);
    students.add(student1);
    students.add(student2);    
  }
  @Override
  public void deleteStudent(Student student) {
    students.remove(student.getRollNo());
    System.out.println("Student: Roll No " + student.getRollNo() 
                       +", deleted from database");
  }

  //从数据库中检索学生名单
  @Override
  public List<Student> getAllStudents() {
    return students;
  }

  @Override
  public Student getStudent(int rollNo) {
    return students.get(rollNo);
  }

  @Override
  public void updateStudent(Student student) {
    students.get(student.getRollNo()).setName(student.getName());
    System.out.println("Student: Roll No " + student.getRollNo() 
                       +", updated in the database");
  }
}
```

**步骤 4**

使用 *StudentDao* 来演示数据访问对象模式的用法。

```java
public class DaoPatternDemo {
  public static void main(String[] args) {
    StudentDao studentDao = new StudentDaoImpl();

    //输出所有的学生
    for (Student student : studentDao.getAllStudents()) {
      System.out.println("Student: [RollNo : "
                         +student.getRollNo()+", Name : "+student.getName()+" ]");
    }


    //更新学生
    Student student =studentDao.getAllStudents().get(0);
    student.setName("Michael");
    studentDao.updateStudent(student);

    //获取学生
    studentDao.getStudent(0);
    System.out.println("Student: [RollNo : "
                       +student.getRollNo()+", Name : "+student.getName()+" ]");      
  }
}
```

**步骤 5**

执行程序，输出结果：

```shell
Student: [RollNo : 0, Name : Robert ]
Student: [RollNo : 1, Name : John ]
Student: Roll No 0, updated in the database
Student: [RollNo : 0, Name : Michael ]
```

# 30. 前端控制器模式

前端控制器模式（Front Controller Pattern）是用来提供一个集中的请求处理机制，所有的请求都将由一个单一的处理程序处理。该处理程序可以做认证/授权/记录日志，或者跟踪请求，然后把请求传给相应的处理程序。以下是这种设计模式的实体。

- **前端控制器（Front Controller）** - 处理应用程序所有类型请求的单个处理程序，应用程序可以是基于 web 的应用程序，也可以是基于桌面的应用程序。
- **调度器（Dispatcher）** - 前端控制器可能使用一个调度器对象来调度请求到相应的具体处理程序。
- **视图（View）** - 视图是为请求而创建的对象。

## 30.1 实现

我们将创建 *FrontController*、*Dispatcher* 分别当作前端控制器和调度器。*HomeView* 和 *StudentView* 表示各种为前端控制器接收到的请求而创建的视图。

*FrontControllerPatternDemo*，我们的演示类使用 *FrontController* 来演示前端控制器设计模式。

![前端控制器模式的 UML 图](https://www.runoob.com/wp-content/uploads/2014/08/frontcontroller_pattern_uml_diagram.jpg)

**步骤 1**

创建视图。

```java
public class HomeView {
  public void show(){
    System.out.println("Displaying Home Page");
  }
}
```

```java
public class StudentView {
  public void show(){
    System.out.println("Displaying Student Page");
  }
}
```

**步骤 2**

创建调度器 Dispatcher。

```java
public class Dispatcher {
  private StudentView studentView;
  private HomeView homeView;
  public Dispatcher(){
    studentView = new StudentView();
    homeView = new HomeView();
  }

  public void dispatch(String request){
    if(request.equalsIgnoreCase("STUDENT")){
      studentView.show();
    }else{
      homeView.show();
    }  
  }
}
```

**步骤 3**

创建前端控制器 FrontController。

```java
public class FrontController {

  private Dispatcher dispatcher;

  public FrontController(){
    dispatcher = new Dispatcher();
  }

  private boolean isAuthenticUser(){
    System.out.println("User is authenticated successfully.");
    return true;
  }

  private void trackRequest(String request){
    System.out.println("Page requested: " + request);
  }

  public void dispatchRequest(String request){
    //记录每一个请求
    trackRequest(request);
    //对用户进行身份验证
    if(isAuthenticUser()){
      dispatcher.dispatch(request);
    }  
  }
}
```

**步骤 4**

使用 *FrontController* 来演示前端控制器设计模式。

```java
public class FrontControllerPatternDemo {
  public static void main(String[] args) {
    FrontController frontController = new FrontController();
    frontController.dispatchRequest("HOME");
    frontController.dispatchRequest("STUDENT");
  }
}
```

**步骤 5**

执行程序，输出结果：

```shell
Page requested: HOME
User is authenticated successfully.
Displaying Home Page
Page requested: STUDENT
User is authenticated successfully.
Displaying Student Page
```

# 31. 拦截过滤器模式

拦截过滤器模式（Intercepting Filter Pattern）用于对应用程序的请求或响应做一些预处理/后处理。定义过滤器，并在把请求传给实际目标应用程序之前应用在请求上。过滤器可以做认证/授权/记录日志，或者跟踪请求，然后把请求传给相应的处理程序。以下是这种设计模式的实体。

- **过滤器（Filter）** - 过滤器在请求处理程序执行请求之前或之后，执行某些任务。
- **过滤器链（Filter Chain）** - 过滤器链带有多个过滤器，并在 Target 上按照定义的顺序执行这些过滤器。
- **Target** - Target 对象是请求处理程序。
- **过滤管理器（Filter Manager）** - 过滤管理器管理过滤器和过滤器链。
- **客户端（Client）** - Client 是向 Target 对象发送请求的对象。

## 31.1 实现

我们将创建 *FilterChain*、*FilterManager*、*Target*、*Client* 作为表示实体的各种对象。*AuthenticationFilter* 和 *DebugFilter* 表示实体过滤器。

*InterceptingFilterDemo* 类使用 *Client* 来演示拦截过滤器设计模式。

![拦截过滤器模式的 UML 图](https://www.runoob.com/wp-content/uploads/2014/08/20201015-intercepting.svg)

**步骤 1**

创建过滤器接口 Filter。

```java
public interface Filter {
  public void execute(String request);
}
```

**步骤 2**

创建实体过滤器。

```java
public class AuthenticationFilter implements Filter {
  public void execute(String request){
    System.out.println("Authenticating request: " + request);
  }
}
```

```java
public class DebugFilter implements Filter {
  public void execute(String request){
    System.out.println("request log: " + request);
  }
}
```

**步骤 3**

创建 Target。

```java
public class Target {
  public void execute(String request){
    System.out.println("Executing request: " + request);
  }
}
```

**步骤 4**

创建过滤器链。

```java
import java.util.ArrayList;
import java.util.List;

public class FilterChain {
  private List<Filter> filters = new ArrayList<Filter>();
  private Target target;

  public void addFilter(Filter filter){
    filters.add(filter);
  }

  public void execute(String request){
    for (Filter filter : filters) {
      filter.execute(request);
    }
    target.execute(request);
  }

  public void setTarget(Target target){
    this.target = target;
  }
}
```

**步骤 5**

创建过滤管理器。

```java
public class FilterManager {
  FilterChain filterChain;

  public FilterManager(Target target){
    filterChain = new FilterChain();
    filterChain.setTarget(target);
  }
  public void setFilter(Filter filter){
    filterChain.addFilter(filter);
  }

  public void filterRequest(String request){
    filterChain.execute(request);
  }
}
```

**步骤 6**

创建客户端 Client。

```java
public class Client {
  FilterManager filterManager;

  public void setFilterManager(FilterManager filterManager){
    this.filterManager = filterManager;
  }

  public void sendRequest(String request){
    filterManager.filterRequest(request);
  }
}
```

**步骤 7**

使用 *Client* 来演示拦截过滤器设计模式。

```java
public class InterceptingFilterDemo {
  public static void main(String[] args) {
    FilterManager filterManager = new FilterManager(new Target());
    filterManager.setFilter(new AuthenticationFilter());
    filterManager.setFilter(new DebugFilter());

    Client client = new Client();
    client.setFilterManager(filterManager);
    client.sendRequest("HOME");
  }
}
```

**步骤 8**

执行程序，输出结果：

```
Authenticating request: HOME
request log: HOME
Executing request: HOME
```

# 32. 服务定位器模式

服务定位器模式（Service Locator Pattern）用在我们想使用 JNDI 查询定位各种服务的时候。考虑到为某个服务查找 JNDI 的代价很高，服务定位器模式充分利用了缓存技术。在首次请求某个服务时，服务定位器在 JNDI 中查找服务，并缓存该服务对象。当再次请求相同的服务时，服务定位器会在它的缓存中查找，这样可以在很大程度上提高应用程序的性能。以下是这种设计模式的实体。

- **服务（Service）** - 实际处理请求的服务。对这种服务的引用可以在 JNDI 服务器中查找到。
- **Context / 初始的 Context** - JNDI Context 带有对要查找的服务的引用。
- **服务定位器（Service Locator）** - 服务定位器是通过 JNDI 查找和缓存服务来获取服务的单点接触。
- **缓存（Cache）** - 缓存存储服务的引用，以便复用它们。
- **客户端（Client）** - Client 是通过 ServiceLocator 调用服务的对象。

## 32.1 实现

我们将创建 *ServiceLocator*、*InitialContext*、*Cache*、*Service* 作为表示实体的各种对象。*Service1* 和 *Service2* 表示实体服务。

*ServiceLocatorPatternDemo* 类在这里是作为一个客户端，将使用 *ServiceLocator* 来演示服务定位器设计模式。

![服务定位器模式的 UML 图](https://www.runoob.com/wp-content/uploads/2014/08/20201015-service-locator.svg)

**步骤 1**

创建服务接口 Service。

```java
public interface Service {
  public String getName();
  public void execute();
}
```

**步骤 2**

创建实体服务。

```java
public class Service1 implements Service {
  public void execute(){
    System.out.println("Executing Service1");
  }

  @Override
  public String getName() {
    return "Service1";
  }
}
```

```java
public class Service2 implements Service {
  public void execute(){
    System.out.println("Executing Service2");
  }

  @Override
  public String getName() {
    return "Service2";
  }
}
```

**步骤 3**

为 JNDI 查询创建 InitialContext。

```java
public class InitialContext {
  public Object lookup(String jndiName){
    if(jndiName.equalsIgnoreCase("SERVICE1")){
      System.out.println("Looking up and creating a new Service1 object");
      return new Service1();
    }else if (jndiName.equalsIgnoreCase("SERVICE2")){
      System.out.println("Looking up and creating a new Service2 object");
      return new Service2();
    }
    return null;      
  }
}
```

**步骤 4**

创建缓存 Cache。

```java
import java.util.ArrayList;
import java.util.List;

public class Cache {

  private List<Service> services;

  public Cache(){
    services = new ArrayList<Service>();
  }

  public Service getService(String serviceName){
    for (Service service : services) {
      if(service.getName().equalsIgnoreCase(serviceName)){
        System.out.println("Returning cached  "+serviceName+" object");
        return service;
      }
    }
    return null;
  }

  public void addService(Service newService){
    boolean exists = false;
    for (Service service : services) {
      if(service.getName().equalsIgnoreCase(newService.getName())){
        exists = true;
      }
    }
    if(!exists){
      services.add(newService);
    }
  }
}
```

**步骤 5**

创建服务定位器。

```java
public class ServiceLocator {
  private static Cache cache;

  static {
    cache = new Cache();    
  }

  public static Service getService(String jndiName){

    Service service = cache.getService(jndiName);

    if(service != null){
      return service;
    }

    InitialContext context = new InitialContext();
    Service service1 = (Service)context.lookup(jndiName);
    cache.addService(service1);
    return service1;
  }
}
```

**步骤 6**

使用 *ServiceLocator* 来演示服务定位器设计模式。

```java
public class ServiceLocatorPatternDemo {
  public static void main(String[] args) {
    Service service = ServiceLocator.getService("Service1");
    service.execute();
    service = ServiceLocator.getService("Service2");
    service.execute();
    service = ServiceLocator.getService("Service1");
    service.execute();
    service = ServiceLocator.getService("Service2");
    service.execute();      
  }
}
```

**步骤 7**

执行程序，输出结果：

```shell
Looking up and creating a new Service1 object
Executing Service1
Looking up and creating a new Service2 object
Executing Service2
Returning cached  Service1 object
Executing Service1
Returning cached  Service2 object
Executing Service2
```

## 32.2 评论区补充

1. 步骤讲解

   步骤1 和步骤2，主要表现接口之间的多态性，指定行为方式。

   步骤3：也就是工厂模式的应用，通过类名来确定要实例化的对象。

   步骤4：用的是下面的传输对象模式。对实体类集合进行操作，主要是在集合中 获取/添加 实体类对象。

   步骤5定位器：使用步骤3来创建实例，使用步骤4来添加到集合，或者从集合中获取。（缓存中没有才会创建） 

   步骤6: 调用步骤5得到实体类，并执行实体类的方法

# 33. 传输对象模式

传输对象模式（Transfer Object Pattern）用于从客户端向服务器一次性传递带有多个属性的数据。传输对象也被称为数值对象。传输对象是一个具有 getter/setter 方法的简单的 POJO 类，它是可序列化的，所以它可以通过网络传输。它没有任何的行为。服务器端的业务类通常从数据库读取数据，然后填充 POJO，并把它发送到客户端或按值传递它。对于客户端，传输对象是只读的。客户端可以创建自己的传输对象，并把它传递给服务器，以便一次性更新数据库中的数值。以下是这种设计模式的实体。

- **业务对象（Business Object）** - 为传输对象填充数据的业务服务。
- **传输对象（Transfer Object）** - 简单的 POJO，只有设置/获取属性的方法。
- **客户端（Client）** - 客户端可以发送请求或者发送传输对象到业务对象。

## 33.1 实现

我们将创建一个作为业务对象的 *StudentBO* 和作为传输对象的 *StudentVO*，它们都代表了我们的实体。

*TransferObjectPatternDemo* 类在这里是作为一个客户端，将使用 *StudentBO* 和 *Student* 来演示传输对象设计模式。

![传输对象模式的 UML 图](https://www.runoob.com/wp-content/uploads/2014/08/20201015-transfer.svg)

**步骤 1**

创建传输对象。

```java
public class StudentVO {
  private String name;
  private int rollNo;

  StudentVO(String name, int rollNo){
    this.name = name;
    this.rollNo = rollNo;
  }

  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }

  public int getRollNo() {
    return rollNo;
  }

  public void setRollNo(int rollNo) {
    this.rollNo = rollNo;
  }
}
```

**步骤 2**

创建业务对象。

```java
import java.util.ArrayList;
import java.util.List;

public class StudentBO {

  //列表是当作一个数据库
  List<StudentVO> students;

  public StudentBO(){
    students = new ArrayList<StudentVO>();
    StudentVO student1 = new StudentVO("Robert",0);
    StudentVO student2 = new StudentVO("John",1);
    students.add(student1);
    students.add(student2);    
  }
  public void deleteStudent(StudentVO student) {
    students.remove(student.getRollNo());
    System.out.println("Student: Roll No " 
                       + student.getRollNo() +", deleted from database");
  }

  //从数据库中检索学生名单
  public List<StudentVO> getAllStudents() {
    return students;
  }

  public StudentVO getStudent(int rollNo) {
    return students.get(rollNo);
  }

  public void updateStudent(StudentVO student) {
    students.get(student.getRollNo()).setName(student.getName());
    System.out.println("Student: Roll No " 
                       + student.getRollNo() +", updated in the database");
  }
}
```

**步骤 3**

使用 *StudentBO* 来演示传输对象设计模式。

```java
public class TransferObjectPatternDemo {
  public static void main(String[] args) {
    StudentBO studentBusinessObject = new StudentBO();

    //输出所有的学生
    for (StudentVO student : studentBusinessObject.getAllStudents()) {
      System.out.println("Student: [RollNo : "
                         +student.getRollNo()+", Name : "+student.getName()+" ]");
    }

    //更新学生
    StudentVO student =studentBusinessObject.getAllStudents().get(0);
    student.setName("Michael");
    studentBusinessObject.updateStudent(student);

    //获取学生
    studentBusinessObject.getStudent(0);
    System.out.println("Student: [RollNo : "
                       +student.getRollNo()+", Name : "+student.getName()+" ]");
  }
}
```

**步骤 4**

执行程序，输出结果：

```shell
Student: [RollNo : 0, Name : Robert ]
Student: [RollNo : 1, Name : John ]
Student: Roll No 0, updated in the database
Student: [RollNo : 0, Name : Michael ]
```

